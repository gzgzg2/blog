<!DOCTYPE html>
<html lang="en"><head>
	<link rel="icon" type="image/png" href="/public/favicon/favicon.ico">
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="나비랑 나리 주인님의 블로그" /></head>
<style>@import url(/public/css/syntax/monokai.css);</style>
  <title>나비랑 나리 주인님의 블로그</title>
  <!-- <link href="/public/css/bootstrap.min.css" rel="stylesheet"> -->

  <link href="/public/css/style.css" rel="stylesheet">
  <body>
  	<div class="container"> 
		<div class="sidebar">
			<div class="sidebar-item sidebar-header">
	<div class='sidebar-brand'>
		<a href="/about/">나비랑 나리 주인님의 블로그</a>
	</div>
	<div class='sidebar-brand'>
		<div class="profile-image">
			<img src="/public/img/navi_3.jpeg"></img>
		</div>
	</div>
	<p class="lead">잠자는 시간이 제일 좋아</p></div>


<div class="sidebar-item sidebar-nav">
	<ul class="nav">
      <li class="nav-title">Pages</li>
	  <li>
	  	<a class="nav-item" href="/">Articles</a>
	  </li>
	  
	  
	    
	  
	    
	      
	        <li>
	        	<a class="nav-item" href="/about/">
	            	About
	            </a>
	        </li>
	      
	    
	  
	    
	      
	    
	  
	    
	  
	    
	  
	</ul>
</div>

<div class="sidebar-item sidebar-nav">
  	<ul class="nav">
			<li class="nav-title">Categories</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#SpringBoot">
				<span class="name">SpringBoot</span>
				<span class="badge">1</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#Tobi">
				<span class="name">Tobi</span>
				<span class="badge">1</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#OS">
				<span class="name">OS</span>
				<span class="badge">12</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#networkStudy">
				<span class="name">networkStudy</span>
				<span class="badge">2</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#Web">
				<span class="name">Web</span>
				<span class="badge">1</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#daily">
				<span class="name">daily</span>
				<span class="badge">1</span>
	    	</a>
 		</li>
	    
	  </nav>
	</ul>
</div>

<div class="sidebar-item sidebar-footer">
	<p>Powered by <a href="https://github.com/jekyll/jekyll">Jekyll</a></p>
</div>
		</div>
		<div class="content">
			<article class="post">
	<header class="post-header">
		<div class="post-title"> 
			[운영체제 스터디] 메모리 관리 - 논리적 주소와 물리적 주소
		</div>
		<time class="post-date dt-published" datetime="2022-04-15T00:00:00+09:00" itemprop="datePublished">2022/04/15
		</time>		
	</header>

	<div class="post-content">
		<p>🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟</p>

<h1 id="️memory-management-1">🗳️ Memory Management 1</h1>

<h2 id="1-논리적-주소와-물리적-주소">1. 논리적 주소와 물리적 주소</h2>

<p><strong>✔️  논리적 주소란(Logical address)?</strong></p>

<ul>
  <li>프로세스마다 독립적으로 가지는 주소 공간</li>
  <li>각 프로세스마다 0번지부터 시작</li>
  <li>CPU가 보는 주소는 <strong>logical address</strong>이다.</li>
</ul>

<p><strong>✔️  물리적 주소란(Logical address)?</strong></p>

<ul>
  <li>실제 메모리에 올라가는 위치</li>
</ul>

<h3 id="12-주소-바인딩address-binding">1.2 주소 바인딩(Address Binding)</h3>

<blockquote>
  <p>프로세스의 물리적 메모리 주소를 결정하는 것</p>

  <p>Symbolic Address → Logical Address → Physical Address</p>

  <p>🌟 <strong>Symbolic Address?</strong> 프로그래머가 사용하는 심볼릭한 주소</p>

</blockquote>

<p>✔️ <strong>사용자 프로그램</strong></p>

<ul>
  <li>logical address만을 다룬다</li>
  <li>실제 physical address를 볼 수 없으며 알 필요가 없다</li>
</ul>

<p>✔️ <strong>Compile time binding</strong></p>

<ul>
  <li>물리적 메모리 주소(physical address)가 컴파일 시 알려짐</li>
  <li>시작 위치 변경시 재컴파일</li>
  <li>컴파일러는 절대 코드(absolute code) 생성</li>
</ul>

<p>❗ <strong>논리적 메모리 주소가 물리적 메모리의 주소가 되므로 여유있는 메모리 공간이 있어도 고정적인 메모리 주소를 갖기 때문에 비효율적</strong></p>

<p>✔️  <strong>Load time binding</strong></p>

<ul>
  <li>프로그램 실행 시 물리적 주소가 결정되는 방식</li>
  <li>컴파일러가 재배치 가능한 코드를 생성한 경우 발생 가능</li>
</ul>

<p>✔️  <strong>Run time binding</strong></p>

<ul>
  <li>프로그램 실행 도중 물리적 메모리 주소가 변경될 수 있는 방식</li>
  <li>CPU가 주소를 참조할 때마다 binding을 점검해야 함 (address mapping table)</li>
  <li>하드웨어적인 지원이 필요함
    <ul>
      <li>(base and limit registers, <strong>MMU</strong>)</li>
    </ul>
  </li>
  <li>현대에서 주로 사용되는 방식</li>
</ul>

<p>✔️ <strong>Memory-Management Unit (MMU)?</strong></p>

<ul>
  <li>MMU
    <ul>
      <li>logical address를 physical address로 매핑해 주는 Hardware device</li>
    </ul>
  </li>
  <li>MMU scheme
    <ul>
      <li>사용자 프로세스가 CPU에서 수행되며 생성해내는 모든 주소값에 대해 base register (=relocation register)의 값을 더한다</li>
    </ul>
  </li>
</ul>

<p>💡 <strong>운영체제 및 사용자 프로세스 간의 메모리 보호를 위해 사용하는 레지스터</strong></p>

<ul>
  <li>relocation register
    <ul>
      <li>프로세스의 물리적 메모리 시작위치를 저장한다 (접근할 수 있는 물리적 메모리 주소의 최소값)</li>
    </ul>
  </li>
  <li>limit register
    <ul>
      <li>물리적 메모리 주소의 한계영역을 지정하기 위해 프로그램의 최대 크기를 저장한다.</li>
      <li>논리적 주소의 범위 (프로그램의 최대 크기)
        <ul>
          <li>예를 들어 P1의 시작 주소가 14000이고 프로그램의 크기가 3000일 때 P1은 14000~17000 사이만 접근할 수 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="2-some-terminologies">2. Some Terminologies</h2>

<h3 id="1-dynamic-loading">1. Dynamic Loading</h3>

<ul>
  <li>프로세스 전체를 메모리에 미리 다 올리는 것이 아니라 해당 루틴이 불려질  때 메모리에 load하는 것</li>
  <li>memory utilization의 향상</li>
  <li>가끔식 사용되는 많은 양의 코드의 경우 유용
    <ul>
      <li>ex) 오류 처리 루틴</li>
    </ul>
  </li>
  <li>운영체제의 특별한 지원 없이 프로그램 자체에서 구현 가능(OS는 라이브러리를 통해 프로그래머를 지원함)</li>
</ul>

<h3 id="2-overlays">2. Overlays</h3>

<ul>
  <li>메모리에 프로세스의 부분 중 실제 필요한 정보만을 올림</li>
  <li>프로세스의 크기가 메모리보다 클 때 유용</li>
  <li>운영체제의 지원없이 사용자에 의해 구현</li>
  <li>작은 공간의 메모리를 사용하던 초창기 시스템에서 수작업으로 프로그래머가 구현
    <ul>
      <li>Manual Overlay</li>
      <li>프로그래밍이 매우 복잡함</li>
      <li>Dynamic Loading과 비슷한 역할을 하지만 OS의 지원이 하나도 없다는 점에서 차이가 있음</li>
    </ul>
  </li>
</ul>

<h3 id="3-dynamic-linking">3. Dynamic Linking</h3>

<p>Linking을 실행 시간(execution time)까지 미루는 기법</p>

<p>✔️ <strong>Static Linking</strong></p>

<ul>
  <li>라이브러리가 프로그램의 실행 파일 코드에 포함됨</li>
  <li>실행 파일의 크기가 커짐</li>
  <li>동일한 라이브러리를 각각의 프로세스가 메모리에 올리므로 메모리 낭비
    <ul>
      <li>ex) printf를 호출하는 n개의 프로세스가 있으면 동일한 라이브러리여도 각각 printf 함수의 라이브러리를 메모리에 올리게 됨</li>
    </ul>
  </li>
</ul>

<p>✔️ <strong>Dynamic linking</strong></p>

<ul>
  <li>라이브러리가 실행시 연결(link)됨</li>
  <li>라이브러리 호출 부분에 라이브러리 루틴의 위치를 찾기 위한 stub이라는 작은 코드를 둠</li>
  <li>라이브러리가 이미 메모리에 있으면 그 루틴의 주소로 가고 없으면 디스크에서 읽어옴</li>
  <li>운영체제의 도움이 필요함</li>
  <li>Dynamic linking을 지원하는 라이브러리를 shared library 라고 함
    <ul>
      <li>window → DLL</li>
      <li>linux → shared object</li>
    </ul>
  </li>
</ul>

<h3 id="4-swapping">4. Swapping</h3>

<blockquote>
  <p>프로세스를 일시적으로 메모리에서 backing store로 쫓아내는 것</p>

  <ul>
    <li><strong>Backing store(=swap area)?</strong>
      <ul>
        <li>디스크
          <ul>
            <li>많은 사용자의 프로세스 이미지를 담을 만큼 충분히 빠르고 큰 저장 공간</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>✔️ <strong>Swap in / Swap out</strong></p>

<ul>
  <li>일반적으로 중기 스케줄러(swapper)에 의해 swap out 시킬 프로세스 선정</li>
  <li>priority-based CPU scheduling algorithm
    <ul>
      <li>CPU 우선순위가 낮은 프로세스를 swapped out 시킴</li>
      <li>CPU 우선순위가 높은 프로세스를 메모리에 올려놓음</li>
    </ul>
  </li>
  <li>Complie time 혹은 load time binding에서는 다른 메모리 공간이 비어있더라도 원래 메모리 위치로 swap in 해야 함</li>
  <li>Execution time binding에서는 추후 빈 메모리 영역 아무 곳에나 올릴 수 있음</li>
  <li>swap time은 대부분 transfer time(swap되는 양에 비례하는 시간)임</li>
  <li>원칙적으로 프로세스 전체가 메모리에서 쫓겨나는 것을 Swap out 이라고 하지만 프로세스 일부분이 쫓겨나는 것도 swap out 이라고 부르기도 한다.</li>
</ul>

<h2 id="3-물리적-메모리-관리">3. 물리적 메모리 관리</h2>

<p>✔️ <strong>메모리는 일반적으로 두 영역으로 나눠어서 사용 됨</strong></p>

<ul>
  <li>OS 상주 영역(커널)
    <ul>
      <li>interrupt vector와 함께 낮은 주소 영역 사용</li>
    </ul>
  </li>
  <li>사용자 프로세스 영역</li>
</ul>

<p>✔️ <strong>사용자 프로세스 영역의 할당 방법</strong></p>

<ul>
  <li><strong>Contiguous allocation(연속할당)</strong>
    <ul>
      <li>각각의 프로세스가 메모리의 연속적인 공간에 적재되도록 하는 것
        <ul>
          <li>Fixed partition allocation</li>
          <li>Variable partition allocation</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Noncontiguous allocation(불연속할당)</strong>
    <ul>
      <li>현대 시스템의 사용 방법</li>
      <li>하나의 프로세스가 메모리의 여러 영역에 분산되어 올라갈 수 있음
        <ul>
          <li>Paging</li>
          <li>Segmentation</li>
          <li>Paged Segmentation</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>✔️ <strong>외부조각과 내부조각</strong> </p>

<ul>
  <li>External fragmentation(외부 조각)
    <ul>
      <li>프로그램 크기보다 분할의 크기가 작은 경우</li>
      <li>아무 프로그램에도 배정되지 않은 빈 곳인데도 프로그램이 올라갈 수 없는 작은 분할</li>
    </ul>
  </li>
  <li>Internal Fragmentation(내부 조각)
    <ul>
      <li>프로그램 크기보다 분할의 크기가 큰 경우</li>
      <li>하나의 분할 내부에서 발생하는 사용되지 않는 메모리 조각</li>
      <li>분할에 배정된 프로그램보다 분할의 크기가 더 커서 생기는 사용되지 않는 메모리 공간</li>
    </ul>
  </li>
</ul>

<h2 id="4-contiguous-allocation연속할당">4. Contiguous allocation(연속할당)</h2>

<h3 id="41-fixed-partition고정분할">4.1 <strong>Fixed partition(고정분할)</strong></h3>

<ul>
  <li>물리적 메모리를 몇 개의 영구적 분할(partition)으로 나눔</li>
  <li>분할의 크기가 모두 동일한 방식과  서로 다른 방식이 존재</li>
  <li>분할당 하나의 프로그램 적재</li>
  <li>융통성이 없음
    <ul>
      <li>동시에 메모리에 load되는 프로그램의 수가 고정됨</li>
      <li>최대 수행 가능 프로그램 크기 제한</li>
    </ul>
  </li>
  <li>internal fragmentation(=내부조각) 과  external fragmentation(=외부조각) 발생</li>
</ul>

<h3 id="42-variable-partition가변분할">4.2 <strong>Variable partition(가변분할)</strong></h3>

<ul>
  <li>프로그램의 크기를 고려해서 할당</li>
  <li>분할의 크기, 개수가 동적으로 변함</li>
  <li>기술적 관리 기법 필요</li>
  <li>external fragmentation(=외부조각) 발생</li>
</ul>

<p>1️⃣  <strong>Hole</strong></p>

<ul>
  <li>가용 메모리 공간</li>
  <li>다양한 크기의 hole들이 메모리 여러 곳에 흩어져 있음</li>
  <li>프로세스가 도착하면 수용가능한 hole을 할당</li>
  <li>운영체제는 다음의 정보를 유지
    <ul>
      <li>a) 할당 공간 b) 가용 공간(hole)</li>
    </ul>
  </li>
</ul>

<p>2️⃣  <strong>Dynamic Storage-Allocation Problem</strong></p>

<ul>
  <li>가변 분할 방식에서 size n인 요청을 만족하는 가능 적절한 hole을 찾는 문제</li>
  <li><strong>First-fit</strong>
    <ul>
      <li>Size가 n 이상인 것 중 최초로 찾아지는 hole에 할당</li>
      <li>셋 중 오버헤드가 가장 적음</li>
    </ul>
  </li>
  <li><strong>Best-fit</strong>
    <ul>
      <li>Size가 n 이상인 가장 작은 hole을 찾아서 할당</li>
      <li>Hole들의 리스트가 크기순으로 정렬되지 않은 경우 모든 hole의 리스트를 탐색해야함</li>
      <li>많은 수의 아주 작은 hole들이 생성됨</li>
    </ul>
  </li>
  <li><strong>Worst-fit</strong>
    <ul>
      <li>가장 큰 hole에 할당</li>
      <li>역시 모든 리스트를 탐색해야 함</li>
      <li>상대적으로 아주 큰 hole들이 생성됨</li>
    </ul>
  </li>
</ul>

<p><strong>🌟 First-fit과 Best-fit이 Worst-fit보다 속도와 공간 이용률 측면에서 횩하적인 것으로 알려짐 (실험적 결과)</strong></p>

<p>3️⃣  <strong>Compaction</strong></p>

<ul>
  <li>external fragmentation 문제를 해결하는 한 가지 방법</li>
  <li>사용 중인 메모리 영역을 한군데로 몰고 hole들을 다른 한 곳으로 몰아 큰 block을 만드는 것</li>
  <li>전체 프로그램 바인딩과 관련되어 있기 때문에 비용이 많이 듬</li>
  <li>최소한의 메모리 이동으로 compaction하는 방법 (매우 복잡한 문제)</li>
  <li>Compcation은 프로세스의 주소가 실행 시간에 동적으로 재배치 가능한 경우에만 수행될 수 있다.
    <ul>
      <li>Runtime binding이 지원되어야 사용 가능함</li>
    </ul>
  </li>
</ul>

<h3 id="reference"><strong>Reference</strong></h3>

<hr />

<p>이화여자대학교 반효경 교수님 운영체제 강의</p>

	</div>
	<script src="https://utteranc.es/client.js"
        repo="gzgzg2/blog-comments"
        issue-term="pathname"
        label="Comment 🐱"
        theme="github-light"
        crossorigin="anonymous"
        async>
	</script>
</article>
		</div>
	</div>
  </body>
</html>