<!DOCTYPE html>
<html lang="en"><head>
	<link rel="icon" type="image/png" href="/public/favicon/favicon.ico">
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="나비랑 나리 주인님의 블로그" /></head>
<style>@import url(/public/css/syntax/monokai.css);</style>
  <title>나비랑 나리 주인님의 블로그</title>
  <!-- <link href="/public/css/bootstrap.min.css" rel="stylesheet"> -->

  <link href="/public/css/style.css" rel="stylesheet">
  <body>
  	<div class="container"> 
		<div class="sidebar">
			<div class="sidebar-item sidebar-header">
	<div class='sidebar-brand'>
		<a href="/about/">나비랑 나리 주인님의 블로그</a>
	</div>
	<div class='sidebar-brand'>
		<div class="profile-image">
			<img src="/public/img/navi_3.jpeg"></img>
		</div>
	</div>
	<p class="lead">잠자는 시간이 제일 좋아</p></div>


<div class="sidebar-item sidebar-nav">
	<ul class="nav">
      <li class="nav-title">Pages</li>
	  <li>
	  	<a class="nav-item" href="/">Articles</a>
	  </li>
	  
	  
	    
	  
	    
	      
	        <li>
	        	<a class="nav-item" href="/about/">
	            	About
	            </a>
	        </li>
	      
	    
	  
	    
	      
	    
	  
	    
	  
	    
	  
	</ul>
</div>

<div class="sidebar-item sidebar-nav">
  	<ul class="nav">
			<li class="nav-title">Categories</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#SpringBoot">
				<span class="name">SpringBoot</span>
				<span class="badge">1</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#Tobi">
				<span class="name">Tobi</span>
				<span class="badge">1</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#OS">
				<span class="name">OS</span>
				<span class="badge">12</span>
	    	</a>
 		</li>
	    
	    <li>
	    	<a class="nav-item" href="/category/#networkStudy">
				<span class="name">networkStudy</span>
				<span class="badge">1</span>
	    	</a>
 		</li>
	    
	  </nav>
	</ul>
</div>

<div class="sidebar-item sidebar-footer">
	<p>Powered by <a href="https://github.com/jekyll/jekyll">Jekyll</a></p>
</div>
		</div>
		<div class="content">
			<article class="post">
	<header class="post-header">
		<div class="post-title"> 
			[운영체제 스터디] 컴퓨터 구조와 컴퓨터 시스템 동작원리
		</div>
		<time class="post-date dt-published" datetime="2022-03-15T00:00:00+09:00" itemprop="datePublished">2022/03/15
		</time>		
	</header>

	<div class="post-content">
		<p>🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟</p>

<h2 id="1-컴퓨터-구조">1. 컴퓨터 구조</h2>

<p><img src="https://user-images.githubusercontent.com/56028408/157796926-1bb83571-56ea-404a-b551-048cb898fdaf.png" alt="https://user-images.githubusercontent.com/56028408/157796926-1bb83571-56ea-404a-b551-048cb898fdaf.png" /></p>

<p>✔️ 전문가적 입장에서 컴퓨터를 말할 때, 보통 CPU와 Memory를 말한다.</p>

<p>✔️ 컴퓨터는 CPU, Memory, I/O Device, Disk, 네트워크 장비들로 이뤄져있다.</p>

<h2 id="2-컴퓨터-시스템-구조">2. 컴퓨터 시스템 구조</h2>

<p>✔️  CPU</p>

<ul>
  <li>CPU는 매 클럭사이클 마다 메모리에서 instruction을 하나씩 읽어서 실행한다.</li>
  <li>instruction 수행이 종료되면 Interrupt Line을 체크하고 인터럽트 신호가 확인되면 수행한다.</li>
</ul>

<p>✔️  Modebit</p>

<ul>
  <li>사용자가 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치</li>
  <li>하드웨어적으로 두 가지 모드의 Operation 지원
    <ul>
      <li>1 → 사용자 모드로 사용자 프로그램을 실행한다.</li>
      <li>0 → 커널모드로 OS 코드를 실행한다</li>
    </ul>
  </li>
  <li>보안을 해칠 수 있는 중요한 명령어는 커널 모드에서만 수행 가능한 특권명령으로 규정한다.</li>
  <li>Interrupt나 Exeception이 발생하면 하드웨어가 mode bit를 0으로 변경하여 운영체제에게 CPU를 할당한다.</li>
  <li>커널모드에서 작업이 끝나면 사용자모드로 변경하기 전에 mode bit를 1으로 변경한다.</li>
</ul>

<p>✔️  Timer</p>

<ul>
  <li>특정 프로그램이 CPU를 독점하는 것을 방지하기위한 장치</li>
  <li>운영체제가 사용자 프로그램에게 CPU를 넘겨줄 때 Timer에 값을 지정해서 넘겨준다.</li>
  <li>타이머 값이 0이 되면 타이머가 CPU에게 인터럽트 신호를 발신한다.</li>
  <li>타이머는 time sharing을 구현하기 위해 널리 이용됨</li>
  <li>타이머는 현재 시간을 계산하기 위해서도 사용됨</li>
</ul>

<p>✔️  Memory</p>

<ul>
  <li>메모리는 CPU가 처리할 데이터나 명령어가 임시로 저장되는 곳으로 작업 공간 역할을 한다.</li>
  <li>컴퓨터 작업을 할 때 하드디스크에 있는 데이터는 먼저 메모리로 이동된 다음 CPU로 전송된다.
    <ul>
      <li>프로그램 실행도 이와 마찬가지로 CPU가 메모리에 저장되어 있는 용량만큼 프로그램을 작동시킨다.</li>
    </ul>
  </li>
</ul>

<p>✔️  I/O Device</p>

<ul>
  <li>각각의 I/O Device는 각 디바이스를 전담하는 Controller를 가지고 있다.</li>
  <li>Controller는 각 I/O 디바이스의 내부를 통제하는 작업을 담당한다. CPU에게 인터럽트를 발생시키는 것도 Controller가 담당한다.</li>
  <li>I/O Device는 CPU에 비해 처리속도가 상당히 느리다</li>
  <li>I/O Device는 모두 각각의 Local Buffer를 가지고 있다.</li>
  <li>I/O는 실제 device와 local buffer 사이에서 일어남</li>
</ul>

<p>✔️ I/O Device Controller</p>

<ul>
  <li>I/O 장치유형을 관리하는 일종의 작은 CPU</li>
  <li>제어 정보를 위해 control register, status register를 가짐</li>
  <li>local buffer를 가짐 (일종의 data register)</li>
  <li>Device controller는 I/O가 끝났을 경우 인터럽트로 CPU에 그 사실을 알림</li>
</ul>

<p>✔️ DMA Controller</p>

<ul>
  <li>CPU와 동일하게 직접 메모리에 접근 가능한 컨트롤러</li>
  <li>I/O device의 작업이 종료되어 localBuffer에 데이터가 적재되면 DMA 컨트롤러가 하드웨어 인터럽트를 CPU 대신 수신하여 데이터를 메모리에 복사한 후 합쳐서 CPU에게 인터럽트를 보낸다</li>
</ul>

<p>✔️ 인터럽트 (Interrupt)</p>

<ul>
  <li>인터럽트 당한 시점의 레지스터와 프로그램 카운터를 저장한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다.</li>
  <li>넓은 의미의 인터럽트
    <ul>
      <li>interuppt (하드웨어 인터럽트) : 하드웨어가 발생시킨 인터럽트</li>
      <li>trap (소프트웨어 인터럽트)</li>
    </ul>
  </li>
  <li>Exception: 프로그램이 오류를 범한 경우</li>
  <li>System Call: 프로그램이 커널함수를 호출하는 경우</li>
  <li>인터럽트 관련 용어
    <ul>
      <li>인터럽트 백터
        <ul>
          <li>해당 인터럽트의 처리 루틴 주소를 가지고 있다.</li>
        </ul>
      </li>
      <li>인터럽트 처리 루틴
        <ul>
          <li>해당 인터럽트를 처리하는 커널 함수</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="3-입출력-io의-수행">3. 입출력 (I/O)의 수행</h2>

<ul>
  <li>모든 입출력 명령은 특권 명령이다.</li>
  <li>사용자 프로그램이 I/O를 하는 방식
    <ul>
      <li>시스템콜(system call)</li>
      <li>사용자 프로그램이 운영체제의 서비스를 받기위해 호출하는 것</li>
    </ul>
  </li>
  <li>trap을 사용하여 인터럽트 벡터의 특정 위치로 이동</li>
  <li>제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동</li>
  <li>올바른 I/O 요청인지 확인 후 I/O 수행</li>
  <li>I/O 완료 시 제어권을 시스템콜 다음 명령으로 옮김</li>
</ul>

<h2 id="3-동기식-입출력">3. 동기식 입출력</h2>

<p>✔️ 동기식 입출력은 어떤 프로그램이 입출력 요청을 했을 때</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>입출력 작업이 완료된 후에야 그 프로그램이 후속 작업을 수행할 수 있는 방식을 말한다.
</code></pre></div></div>

<p>🌟  <strong>동기식 입출력의 실행 방식</strong> 🌟</p>

<blockquote>
  <p>동기식 입출력은 프로그램이 디스크에서 어떤 정보를 읽어오라는 요청을 했을 때 디스크 입출력이 진행되는 동안 그 프로그램의 다음 명령을 수행하지 않고 기다린다.
그러다가 입출력이 완료되어 인터럽트를 통해 완료 사실이 전달된 후에야 CPU의 제어권이 해당 프로그램에게 넘어간다.</p>
</blockquote>

<p>따라서 동기식 입출력에서 CPU는 입출력 연산이 끝날 때까지 인터럽트를 기다리며 자원을 낭비하게 된다.
한편 CPU의 명령 수행 속도는 빠르지만 입출력 장치에서 데이터를 읽어오는 등의 입출력 연산은 상대적으로 느리다.</p>

<p>그럼에도 불구하고 입출력이 완료될 때까지 대기했다가 사용자 프로그램에게 CPU의 제어권을 넘기는 방식은 자원 낭비를 초래한다.</p>

<p>따라서 일반적으로 프로그램이 입출력을 수행 중인 경우 CPU를 입출력을 실행한 프로그램에게서 빼앗아 다른 프로그램에게 할당하고 입출력을 수행중인 프로그램은 봉쇄상태로 변경한다.</p>
<blockquote>

</blockquote>

<h2 id="4-비동기식-입출력">4. 비동기식 입출력</h2>

<p>비동기식 입출력은 프로그램이 디스크 정보를 요청하더라도 프로그램을 봉쇄상태로 이동하지 않고 다음 작업을 수행한다.</p>

<p>🌟  비<strong>동기식 입출력의 실행 방식</strong> 🌟</p>

<blockquote>
  <p>비동기식 입출력은 입출력 연산을 요청한 후에 연산이 끝나기를 기다리는 것이 아니라</p>

  <p>CPU의 제어권을 입출력 연산을 호출한 그 프로그램에게 곧바로 다시 부여하는 것을 말한다.</p>

  <p>어떤 프로그램이 데이터를 디스크에서 읽어오라는 요청을 했을 때 보통은 읽어온 결과를 이용해서 다음 연산을 수행하지만 경우에 따라서는 그 데이터와 관련없이 수행할 수 있는 일이 있을 것이다.</p>

  <p>비동기식 입출력에서는 그러한 작업을 먼저 수행하고, 읽어오는 데이터가 반드시 이어야 수행할 수 있는 일들은 입출력이 완료된 후에 수행하게 된다.</p>

  <p>또한 디스크에서 읽어오는 요청이 아니라 디스크에 쓰는 요청이라면 쓰기 작업이 완료되기 전에도 다음 명령을 수행할 수 있으므로 비동기식 입출력이 사용될 수 있다.</p>

</blockquote>

<h2 id="5-프로그램의-구조와-실행">5. 프로그램의 구조와 실행</h2>

<p>✔️ 프로그램의 구조와 인터럽트</p>

<ul>
  <li>프로그램이 CPU에서 명령을 수행하려면 해당 명령을 담은 프로그램의 주소 영역이 메모리에 올라가 있어야 한다. 이때 프로그램의 주소 영역은 크게 코드, 데이터, 스택 영역으로 구분된다.</li>
</ul>

<p>✔️ 코드영역</p>

<ul>
  <li>코드영역은 작성한 프로그램의 함수들의 코드가 CPU에서 수행할 수 있는 기계어 명령 형태로 변환되어 저장되는 부분</li>
</ul>

<p>✔️ 데이터 영역</p>

<ul>
  <li>전역 변수 등 프로그램이 사용하는 데이터를 저장하는 부분</li>
</ul>

<p>✔️ 스택 영역</p>

<ul>
  <li>함수가 호출될 때 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는 데에 사용되는 공간</li>
</ul>

<p>✔️ 컴퓨터 시스템의 작동 개요</p>

<ul>
  <li>CPU는 빠른 속도로 처리하는 계산 능력은 가지고 있지만, 수행해야하는 작업을 스스로 결정하는 능력은 갖추고 있지 않다.</li>
  <li>
    <p>CPU는 매 시점 메모리의 특정 주소에 존재하는 명령어를 하나씩 읽어와서 그대로 실행한다.</p>

    <p>이때 CPU가 수행해야 할 메모리 주소를 담고 있는 레지스터를 프로그램 카운터라고 부른다.</p>
  </li>
  <li>CPU는 매번 프로그램 카운터가 가리키는 메모리 위치의 명령을 처리하게 된다.</li>
</ul>

<p>✔️ 프로그램의 실행</p>

<ul>
  <li>프로그램이 실행되고 있다는 것은 디스크에 존재하면 실행파일이 메모리에 적재된다는 의미와</li>
  <li>프로그램이 CPU를 할당받고 명령을 수행하고 있는 상태라는 의미이다.</li>
  <li>현재 수행 중인 프로그램을 프로세서(process)라고 부른다.</li>
  <li>각 프로그램은 코드, 데이터, 스택영역과 같은 주소 공간을 별도로 가진다</li>
  <li>프로그램마다 독자적으로 존재하는 주소공간을 가상메모리 또는 논리적 메모리라고 부른다.</li>
</ul>

<hr />

<p><strong>[질문 리스트]</strong></p>

<ol>
  <li>사용자 프로그램이 I/O를 요청했을 때 일어나는 일을 설명해보시오
    <ul>
      <li>사용자는 직접 입출력 장치에 접근할 수 없기 때문에 시스템 콜을 하여 운영체제에게 I/O 작업을 요청한다.
 운영체제는 요청받은 I/O 명령을 사용자 프로그램 모드가 아닌 커널 모드에서 해당 요청에 맞는 처리코드를 수행하게 된다.
 예를 들어 디스크에서 자료를 읽어오는 시스템 콜이라면, CPU가 디스크 컨트롤러에게 데이터를 읽어오라는 명령을 내린다.</li>
    </ul>
  </li>
  <li>DMA 컨트롤러의 기능을 설명해주세요.
    <ul>
      <li>CPU가 입출력 장치들의 메모리 접근 요청에 의해 자주 인터럽트 당하는 것을 막아주어서
 CPU에 발생하는 인터럽트의 빈도를 줄여 CPU를 효율적으로 관리할 수 있게 도와주는 역할을 한다.</li>
      <li>DMA를 사용하면 CPU가 로컬버퍼에서 메모리로 읽어오는 작업을 DMA가 대행한다.</li>
      <li>DMA는 바이트 단위가 아니라 블록이라는 큰 단위로 정보를 메모리로 읽어온 후에 CPU에게 인터럽트를 발생시켜 작업이 끝난 것을 알린다.</li>
    </ul>
  </li>
  <li>시스템콜에 대해 설명해보세요
    <ul>
      <li>시스템 콜이란 사용자 프로그램이 특권명령을 수행하기 위해 운영체제에게 해당 작업을 요청하는 행위이다.
 시스템 콜은 일종의 소프트웨어적인 인터럽스로서 사용자 프로그램이 시스템 콜을 할 경우 트랩이 발생해 CPU의 제어권이 운영체제로 넘어가게 된다.
 그러면 운영체제는 해당 시스템 콜을 처리하기 위한 루틴으로 가서 정의된 명령을 수행한다.</li>
    </ul>
  </li>
</ol>

	</div>
</article>
		</div>
	</div>
  </body>
</html>