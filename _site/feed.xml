<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-05-14T21:16:19+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">나비랑 나리 주인님의 블로그</title><subtitle>잠자는 시간이 제일 좋아</subtitle><entry><title type="html">[글또 7기] 나의 다짐</title><link href="http://localhost:4000/daily/2022/05/14/%EA%B8%80%EB%98%907%EA%B8%B0-%EB%8B%A4%EC%A7%90.html" rel="alternate" type="text/html" title="[글또 7기] 나의 다짐" /><published>2022-05-14T00:00:00+09:00</published><updated>2022-05-14T00:00:00+09:00</updated><id>http://localhost:4000/daily/2022/05/14/%EA%B8%80%EB%98%907%EA%B8%B0-%EB%8B%A4%EC%A7%90</id><content type="html" xml:base="http://localhost:4000/daily/2022/05/14/%EA%B8%80%EB%98%907%EA%B8%B0-%EB%8B%A4%EC%A7%90.html">&lt;h2 id=&quot;들어가며&quot;&gt;들어가며&lt;/h2&gt;
&lt;p&gt;읽기 좋은 글을 꾸준하게 작성하고 싶어서 &lt;a href=&quot;https://www.notion.so/zzsza/ac5b18a482fb4df497d4e8257ad4d516&quot;&gt;글또&lt;/a&gt;라는 개발자 커뮤니티에서 활동하게 되었다. 
꾸준하게 글을 작성하는 것이 목표인데….  5월 초에 포스팅한 이후로 인제야 글을 작성한다. 느슨해지지 않기 위해 활동하면서 이루고 싶은 목표들을 정하기로 결심 !&lt;/p&gt;

&lt;h2 id=&quot;참여한-이유&quot;&gt;참여한 이유&lt;/h2&gt;
&lt;h3 id=&quot;1-가독성-높은-글&quot;&gt;1. 가독성 높은 글&lt;/h3&gt;
&lt;p&gt;많은 글을 작성해보진 않았지만, 지금까지 포스팅했던 내용을 다시 읽어보면 가독성이 매우 떨어진다. 그리고 불친절한 설명 때문에 다른 사람이 내가 작성한 글을 읽었을 때 큰 혼란이 올 것 같았다. 이런 문제점을 어떻게 고쳐야 하나 고민하고 있을 때 운 좋게 발견한 것이 글또이다.&lt;/p&gt;

&lt;h3 id=&quot;2-게으름-탈출&quot;&gt;2. 게으름 탈출&lt;/h3&gt;
&lt;p&gt;강의를 듣거나 책을 읽는 것은 꾸준하게 하는 것이 어렵지 않은데 이상하게 글을 작성하려고 하면 게을러진다. 마음먹고 자리에 앉아도 포스팅하고 싶었던 내용을 정리하는 것이 그렇게 어렵다. 그래도 강제적으로 할 수밖에 없는 환경에 내던져지면 잘 적응하는 편이여서 글또는 나에게 딱 맞았다.&lt;/p&gt;

&lt;h3 id=&quot;3-학습한-내용-머릿속에-각인하기&quot;&gt;3. 학습한 내용 머릿속에 각인하기&lt;/h3&gt;
&lt;p&gt;가끔 학습한 내용을 전부 이해하지 못하고 그냥 지나칠 때 내용을 전부 잊어먹는 경우가 있다. 이럴 때 배운 내용을 다시 곱씹으면서 글로 작성하면 머릿속에 더 깊이 각인되는 효과가 있는 것 같다. 글또에서는 주로 공부한 내용을 포스팅할 것이기 때문에 글솜씨와 함께 나의 개발력도 상승하길 바라고 있다.&lt;/p&gt;

&lt;h2 id=&quot;목표&quot;&gt;목표&lt;/h2&gt;
&lt;h3 id=&quot;1-작성하고-싶은-글&quot;&gt;1. 작성하고 싶은 글&lt;/h3&gt;
&lt;p&gt;원래 글또를 신청했을 당시에는 참여했던 스터디 중 가장 만족도가 높았던 JSCODE 운영체제 스터디의 후기를 작성할 생각이었는데 마음이 변했다. 지금은 아래와 관련된 내용의 게시물을 포스팅할 생각이다. 전부 작성할 수 있을진 모르겠지만 일단 도전 !&lt;/p&gt;

&lt;p&gt;👊 &lt;strong&gt;작성하고 싶은 글 카테고리&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;읽었던 개발관련 도서 내용 정리&lt;/li&gt;
  &lt;li&gt;인상깊은 트러블슈팅 경험&lt;/li&gt;
  &lt;li&gt;Java의 모든 것 ?&lt;/li&gt;
  &lt;li&gt;Spring 뿌수기&lt;/li&gt;
  &lt;li&gt;컴퓨터 사이언스&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-내성적인-인간-탈출&quot;&gt;2. 내성적인 인간 탈출&lt;/h3&gt;
&lt;p&gt;매우 내성적인 성격이라 먼저 나서지도 못하고 말수도 적지만, 글또에서는 좋은 것들은 공유하고 많은 사람과 교류하면서 서로 좋은 영향을 나누고 싶다. 적극적인 사람으로 변할 수 있길 🙏🏻&lt;/p&gt;

&lt;h2 id=&quot;마치며&quot;&gt;마치며&lt;/h2&gt;
&lt;p&gt;6개월 동안 초라한 블로그를 화려하게 바꿀 수 있길 ! 이번에는 마감일에 가깝게 글을 작성하였는데 다음번에는 미루지 않고 부지런하게 작성해야겠다. 앞으로도 계속 마감일에 가깝게 글을 작성하면 글 쓰는 게으름을 많이 고치지 못할 것 같다. 그리고 나의 피드백이 많은 사람에게 도움이 되면 좋겠다 !! 글또 화이팅 !&lt;/p&gt;</content><author><name></name></author><category term="글또 7기" /><summary type="html">들어가며 읽기 좋은 글을 꾸준하게 작성하고 싶어서 글또라는 개발자 커뮤니티에서 활동하게 되었다. 꾸준하게 글을 작성하는 것이 목표인데…. 5월 초에 포스팅한 이후로 인제야 글을 작성한다. 느슨해지지 않기 위해 활동하면서 이루고 싶은 목표들을 정하기로 결심 !</summary></entry><entry><title type="html">DNS 란?</title><link href="http://localhost:4000/web/2022/05/01/dns.html" rel="alternate" type="text/html" title="DNS 란?" /><published>2022-05-01T00:00:00+09:00</published><updated>2022-05-04T00:00:00+09:00</updated><id>http://localhost:4000/web/2022/05/01/%08dns</id><content type="html" xml:base="http://localhost:4000/web/2022/05/01/dns.html">&lt;h2 id=&quot;브라우저에-wwwnavercom-입력하면&quot;&gt;브라우저에 “www.naver.com” 입력하면?&lt;/h2&gt;

&lt;p&gt;DNS가 무엇인지 알아보기 전에 먼저 브라우저에 “www.naver.com” 을 입력했을 때 벌어지는 일들의 일부만 간략하게 알아보자.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;브라우저 애플리케이션이 “도메인명”을 조회하는 DNS 리졸버 호출&lt;/li&gt;
  &lt;li&gt;DNS 리졸버가 DNS 서버에 보내는 조회 메시지를 생성&lt;/li&gt;
  &lt;li&gt;프로토콜 스택이 DNS 서버에 DNS 리졸버가 생성한 메시지를 송신&lt;/li&gt;
  &lt;li&gt;DNS 리졸버가 응답 결과를 수신&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;🤔 브라우저 애플리케이션이 “도메인명”을 조회한다고 했는데, 여기서 “도메인명” 이란 무엇을 말하는 걸까?&lt;/strong&gt; 
“www.naver.com”를 예시로 들었을 때 도메인명이란 www, naver, com 모두 해당된다. 보통 우리는 특정 웹사이트에 접속할 때 IP 주소가 아닌 도메인명을 입력해서 접속한다.&lt;/p&gt;

&lt;h2 id=&quot;dns-란&quot;&gt;DNS 란?&lt;/h2&gt;

&lt;p&gt;사용자는 특정 웹사이트의 도메인명이 아닌 실제 IP를 알 필요가 없다. 하지만 OS 내부에서 다른 서버에 패킷을 송신할 때는 도메인명이 아닌 IP 주소가 필요하다.
앞서 설명한 것처럼 브라우저 애플리케이션은 도메인명으로 해당 서버의 IP 주소를 조회한다. 그렇다면 DNS란 무엇일까? DNS는 도메인명에 해당하는 IP와 기타 정보를 저장해둔 서버이다. 보통 아래와 같은 정보가 저장되어 있다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;이름&lt;/th&gt;
      &lt;th&gt;클래스&lt;/th&gt;
      &lt;th&gt;타입&lt;/th&gt;
      &lt;th&gt;클라이언트에 회답하는 항목&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;www.example.com&lt;/td&gt;
      &lt;td&gt;IN&lt;/td&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;192.168.2.5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;example.com&lt;/td&gt;
      &lt;td&gt;IN&lt;/td&gt;
      &lt;td&gt;MX&lt;/td&gt;
      &lt;td&gt;192.168.2.6&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;✔️ 등록정보의 구성&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;이름
    &lt;ul&gt;
      &lt;li&gt;이름은 앞서 말한 도메인명에 해당된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;클래스
    &lt;ul&gt;
      &lt;li&gt;클래스는 네트워크의 종류를 나타낸다. IN은 인터넷을 뜻한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;타입
    &lt;ul&gt;
      &lt;li&gt;해당 도메인명에 어떤 타입의 정보가 지원되는지를 뜻한다. 예를 들면 MX는 메일의 배송 목적지, A는 도메인명에 IP 주소가 지원된다는 뜻&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;클라이언트에 회답하는 항목
    &lt;ul&gt;
      &lt;li&gt;이 항목은 도메인명에 해당하는 IP 주소를 의미한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;자 그러면 DNS에 등록되어 있는 정보도 알아보았다. 대충 살펴보면 도메인명으로 해당하는 IP를 매칭 해둔 서버인 것 같다.
그런데? 대체 왜 필요한 것일까?&lt;/p&gt;

&lt;h2 id=&quot;dns를-사용하는-이유&quot;&gt;DNS를 사용하는 이유&lt;/h2&gt;

&lt;p&gt;간단하게 전화번호부를 예로 들어보자. 평소에 우리는 지인들의 전화번호를 전부 외우지 못한다.
하지만 우리는 현대인이기 때문에 전화번호를 외우지 못하는 것이 아무런 문제가 되지 않는다. 전화번호를 전화번호부에 이름으로 저장해두면 되기 때문이다. 
DNS도 비슷한 맥락이다. 우리가 자주 접근하는 웹 사이트 전부를 IP 주소만을 사용해서 접근할 수 있다고 생각하면 너무 끔찍하다. 북마크 기능이 있지만 접근하는 사이트마다 북마크를 해놓을수도 없는 노릇이다. DNS 서버는 우리가 도메인명으로 웹 사이트에 접근할 수 있도록 해주는 아주 고마운 서버이다. 그런데 DNS 서버없이 그냥 도메인명으로 통신하면 안될까? 라는 의문도 들 수 있다. 
하지만 IP 주소는 32bit 만으로 이뤄져있는 반면에 도메인명은 수십 바이트부터 255 바이트까지 존재하기 때문에 라우터의 부하가 발생하여 통신이 지연될 수 있다.&lt;/p&gt;</content><author><name></name></author><category term="DNS" /><summary type="html">브라우저에 “www.naver.com” 입력하면?</summary></entry><entry><title type="html">[네트워크 스터디] Chapter_02 TCP/IP의 데이터를 전기 신호로 만들어 보낸다</title><link href="http://localhost:4000/networkstudy/2022/04/29/network-study-02.html" rel="alternate" type="text/html" title="[네트워크 스터디] Chapter_02 TCP/IP의 데이터를 전기 신호로 만들어 보낸다" /><published>2022-04-29T00:00:00+09:00</published><updated>2022-04-29T00:00:00+09:00</updated><id>http://localhost:4000/networkstudy/2022/04/29/network-study-02</id><content type="html" xml:base="http://localhost:4000/networkstudy/2022/04/29/network-study-02.html">&lt;h1 id=&quot;-chapter_02-tcpip의-데이터를-전기-신호로-만들어-보낸다&quot;&gt;📗 Chapter_02 TCP/IP의 데이터를 전기 신호로 만들어 보낸다&lt;/h1&gt;
&lt;h3 id=&quot;2장의-요점-짚고-넘어가기-&quot;&gt;🌟 2장의 요점 짚고 넘어가기 🌟&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Chapter 02에선 OS에 내장된 프로토콜 스택이 처음 등장한다. 프로토콜 스택은 네트워크 제어용 소프트웨어이다. 프로토콜 스택은 브라우저에서 받은 메세지를 패킷 속에 저장하고, 수신처 주소 등의 제어 정보를 덧붙인다. 프로토콜 스택은 통신 오류가 발생했을 때 패킷을 고쳐서 보내거나 통신의 기본을 조절하는 등의 다양한 역할을 한다.&lt;/p&gt;

  &lt;p&gt;이뿐만 아니라 프로토콜 스택은 패킷을 LAN어댑터(이더넷이나 무선 LAN으로 통신할 때 사용하는 하드웨어)에 넘긴다. 그리고 LAN 어댑터가 패킷을 전기신호로 변환하고 LAN의 케이블에 송출하는 과정을 통해 패킷이 네트워크 속으로 전달된다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;1-소켓을-작성한다&quot;&gt;&lt;strong&gt;1. 소켓을 작성한다.&lt;/strong&gt;&lt;/h2&gt;

&lt;h3 id=&quot;1️⃣프로토콜-스택의-내부-구성&quot;&gt;&lt;strong&gt;1️⃣ 프로토콜 스택의 내부 구성&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;아래 이미지는 브라우저에서 데이터를 전송했을 때 어떠한 소프트웨어와 하드웨어를 거쳐 서버에 도착하는 지&lt;/p&gt;

&lt;p&gt;간단하게 요약한 이미지이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56028408/164371689-8ed7cd05-d86f-4853-bbb5-9d900e6b5ef0.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;✔️ 네트워크 어플리케이션&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;브라우저, 메일러, 웹 서버, 메일 서버 등의 프로그램이 여기에 해당됨&lt;/li&gt;
  &lt;li&gt;네트워크 어플리케이션부터 아래로 향하여 데이터 송 수신 등의 일을 의뢰함&lt;/li&gt;
  &lt;li&gt;Socket
    &lt;ul&gt;
      &lt;li&gt;네트워크 애플리케이션 아랫부분에는 Socket 라이브러리가 존재하고 그 안에는 리졸버가 내장되어 있음&lt;/li&gt;
      &lt;li&gt;Socket 라이브러리는 DNS서버에서 목적지의 IP 주소를 조회하는 역할을 담당함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;✔️  프로토콜 스택&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로토콜 스택은 OS 내부에 존재하는 네트워크 제어용 소프트웨어이다.&lt;/li&gt;
  &lt;li&gt;TCP, UDP 프로토콜을 사용하는 소프트웨어
    &lt;ul&gt;
      &lt;li&gt;프로토콜 스택의 윗부분에는 TCP, UDP 프로토콜을 사용하여 데이터 송수신을 담당하는 부분이 존재한다. 이 둘이 어플리케이션의 의뢰를 받아 송수신 동작을 실행한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;IP 프로토콜을 사용하는 소프트웨어
    &lt;ul&gt;
      &lt;li&gt;데이터를 작게 나눈 패킷을 통신 상대까지 운반하는 것이 해당 소프트웨어의 주 역할&lt;/li&gt;
      &lt;li&gt;IP 안에는 ICMP와 ARP라는 프로토콜을 다루는 부분이 존재함&lt;/li&gt;
      &lt;li&gt;ICMP는 패킷을 운반할 때 발생하는 오류를 통지하거나 제어용 메세지를 통지할 때 사용됨&lt;/li&gt;
      &lt;li&gt;ARP는 IP 주소에 대응하는 이더넷의 MAC 주소를 조사할 때 사용됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;✔️ LAN 드라이버&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;LAN 어댑터의 하드웨어를 제어함&lt;/li&gt;
  &lt;li&gt;LAN 드라이버 아래에 있는 LAN 어댑터가 실제 송 수신 동작, 즉 케이블에 대해 신호를 송 수신 하는 동작을 실행함&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;💡 프로토콜&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;스택이란&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;네트워크&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;제어용&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;소프트웨어이다.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;프로토콜&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;스택은&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;제어&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;정보를&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;저장하거나&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;패킷을&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;LAN&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;어댑터에&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;넘기는&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;역할을&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;담당한다.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;💡 브라우저나&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;메일&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;등의&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;일반적인&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;애플리케이션이&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;데이터를&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;송&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;수신할&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;경우에는&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;TCP를&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;주로&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;사용&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;💡 DNS&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;서버에&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;대한&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;조회&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;등에서&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;짧은&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;제어용&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;데이터를&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;송수신할&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;경우에는&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;UDP 사용&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;✔️  소켓의 메세지 송신 동작&lt;/strong&gt;  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56028408/164371702-c3a06672-64e0-4ee6-8419-da6472697a41.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2️⃣소켓의-실체는-통신-제어용-제어-정보&quot;&gt;2️⃣ 소켓의 실체는 통신 제어용 제어 정보&lt;/h3&gt;

&lt;p&gt;프로토콜 스택은 내부에 제어 정보를 기록하는 메모리 영역을 가지고 있다. 해당 영역에는 통신 동작 제어에 필요한 제어 정보를 기록한다. 대표적으로 &lt;strong&gt;통신 상대의 IP주소, 포트번호, 통신 동작 진행 상태&lt;/strong&gt; 등이 있다.&lt;/p&gt;

&lt;p&gt;본래 소켓은 개념적인 것이고 실체가 존재하지 않는다. 굳이 말하자면 프로토콜 스택 내부에 저장된 제어 정보가 소켓의 실체라고 할 수 있다. 프로토콜 스택은 소켓에 기록된 제어 정보를 참조하면서 동작한다.&lt;/p&gt;

&lt;h3 id=&quot;3️⃣소켓을-호출했을-때의-동작&quot;&gt;3️⃣ 소켓을 호출했을 때의 동작&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;✔️  socket()&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;애플리케이션이 socket을 호출하여 프로토콜 스택에게 소켓을 만들 것을 의뢰한다. 이때 프로토콜 스택은 소켓 한 개 분량의 메모리 영역을 확보하고 초기 상태임을 나타내는 제어 정보를 기록한다. 이 과정을 통해 소켓이 생성된다.&lt;/li&gt;
  &lt;li&gt;소켓이 생성되면 소켓을 나타내는 디스크립터를 애플리케이션에 알려준다. 디스크립터는 프로토콜 스택의 내부에 있는 다수의 소켓 중 어느 것을 가리키는지 나타내는 번호표와 같다. 디스크립터는 프로토콜 스택이 데이터 송 수신 동작을 의뢰할 때 통지한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-서버에-접속한다&quot;&gt;2. 서버에 접속한다.&lt;/h2&gt;

&lt;h3 id=&quot;1️⃣접속의-의미&quot;&gt;&lt;strong&gt;1️⃣&lt;/strong&gt;  접속의 의미&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;이더넷이나 통신 회선은 항상 케이블이 연결되어 있으므로 데이터를 신호로 변환하여 송신하기만 하면 언제든 통신이 가능하다. 하지만 소켓을 만든 직후에는 아무런 정보도 기록되어 있지 않기 때문에 통신 상대와의 사이에 제어 정보를 주고받아서 데이터 송 수신이 가능한 상태로 만드는 작업이 필요하다. 여기에서 주고받는 제어정보는 IP나 포트번호 등이다. 접속 동작에서 주고받는 제어 정보는 통신의 규칙으로 정해져 있다.&lt;/p&gt;

  &lt;p&gt;접속을 시도할 때는 제어 정보를 주고받는 것 뿐만 아니라 송 수신 데이터를 일시적으로 저장할 버퍼 메모리 확보도 이때 같이 실행된다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;2️⃣맨-앞부분에-제어-정보를-기록한-헤더를-배치한다&quot;&gt;2️⃣ 맨 앞부분에 제어 정보를 기록한 헤더를 배치한다.&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;✔️  헤더란?&lt;/strong&gt; &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;헤더는 클라이언트와 서버가 서로 연락을 절충하기 위해 주고받는 정보가 포함되어 있다.&lt;/li&gt;
  &lt;li&gt;헤더에는 데이터를 송 수신 하는 동작이나 연결을 끊는 동작도 포함되어 있기 때문에 통신 동작 전체에서 필요한 내용을 검토하여 TCP 프로토콜의 사양으로 규정하고 있다.&lt;/li&gt;
  &lt;li&gt;클라이언트와 서버 사이에 주고받는 패킷 맨 앞부분부터 부가된 제어정보를 헤더라고 한다.&lt;/li&gt;
  &lt;li&gt;이더넷이나 IP에도 동일한 헤더가 존재하기 때문에 &lt;strong&gt;TCP 헤더, 이더넷 헤더(=Mac 헤더), IP헤더&lt;/strong&gt;와 같이 구분하여 사용해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;✔️  소켓에 기록되는 정보&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로토콜 스택의 동작을 제어하기 위한 정보
    &lt;ul&gt;
      &lt;li&gt;애플리케이션에서 통지된 정보&lt;/li&gt;
      &lt;li&gt;통신 상대로부터 받은 정보&lt;/li&gt;
      &lt;li&gt;송 수신 동작의 진행 상황&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로토콜 스택이 소켓에 기록된 정보를 참조하면서 움직이기 때문에 소켓의 제어 정보는 프로토콜 스택과 일체화 되어있다 해도 무방하다.&lt;/li&gt;
  &lt;li&gt;소켓에 기록되는 정보는 상대측에서 볼 수 없다. 이미 서로 필요한 정보를 헤더로 주고받기 때문에 통신에는 문제가 없다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;🌟 &lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;통신&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;동작에&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;이용하는&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;제어&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;정보는&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;다음의&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;두&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;종류&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;헤더에&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;기입되는&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;정보&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;소켓에&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;기록되는&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;정보&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3️⃣접속-동작의-실체&quot;&gt;3️⃣ 접속 동작의 실체&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;✔️ connet()&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;여기에 서버측의 IP 주소와 포트 번호를 입력하면 명령이 프로토콜 스택의 TCP 담당 부분에 전달된다.&lt;/li&gt;
  &lt;li&gt;그러면 TCP 담당 부분은 목적지 서버측의 TCP 담당 부분과의 사이에 제어 정보를 주고 받는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;✔️  클라이언트와 서버의 대화 과정&lt;/strong&gt; &lt;/p&gt;
&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;데이터&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;송&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;수신&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;동작의&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;개시를&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;나타내는&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;제어&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;정보를&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;기록한&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;헤더를&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;만든다.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;헤더의&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;내용&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;중&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;중요한&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;것은&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;송신처와&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;수신처의&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;포트번호이다.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;이를&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;통해&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;송신처와&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;수신처를&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;지정할&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;수&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;있다.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    
&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;TCP&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;헤더가&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;만들어지면&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;이를&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;IP&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;담당&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;소프트웨어에&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;건네주어&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;송신하도록&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;의뢰한다.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;송신&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;동작을&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;거쳐&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;네트워크를&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;통해&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;서버에&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;패킷이&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;도착하면&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;서버측의&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;IP&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;담당&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;소프트웨어가&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;이를&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;TCP&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;담당&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;소프트웨어&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;에게&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;전달한다.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;서버측의&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;TCP&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;담당&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;소프트웨어가&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;TCP헤더를&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;조사하여&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;기록되어&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;있는&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;수신처&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;포트&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;번호에&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;해당하는&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;소켓을&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;찾아낸다.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
   &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;해당하는&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;소켓이&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;발견되면&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;해당&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;소켓에&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;필요한&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;정보를&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;기록하고&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;접속&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;동작&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;상태를&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;진행&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;중으로&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;변경한다.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    
&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;)번&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;과정이&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;끝나면&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;서버의&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;TCP&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;담당&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;소프트웨어는&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;응답을&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;돌려보내기&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;위해&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;IP&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;담당&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;소프트웨어에게&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;의뢰한다.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 

&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;이때&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;ACK라는&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;컨트롤&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;비트도&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;로&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;설정하여&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;돌려보낸다.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 

&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;패킷이&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;클라이언트에게&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;정상적으로&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;돌아왔으면&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;TCP&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;헤더를&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;조사하여&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;서버측의&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;접속&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;동작이&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;성공했는&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;지&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;확인한다.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
   &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;서버&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;측의&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;접속이&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;성공했으면&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;클라이언트&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;소켓에&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;서버&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;IP&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;주소나&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;포트&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;번호&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;등과&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;함께&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;접속&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;완료를&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;나타내는&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;제어&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;정보를&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;기록한다.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    
&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;마지막으로&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;클라이언트에&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;패킷이&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;정상적으로&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;도착했다는&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;것을&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;알리기&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;위해&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;ACK&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;비트를&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;로&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;만든&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;TCP&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;헤더를&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;서버측에&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;반송한다.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;🌟 ACK는 패킷이 대상에게 잘 도착했는지 확인하는 용도로 사용된다.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-데이터를-송수신-한다&quot;&gt;3. 데이터를 송수신 한다.&lt;/h2&gt;

&lt;h3 id=&quot;1️⃣프로토콜-스택에--http-리퀘스트-메세지를-넘긴다&quot;&gt;&lt;strong&gt;1️⃣ 프로토콜 스택에  HTTP 리퀘스트 메세지를 넘긴다.&lt;/strong&gt;&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;connect에서 애플리케이션에 제어가 되돌아오면 데이터 송 수신 동작이 들어간다. 데이터 송 수신 동작은 애플리케이션이 &lt;strong&gt;✔️ write()&lt;/strong&gt; 를 호출하여 송신 데이터를 프로토콜 스택에 건네주는 곳부터 시작된다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;프로토콜 스택은 받은 데이터의 내용을 곧바로 송신하는 것이 아니라 일단 프로토콜 스택 내부의 송신용 버퍼 메모리 영역에 저장하고 애플리케이션이 다음 데이터를 건네주기를 기다린다.&lt;/p&gt;

&lt;p&gt;송신용 버퍼에 저장하는 이유는 애플리케이션에서 프로토콜 스택에 건네주는 데이터의 길이는 애플리케이션마다 상이하기 때문이다.  이러한 상황에서 받은 데이터를 곧바로 보내는 방법은 작은 패킷을 많이 보낼 수 있지만 네트워크 이용 효율이 저하되므로 어느 정도 데이터를 저장하고 나서 송 수신 동작을 진행한다.&lt;/p&gt;

&lt;p&gt;송신 버퍼에 어느 정도의 데이터가 담겼을 때 송신한다는 규칙은 OS의 종류나 버전마다 달라지지만 &lt;strong&gt;MTU&lt;/strong&gt;나 &lt;strong&gt;타이밍&lt;/strong&gt;을 바탕으로 어느정도 판단할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;✔️ MTU?&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;한 패킷으로 운반할 수 있는 디지털 데이터의 최대 길이 이더넷에서는 보통 1500 바이트&lt;/li&gt;
  &lt;li&gt;MTU에는 패킷의 맨 앞부분에 헤더가 포함되어 있음, 여기부터 헤더를 제외한 것이 하나의 패킷으로 운반할 수 있는 데이터의 최대 길이가 됨 이것을 &lt;strong&gt;MSS&lt;/strong&gt; 라고 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;✔️ MSS?&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;헤더를 제외하고 한 개의 패킷으로 운반할 수 있는 TCP의 데이터 최대 길이&lt;/li&gt;
  &lt;li&gt;애플리케이션에서 받은 데이터가 MSS를 초과하거나 MSS에 가까운 길이에 이르기까지 데이터를 저장하고 송신동작을 진행하면 패킷이 잘게 나눠질 걱정을 하지 않아도 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56028408/164371712-2c075fc2-7133-48aa-837b-c3bf552b4f15.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;✔️ &lt;strong&gt;타이밍?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;애플리케이션의 송신 속도가 느려지는 경우 MSS에 가깝게 데이터를 저장하면 여기에서 시간이 걸려 송신 동작이 지연되므로 버퍼에 데이터가 모이지 않아도 적당한 곳에서 송신 동작을 실행해야 한다. 따라서 프로토콜 스택은 일정한 시간이 경과하면 패킷을 송신할 수 있게 내부에 타이머라는 소프트웨어를 둔다.&lt;/p&gt;

&lt;p&gt;두 가지의 판단요소가 존재하지만 이 둘은 상반되는 면도 존재한다. &lt;strong&gt;MSS&lt;/strong&gt; 바탕을 중시하면 패킷 길이가 길어져서 네트워크 이용 효율이 높아지지만 버퍼에 머무는 시간만큼 송신 동작이 지연될 우려가 존재한다. 반대로 타이밍을 중시하면 지연은 적어지지만 이용 효율이 떨어지므로 양자를 절충해서 적당히 시간을 가늠하여 송신 동작을 실행해야 한다. 그러나 TCP 프로토콜 사양에는 절충에 대한 규약은 없으므로 실제 판단은 프로토콜 스택을 만드는 개발자의 몫이다.&lt;/p&gt;

&lt;h3 id=&quot;2️⃣데이터가-클-때는-분할하여-보낸다&quot;&gt;2️⃣ 데이터가 클 때는 분할하여 보낸다&lt;/h3&gt;

&lt;p&gt;HTTP 리퀘스트 메세지는 보통 그다지 길지 않은 것이 대부분이다. 하지만 항상 예외는 존재하기에 HTTP 리퀘스트 메세지가 한 개의 패킷에 전부 들어가지 못할 경우, 송신 버퍼에 들어있는 데이터를 맨 앞부터 차례대로 MSS의 크기에 맞게 분할하고 분할한 조각을 한 개씩 패킷에 넣어 송신한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56028408/164371676-1c0fa15f-f6bb-4a7d-8df4-77c61fdae138.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3️⃣-ack-번호를-사용하여-패킷이-도착했는지-확인한다&quot;&gt;3️⃣  ACK 번호를 사용하여 패킷이 도착했는지 확인한다.&lt;/h3&gt;

&lt;p&gt;데이터 송신동작은 앞서 설명한 것 만으로는 끝나지 않는다. TCP는 송신한 패킷이 상대에게 도착했는지 확인하고 도착하지 않았으면 다시 송신하는 기능이 있으므로 패킷을 송신한 후에는 확인 동작으로 넘어간다.&lt;/p&gt;

&lt;p&gt;먼저 TCP 담당 소프트웨어는 데이터를 조각으로 분할할 때 조각이 통신 개시부터 따져서 몇 번째 바이트에 해당 하는지 세어둔다. 이 값을 시퀀스 번호라고 하며 TCP 헤더에 기록한다. 이렇게 시퀀스 번호를 기록할 경우 수신측에서 패킷의 누락여부를 확인할 수 있다. 수신측은 전달 받은 데이터의 바이트 크기를 확인하고 이를 ACK 번호에 기록하고 이 값에 1을 더하여 송신측에 전달한다.&lt;/p&gt;

&lt;p&gt;✔️ &lt;strong&gt;예시&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;총 4381바이트의 데이터를 전송한다고 가정한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[누락되지 않은 경우]&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;시퀀스 번호 1 , 데이터 크기 : 1460바이트
    &lt;ol&gt;
      &lt;li&gt;ACK 번호 1461&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;시퀀스 번호 1461, 데이터 크기 : 1460바이트
    &lt;ol&gt;
      &lt;li&gt;ACK 번호 2921&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;시퀀스 번호 2921, 데이터 크기 : 1460바이트
    &lt;ol&gt;
      &lt;li&gt;ACK 번호 4381&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;[누락된 경우]&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;시퀀스 번호 1 , 데이터 크기 : 1460바이트
    &lt;ol&gt;
      &lt;li&gt;ACK 번호 1461&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;시퀀스 번호 1461, 데이터 크기 : 1460바이트
    &lt;ol&gt;
      &lt;li&gt;ACK 번호 전송하지 않음&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;시퀀스 번호 1461, 데이터 크기 : 1460바이트 (재전송)
    &lt;ol&gt;
      &lt;li&gt;ACK 번호 2921&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;🌟 &lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;시퀀스&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;번호와&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;ACK&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;번호로&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;패킷이&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;수신측에&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;도착한&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;것을&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;확인한다.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;🌟 ACK&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;번호를&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;통지할&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;때는&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;단순히&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;ACK&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;번호에&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;값을&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;설정할&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;뿐만&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;아니라&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;제어&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;비트의&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;ACK&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;비트도&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;로&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;설정한다.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;이렇게하면&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;ACK&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;번호&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;필드가&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;유효하다는&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;의미가&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;된다.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;4️⃣-패킷-평균-왕복-시간으로-ack-번호의-대기-시간을-조정한다&quot;&gt;&lt;strong&gt;4️⃣  패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다.&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;ACK 번호가 돌아오는 것을 기다리는 시간을 &lt;strong&gt;타임아웃 값&lt;/strong&gt; 이라고 한다.&lt;/p&gt;

&lt;p&gt;네트워크가 혼잡하면 ACK 번호가 돌아오는 시간이 지연될 수 있다. 이때 ACK 번호가 돌아오기전에 패킷을 재전송하면 혼잡한 네트워크를 악화시키는 사태가 발생한다.&lt;/p&gt;

&lt;p&gt;이러한 문제를 방지하기 위해 대기 시간을 적절하게 설정해야한다. 대기 시간이 너무 짧으면 패킷을 자주 보내게 되고 대기시간을 너무 길게 설정하면 패킷을 다시 보내는 동작이 지연되어 속도 저하의 원인이 되기 때문이다.&lt;/p&gt;

&lt;p&gt;보통 TCP는 ACK 번호가 돌아오는 시간을 기준으로 대기 시간을 판단하여 동적으로 변경하는 방법을 취한다.&lt;/p&gt;

&lt;h3 id=&quot;5️⃣-윈도우-제어-방식으로-효율적으로-ack-번호를-관리한다&quot;&gt;&lt;strong&gt;5️⃣  윈도우 제어 방식으로 효율적으로 ACK 번호를 관리한다.&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;ACK 번호가 돌아올 때까지의 시간동안 아무 일도 하지 않고 기다리는 것은 자원과 시간 낭비이다.&lt;/p&gt;

&lt;p&gt;낭비를 줄이기 위해 TCP는 윈도우 제어 방식에 따라 송신과 ACK 번호 통지의 동작을 실행한다.&lt;/p&gt;

&lt;p&gt;윈도우 제어 방식이란 한 개의 패킷을 보낸 후 ACK 번호를 기다리지 않고 차례대로 연속해서 복수의 패킷을 보내는 방법을 말한다. 이럴 경우 ACK 번호가 돌아올 때까지의 시간이 낭비되지 않는다.&lt;/p&gt;

&lt;p&gt;주의할 점은 ACK 번호를 기다리지 않고 차례로 패킷을 보내면 수신측의 능력을 초과하여 패킷을 보내는 사태가 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;수신측은 패킷을 수신하면 수신측 버퍼 메모리에 일시 보관한다. 수신측에서는 ACK 번호를 계산하는 작업이나 조각을 연결하여 원래 데이터를 복원하고 애플리케이션에 넘겨주어야 수신 버퍼에 저장된 데이터가 사용되어 사라진다. 하지만 송신측이 수신측의 처리속도보다 빠른 속도로 패킷을 송신하면 수신 버퍼에 데이터가 쌓이지 않고 사라질 수 있다.&lt;/p&gt;

&lt;p&gt;이러한 문제를 방지하기 위해 수신측은 송신측에 수신가능한 데이터의 양을 통지한다. 수신 가능한 양은 TCP 헤더의 윈도우 필드에 기록하여 송신측에 알린다.&lt;/p&gt;

&lt;h3 id=&quot;6️⃣ack-번호와-윈도우를-합승한다&quot;&gt;&lt;strong&gt;6️⃣ ACK 번호와 윈도우를 합승한다.&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;수신측은 네트워크 효율성 저하를 방지하기 위해 ACK 번호나 윈도우를 통지할 때 소켓을 바로 보내지 않고 잠시 기다린다. 기다리는 사이에 통지 동작이 발생하면 양쪽을 상승시켜서 한 개의 패킷으로 묶어서 전송한다.&lt;/p&gt;

&lt;p&gt;예를 들자면 ACK 번호의 송신을 대조할 때 윈도우 통지가 발생하면 ACK 번호와 윈도우를 한개의 패킷에 합승 시켜서 통지하여 패킷의 수를 줄이는 것이다.&lt;/p&gt;

&lt;p&gt;연속으로 ACK 번호 통지가 발생할 때도 마찬가지다. ACK 번호는 수신한 데이터의 끝이 어디인지를 송신측에 알리는 것이므로 ACK 번호가 통지가 연속적으로 발생하면 마지막 ACK 번호만 송신하고 나머지의 것은 생략해도 상관없다. 윈도우 통지도 마찬가지이다. 윈도우 통지가 연속적으로 발생하면 수신버퍼에 빈 공간이 늘어난다는 의미이므로 마지막 통지만 전달해도 문제가 발생하지 않는다.&lt;/p&gt;

&lt;h3 id=&quot;7️⃣http-응답-메세지를-수신한다&quot;&gt;&lt;strong&gt;7️⃣ HTTP 응답 메세지를 수신한다.&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;HTTP 리퀘스트 메세지를 보내면 웹 서버에서 응답 메세지가 돌아오기를 기다리고, 응답 메세지가 돌아오면 그것을 수신한다.&lt;/p&gt;

&lt;p&gt;데이터를 수신하면 수신한 데이터 조각과 TCP 헤더의 내용을 조사하여 누락된 데이터가 있는 지 검사하고 문제가 없으면 송신측에 ACK 번호를 반송한다. 그리고 데이터의 조각을 수신 버퍼에 일시 보관하고 데이터 조각을 연결하여 애플리케이션에게 건네준다. 이를 정확하게 설명하자면 수신 버퍼에 저장된 데이터를 애플리케이션 메모리 영역에 옮기고 제어권을 애플리케이션에게 되돌려준다.&lt;/p&gt;

&lt;h2 id=&quot;4-서버에서-연결을-끊어-소켓을-말소한다&quot;&gt;4. 서버에서 연결을 끊어 소켓을 말소한다.&lt;/h2&gt;

&lt;h3 id=&quot;1️⃣데이터-보내기를-완료했을-때-연결을-끊는다&quot;&gt;&lt;strong&gt;1️⃣ 데이터 보내기를 완료했을 때 연결을 끊는다.&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;데이터의 송 수신 동작이 완료되면 대상과의 연결을 끊는다. 이때 연결 끊기를 시도하는 대상은 서버나 클라이언트의 구분이 없다. 만약 서버에서 먼저 연결을 끊는다고 가정하면 서버측의 프로토콜 스택이 TCP 헤더를 생성하고 컨트롤비트인 FIN의 값을 1로 설정하여 클라이언트에게 전송한다. 이때 서버측은 소켓이 연결 끊기 동작에 들어갔다는 것을 기록한다. 서버에서 FIN을 설정한 TCP 헤더가 클라이언트에게 도착하면 클라이언트는 자신의 소켓에 서버가 연결끊기 작업에 들어갔다는 것을 기록하고 서버측에 FIN 값을 수신했다는 의미로 ACK 값을 전송한다.&lt;/p&gt;

&lt;p&gt;클라이언트측 소켓이 애플리케이션에 데이터를 전부 전달하면 클라이언트측의 애플리케이션도 close를 호출하여 데이터 송 수신 동작을 중지한다. 그러면 클라이언트의 프로토콜 스택도 서버와 마찬가지로 TCP 헤더에 FIN 값을 1로 설정하여 서버측에 전송한다. 서버측에서 ACK 값이 되돌아오면 서버와의 대화는 끝이난 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[연결 끊기 동작]&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;클라이언트가 FIN 송신&lt;/li&gt;
  &lt;li&gt;서버가 ACK 번호 송신&lt;/li&gt;
  &lt;li&gt;서버가 FIN 송신&lt;/li&gt;
  &lt;li&gt;클라이언트가 ACK 번호 송신&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;🌟  이때 연결 종료의 순서는 클라이언트와 서버가 서로 바뀔수도 있다.&lt;/strong&gt; &lt;/p&gt;

&lt;h3 id=&quot;2️⃣소켓을-말소한다&quot;&gt;2️⃣ 소켓을 말소한다.&lt;/h3&gt;

&lt;p&gt;서버와의 대화가 끝나면 더이상 소켓을 사용하여 서버와 대화할 수 없다. 하지만 이때 바로 소켓을 말소시키면 ACK 번호의 응답이 늦어 FIN을 재전송 할 때 기록 정보가 제거되어 어느 소켓이 수신 대상인지 알 수 없게 된다. 뿐만아니라 동일한 포트로 새롭게 생성된 소켓이 FIN을 수신하여 오동작이 발생할 수 있다. 이러한 문제 때문에 소켓을 바로 말소하지 않고 일정시간 기다린 후 말소한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;reference&quot;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://velog.io/@anhesu11/HTTP-%EA%B8%B0%EB%B3%B8-%EC%9D%B4%EB%A1%A0-%EC%A0%95%EB%A6%AC&quot;&gt;https://velog.io/@anhesu11/HTTP-기본-이론-정리&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;성공과 실패를 결정하는 1%의 네트워크&lt;/p&gt;</content><author><name></name></author><category term="3 way handshake" /><category term="4 way handshake" /><category term="Socket" /><category term="DNS" /><category term="TCP" /><category term="성공과 실패를 위한 네트워크 1%의 원리" /><summary type="html">📗 Chapter_02 TCP/IP의 데이터를 전기 신호로 만들어 보낸다 🌟 2장의 요점 짚고 넘어가기 🌟</summary></entry><entry><title type="html">[운영체제 스터디] 가상 메모리와 Page Fault</title><link href="http://localhost:4000/os/2022/04/16/os-study-11.html" rel="alternate" type="text/html" title="[운영체제 스터디] 가상 메모리와 Page Fault" /><published>2022-04-16T00:00:00+09:00</published><updated>2022-04-16T00:00:00+09:00</updated><id>http://localhost:4000/os/2022/04/16/os-study-11</id><content type="html" xml:base="http://localhost:4000/os/2022/04/16/os-study-11.html">&lt;p&gt;🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟&lt;/p&gt;

&lt;h1 id=&quot;️virtual-memory&quot;&gt;🗳️ Virtual Memory&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;물리적 메모리의 주소변환은 운영체제가 관여하지 않지만 Virtual Memory 기법은 운영체제가 관여한다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;1-demand-paging&quot;&gt;1. Demand Paging&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;실제로 사용자 프로그램에선 자주 사용되지 않는 코드가 대부분이다.&lt;/p&gt;

  &lt;p&gt;Demand Paging 기법은 실제로 사용될 경우 메모리에 올리기 때문에 많은 프로세스를 메모리에 동시에 올릴 수 있다.&lt;/p&gt;

  &lt;p&gt;Demand Paging 기법에선 무조건 한번은 page fault가 발생한다. (참조될 경우에 메모리에 올리기 때문)&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;실제로 필요할 때 page를 메모리에 올리는 것
      &lt;ul&gt;
        &lt;li&gt;I/O 양의 감소
          &lt;ul&gt;
            &lt;li&gt;한정된 메모리 공간을 조금 더 효율적으로 사용할 수 있기 때문에 Disk 에서 읽어오는 일이 적어짐&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;Memory 사용량 감소&lt;/li&gt;
        &lt;li&gt;빠른 응답 시간&lt;/li&gt;
        &lt;li&gt;더 많은 사용자 수용&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;Valid / Invalid bit의 사용
      &lt;ul&gt;
        &lt;li&gt;Invalid 의 의미
          &lt;ul&gt;
            &lt;li&gt;사용되지 않는 주소 영역인 경우&lt;/li&gt;
            &lt;li&gt;페이지가 물리적 메모리에 없는 경우&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;처음에는 모든 page entry가 invalid로 초기화&lt;/li&gt;
        &lt;li&gt;address translation 시에 Invalid bit이 set되어 있으면
          &lt;ul&gt;
            &lt;li&gt;“page fault”&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;2-page-fault&quot;&gt;2. Page Fault&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;invalid page를 접근하면 MMU가 trap을 발생시킴 (page fault trap)&lt;/li&gt;
  &lt;li&gt;Kernel mode로 들어가서 page fault handler가 invoke됨&lt;/li&gt;
  &lt;li&gt;다음과 같은 순서로 page fault를 처리한다.
    &lt;ul&gt;
      &lt;li&gt;invalid reference? (eg. bad address, protection violation) → abort process&lt;/li&gt;
      &lt;li&gt;Get an empty frame (없으면 뺏어온다: 다른 페이지가 할당된 frame에 replace)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;메모리를 획득하면 해당 페이지를 disk에서 momory로 읽어온다
    &lt;ul&gt;
      &lt;li&gt;disk I/O가 끝나기까지 이 프로세스는 CPU를 preempt 당함 (block)&lt;/li&gt;
      &lt;li&gt;Disk read가 끝나면 page tables entry 기록, valid/invalid bit = “vaild”&lt;/li&gt;
      &lt;li&gt;ready queue에 process를 insert → dispatch later&lt;/li&gt;
      &lt;li&gt;이 프로세스가 CPU를 잡고 다시 running&lt;/li&gt;
      &lt;li&gt;아까 중단되었던 instruction을 재개&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✔️ &lt;strong&gt;Steps in Handling a Page Fault&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;페이지 테이블 엔트리에 접근한다.&lt;/li&gt;
  &lt;li&gt;접근한 엔트리의 Invalid bit이 invalid이면 trap을 발생시킨다.&lt;/li&gt;
  &lt;li&gt;커널모드로 변경되어 page가 저장된 하드디스크에 접근한다.&lt;/li&gt;
  &lt;li&gt;page를 비어있는 page frame으로 이동시킨다. 이때 비어있는 page frame이 존재하지 않을경우 다른 페이지가 할당된 frame에 replace한다&lt;/li&gt;
  &lt;li&gt;새로 할당된 page frame number를 입력하고 invalid bit을 수정한다.&lt;/li&gt;
  &lt;li&gt;trap에 의해 중단되었던 명령어를 다시 수행한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56028408/162662911-5e53ed58-7416-496d-8f00-797fe1f456cc.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;✔️ Performace of Demand Paging&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Page Fault Rate  0≤ p ≤ 1.0
    &lt;ul&gt;
      &lt;li&gt;if p = 0 no page fault&lt;/li&gt;
      &lt;li&gt;if p = 1, every reference is a fault&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Effective Access Time
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;(1 - p) x memory access + P (OS &amp;amp; HW page fault overhead&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;[swap page out if needed]&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;swap page in&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;OS &amp;amp; HW restart overhead)&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;🌟   실제로 시스템에서  Page Fault Rate를 조사해본 결과 0.09 값이 측정된다. 즉 대부분의 경우는 메모리에서 직접 주소변환이 이뤄진다는 것이다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;22-empty-frame이-없는-경우&quot;&gt;2.2 Empty Frame이 없는 경우&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;✔️  Page replacement&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;어떤 frame을 빼앗아올지 결정해야 함&lt;/li&gt;
  &lt;li&gt;곧바로 사용되지 않을 page를 쫓아내는 것이 좋음&lt;/li&gt;
  &lt;li&gt;동일한 페이지가 여러번 메모리에서 쫓겨났다가 다시 들어올 수 있음&lt;/li&gt;
  &lt;li&gt;운영체제의 역할&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;✔️  Replacement Algorithm&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;page-fault rate을 최소화하는 것이 목표&lt;/li&gt;
  &lt;li&gt;알고리즘의 평가
    &lt;ul&gt;
      &lt;li&gt;주어진 page reference string에 대해 page fault를 얼마나 내는지 조사&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;reference string
    &lt;ul&gt;
      &lt;li&gt;시간순서에 따라 나열된 page frame (참조된 순서로 나열됨)&lt;/li&gt;
      &lt;li&gt;reference string의 예
        &lt;ul&gt;
          &lt;li&gt;1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;✔️ Page Replacement 흐름&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;swap out할 victim page를 선점하여 backing store에 swap out시킨다. 이때 변경사항이 있으면 변경된 내용을 저장하고 swap out한다.&lt;/li&gt;
  &lt;li&gt;victim page가 저장되어있던 page table 엔트리의 valid/invalid bit를 invalid 로 수정한다&lt;/li&gt;
  &lt;li&gt;swap out이 완료되면 victim page가 존재하던 frame에 trap을 발생시킨 page를 할당한다.&lt;/li&gt;
  &lt;li&gt;새롭게 할당된 page가 존재하는 page table 엔트리의 frame number를 수정한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;💡 victim page&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;page replacement에 의해 swap out 되는 페이지를 victim page 라고 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56028408/162663269-0ad00235-1654-44ad-aa55-bb1e862cd25e.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;23-optimal-algorithm&quot;&gt;2.3 Optimal Algorithm&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;MIN(OPT): 가장 먼 미래에 참조되는 page를 replace&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;✔️ Optimal Alogrithm?&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;미래의 참조를 어떻게 아는가?
    &lt;ul&gt;
      &lt;li&gt;미래를 모두 짐작해야하기 때문에 Offline algorithm 실제로 사용되진 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다른 알고리즘 성능에 대한 upper bound 제공
    &lt;ul&gt;
      &lt;li&gt;Belady’s optimal algorithm, MIN, OPT 등으로 불림&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;✔️ Optimal Alogrithm 예시&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56028408/162663068-66b5c86c-af59-4cf2-bd73-7451c519efa3.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[ 가정 ]&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;빨간색 숫자는 page fault가 발생한 page&lt;/li&gt;
  &lt;li&gt;연보라색 숫자는 메모리로 바로 참조되는 page&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;[ 예시 ]&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;1,2,3,4번 page의 참조가 발생하여 메모리에 할당한다.&lt;/li&gt;
  &lt;li&gt;1번과 2번 page가 메모리에서 바로 참조된다.&lt;/li&gt;
  &lt;li&gt;다음 순서로 5번 page가 참조되어 page fault가 발생한다.&lt;/li&gt;
  &lt;li&gt;이때 page frame은 모두 꽉 차있는 상태이므로 swap out할 page를 선점한다.&lt;/li&gt;
  &lt;li&gt;가장 먼 미래에 참조되는 4번 page를 swap out한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;24-fifo-first-in-first-out-algorithm&quot;&gt;2.4 FIFO (First In First Out) Algorithm&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;가장 먼저들어온 page를 내쫓는 알고리즘&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;✔️ &lt;strong&gt;FIFO Anomaly (Belady’s Anomaly)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;more frames ≠ less page fault&lt;/li&gt;
  &lt;li&gt;frame이 많을수록 page fault가 더 자주 일어난다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;✔️ FIFO (First In First Out) Algorithm 예시&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56028408/162662867-f815886e-bb6b-4e4f-847a-5db4b5d26653.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[가정]&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;빨간색 숫자는 page fault가 발생한 page&lt;/li&gt;
  &lt;li&gt;연보라색 숫자는 메모리로 바로 참조되는 page&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;[예시]&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;1,2,3 번 page가 참조되어 page fault가 발생한다.&lt;/li&gt;
  &lt;li&gt;그 이후 4번 page가 참조되어 가장 먼저 들어온 1번 page가 swap out되고 4번 page가 할당된다.&lt;/li&gt;
  &lt;li&gt;1번 page가 재참조되어 1번 다음으로 빨리 들어왔던 2번 page를 swap out하고 1번 page를 할당한다.&lt;/li&gt;
  &lt;li&gt;가장 먼저 할당되었던 page를 swap out하면서 반복&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;25-lru-least-recently-used-algorithm&quot;&gt;2.5 LRU (Least Recently Used) Algorithm&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;LRU : 가장 오래 전에 참조된 것을 swap out 시키는 알고리즘&lt;/p&gt;

  &lt;p&gt;가장 오래전에 참조된 알고리즘을 swap out하기 때문에 swap out 되는 page의 인지도는 체크하지 않는다. (여러번 참조되었냐의 여부 확인 안함)&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;✔️  LRU (Least Recently Used) Algorithm 예시&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56028408/162662841-9832b9ff-10e3-4dd8-a32e-8c837bc550d2.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[가정]&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;빨간색 숫자는 page fault가 발생한 page&lt;/li&gt;
  &lt;li&gt;연보라색 숫자는 메모리로 바로 참조되는 page&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;[예시]&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;1,2,3,4 번 page가 참조되어 page fault가 발생한다.&lt;/li&gt;
  &lt;li&gt;1번과 2번 page를 직접 메모리에서 참조한다.&lt;/li&gt;
  &lt;li&gt;5번 page가 page fault가 발생하여 오래전에 참조되었던 3번 page가 swap out 된다.&lt;/li&gt;
  &lt;li&gt;가장 오래전에 참조되었던 page를 swap out하면서 반복&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;26-lfu-least-frequently-used-algorithm&quot;&gt;2.6 LFU (Least Frequently Used) Algorithm&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;LFU: 참조 횟수(reference count)가 가장 적은 페이지를 지움&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;✔️  최저 참조 횟수인 page가 여럿 있는 경우&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;LFU 알고리즘 자체에서는 여러 page 중 임의로 선정한다&lt;/li&gt;
  &lt;li&gt;성능 향상을 위해 가장 오래 전에 참조된 page를 지우게 구현할 수도 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✔️  장단점&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;LRU처럼 직전 참조 시점만 보는 것이 아니라 장기적인 시간 규모를 보기 때문에 page의 인기도를 좀 더 정확히 반영할 수 있음&lt;/li&gt;
  &lt;li&gt;참조 시점의 최근성을 반영하지 못함&lt;/li&gt;
  &lt;li&gt;LRU보다 구현이 복잡함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;✔️ LRU와 LFU 알고리즘 예제&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; 
&lt;img src=&quot;https://user-images.githubusercontent.com/56028408/162662834-97cd9c40-0a3b-443e-8a78-c37091d0fc31.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[가정]&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;page frame은 4칸이 존재함&lt;/li&gt;
  &lt;li&gt;5번 page를 page fault 발생시켜야 하는 상황&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;[예시]&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;1번 페이지가 가장 먼저 할당되었고 1번 페이지는 총 4번 참조되었다.&lt;/li&gt;
  &lt;li&gt;1번 페이지 이후 2번 페이지가 할당되었고 2번 페이지는 총 3번 참조되었다.&lt;/li&gt;
  &lt;li&gt;2번 페이지 이후 3번 페이지가 할당되었고 3번 페이지는 총 2번 참조되었다.&lt;/li&gt;
  &lt;li&gt;마지막으로 4번 페이지가 할당되고 4번 페이지는 총 1번 참조되었다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;[결과]&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;LRU : 가장 오래전에 참조된 1번 page를 삭제함&lt;/li&gt;
  &lt;li&gt;LFU : 가장 최근에 할당되었음에도 적게 참조된 4번 page를 삭제함&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;28-paging-system에서-lru-lfu-가능한가&quot;&gt;2.8 Paging System에서 LRU, LFU 가능한가?&lt;/h3&gt;

&lt;p&gt;운영체제가 Page fault가 발생한 page를 물리적 메모리에 replace 한다. 그런데 비어있는 frame이 없을 경우 해당하는 알고리즘에 맞게  frame을 쫓아내야 하는데 이미 메모리에 해당 page가 존재할 경우 OS의 지원이 아닌 하드웨어 지원으로 주소변환이 일어나기 때문에 page의 참조 시간이나 page의 참조 횟수를 알 수 있는 방법이 없다. 즉 가상메모리 환경의 Page Fault 기법에서는 LRU, LFU 알고리즘을 사용할 수가 없다.&lt;/p&gt;

&lt;h3 id=&quot;29-clock-algorithm&quot;&gt;2.9 Clock Algorithm&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;LRU의 근사(approximation) 알고리즘&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56028408/163078507-2723e003-3bbf-419c-b93a-9414b7b08f0f.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;✔️ Clock Algorithm&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;여러 명칭으로 불림
    &lt;ul&gt;
      &lt;li&gt;Second cahnge alogorithm&lt;/li&gt;
      &lt;li&gt;NUR (Not Used Recently) 또는 NRU ( Not Recently Used)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Reference bit을 사용해서 교체 대상 페이지 선정 (circular list)&lt;/li&gt;
  &lt;li&gt;reference bit가 0인 것을 찾을 때까지 포인터를 하나씩 앞으로 이동&lt;/li&gt;
  &lt;li&gt;포인터 이동하는 중에 참조되지 않은 reference bit 1은 모두 0으로 바꿈&lt;/li&gt;
  &lt;li&gt;Reference bit이 0인 것을 찾으면 그 페이지를 교체&lt;/li&gt;
  &lt;li&gt;한 바퀴 되돌아와서도(=second chance) 0이면 그때에는 replace 당함&lt;/li&gt;
  &lt;li&gt;자주 사용되는 페이지라면 second change가 올 때 1&lt;/li&gt;
  &lt;li&gt;Clock algorithm의 개선
    &lt;ul&gt;
      &lt;li&gt;reference bit과 modified bit (dirty bit)을 함께 사용&lt;/li&gt;
      &lt;li&gt;reference bit → 1 최근에 참조된 페이지&lt;/li&gt;
      &lt;li&gt;modified bit(=dirty bit) → 1 최근에 변경된 페이지 (I/O를 동반하는 페이지)
        &lt;ul&gt;
          &lt;li&gt;메모리에서 write가 발생할 때 1로 세팅&lt;/li&gt;
          &lt;li&gt;page fault를 발생시킬 때 modified bit가 0인 page들을 먼저 쫓아내면 disk I/O 수행시간이 적어지는 장점이 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;🌟  &lt;strong&gt;이미 메모리에 할당된 페이지를 참조할 때  reference bit을 변경하는 것은 OS가 아니라 하드웨어의 역할이다. 운영체제는 비트를 주기적으로 검사하여 reference bit이 0인 page를 replace 하는 역할을 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-page-frame의-allocation&quot;&gt;3. Page Frame의 Allocation&lt;/h2&gt;

&lt;p&gt;💡  Allocation problem: 각 process에 얼마만큼의 page frame을 할당할 것인가?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;✔️ Allocation의 필요성&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;메모리 참조 명령어 수행시 명령어, 데이터 등 여러 페이지 동시 참조
    &lt;ul&gt;
      &lt;li&gt;명령어 수행을 위해 최소한 할당되어야 하는 frame의 수가 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Loop를 구성하는 page들은 한꺼번에 allocate 되는 것이 유리함
    &lt;ul&gt;
      &lt;li&gt;최소한의 allcation이 없으면 매 loop 마다 page fault&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;✔️ Allocation Scheme&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Equal allocation: 모든 프로세스에 똑같은 갯수 할당&lt;/li&gt;
  &lt;li&gt;Proportional allocation: 프로세스 크기에 비례하여 할당&lt;/li&gt;
  &lt;li&gt;Priority allocation: 프로세스의 priority에 따라서 다르게 할당&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-global-vs-local-replacement&quot;&gt;4. Global vs Local Replacement&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;✔️ Global replacement&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Replace 시 다른 process에 할당된 frame을 빼앗아 올 수 있다&lt;/li&gt;
  &lt;li&gt;Process별 할당량을 조절하는 또 다른 방법&lt;/li&gt;
  &lt;li&gt;FIFO, LRU, LFU 등의 알고리즘을 global repacement로 사용시에 해당한다&lt;/li&gt;
  &lt;li&gt;Working set, PFF 알고리즘 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;✔️  Local Replacement&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;자신에게 할당된 frame 내에서만 replacement&lt;/li&gt;
  &lt;li&gt;FIFO, LRU, LFU 등의 알고리즘을 process 별로 운영시&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;5-다양한-캐싱-환경&quot;&gt;5. 다양한 캐싱 환경&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;✔️ 캐싱 기법&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;한정된 빠른 공간(=캐쉬)에 요청된 데이터를 저장해 두었다가 후속 요청시 캐쉬로부터 직접 서비스하는 방식&lt;/li&gt;
  &lt;li&gt;paging system 외에도 cache memory, buffer caching, Web caching 등 다양한 분야에서 사용됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;✔️ 캐쉬 운영의 시간 제약&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;교체 알고리즘에서 삭제할 항목을 결정하는 일에 지나치게 많은 시간이 걸리는 경우 실제 시스템에서 사용할 수 없음&lt;/li&gt;
  &lt;li&gt;Buffer caching이나 Web caching의 경우
    &lt;ul&gt;
      &lt;li&gt;O(1)에서 O(log n) 정도까지 허용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Paging system인 경우
    &lt;ul&gt;
      &lt;li&gt;page fault인 경우에만 OS가 관여함&lt;/li&gt;
      &lt;li&gt;페이지가 이미 메모리에 존재하는 경우 참조시각 등의 정보를 OS가 알 수 없음&lt;/li&gt;
      &lt;li&gt;O(1)인 LRU의 list 조작조차 불가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;6-thrashing&quot;&gt;6. Thrashing&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;프로세스의 원활한 수행에 필요한 최소한의 page frame 수를 할당 받지 못한 경우 발생하는 현상&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56028408/163078491-4d5715f3-ec1f-47a4-839d-f4f94ac0764a.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Page fault rate이 매우 높아짐&lt;/li&gt;
  &lt;li&gt;CPU utillization이 매우 낮아짐&lt;/li&gt;
  &lt;li&gt;OS는 MPD(Multiprogramming degree)를 높여아 한다고 판단&lt;/li&gt;
  &lt;li&gt;또 다른 프로세스가 시스템에 추가됨 (higher MPD)&lt;/li&gt;
  &lt;li&gt;프로세스당 할당된 frame의 수가 더욱 감소&lt;/li&gt;
  &lt;li&gt;프로세스는 page의 swap in / swap out으로 매우 바쁨&lt;/li&gt;
  &lt;li&gt;대부분의 시간에는 CPU가 한가함&lt;/li&gt;
  &lt;li&gt;low throughput&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;✔️  대충 살펴봐도 프로세스 성능이 상당히 저하될 수 있는 현상이다. 이를 예방하기 위한 방법이 없을까?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; 있다 ! 앞서 설명한 Working set, PFF(Page-Fault Frequency) Scheme가 Thrashing 문제를 해결하기 위한 알고리즘이다.&lt;/p&gt;

&lt;h3 id=&quot;61-working-set-model&quot;&gt;6.1 Working-Set Model&lt;/h3&gt;

&lt;p&gt;✔️ Locality of reference&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스는 특정 시간 동안 일정 장소만을 집중적으로 참조한다.&lt;/li&gt;
  &lt;li&gt;집중적으로 참조되는 해당 page들의 집합을 locality set이라 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✔️ Working-set Model&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Locality에 기반하여 프로세스가 일정 시간 동안 원활하게 수행되기 위해 한꺼번에 메모리에 올라와 있어야하는 page들의 집합을 Working Set 이라고 정의한다.&lt;/li&gt;
  &lt;li&gt;Working Set 모델에서는 process의 working set 전체가 메모리에 올라와 있어야 수행되고 그렇지 않을 경우 모든 frame을 반납한 후 swap out (suspend)&lt;/li&gt;
  &lt;li&gt;Thrashing을 방지함&lt;/li&gt;
  &lt;li&gt;Multiprogramming degree를 결정함&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;62-working-set-alogorithm&quot;&gt;6.2 Working-Set Alogorithm&lt;/h3&gt;

&lt;p&gt;✔️ &lt;strong&gt;Working set 결정 방법&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Working set window를 통해 알아낸다&lt;/li&gt;
  &lt;li&gt;window size가 델타 인 경우
    &lt;ul&gt;
      &lt;li&gt;시각 t 에서의 working set WS (t)
        &lt;ul&gt;
          &lt;li&gt;Time interval [델타] 사이에 참조된 서로 다른 페이지들의 집합&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Working set에 속한 page는 메모리에 유지, 속하지 않은 것은 버림 (즉, 참조된 후 델타 시간 동안 해당 page를 메모리에 유지한 후 버림)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56028408/163078480-dbd22313-a45b-41cb-a30d-32a63203984e.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;63-pff-page-fault-frequency-scheme&quot;&gt;6.3 PFF (Page-Fault Frequency) Scheme&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Page-fault rate의 상한값과 하한값을 둔다
    &lt;ul&gt;
      &lt;li&gt;Page fault rate이 상한값을 넘으면 frame을 더 할당한다&lt;/li&gt;
      &lt;li&gt;Page fault rate이 하한값 이하이면 할당 frame 수를 줄인다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;빈 frame이 없으면 일부 프로세스를 swap out 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;7-page-size의-결정&quot;&gt;7. Page Size의 결정&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Page size를 감소시키면
    &lt;ul&gt;
      &lt;li&gt;페이지 수 증가&lt;/li&gt;
      &lt;li&gt;페이지 테이블 크기 증가&lt;/li&gt;
      &lt;li&gt;Internal fregmentation 감소&lt;/li&gt;
      &lt;li&gt;Disk transfer의 효율성 감소
        &lt;ul&gt;
          &lt;li&gt;Seek/rotation vs transfer&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;필요한 정보만 메모리에 올라와 메모리 이용이 효율적
        &lt;ul&gt;
          &lt;li&gt;Locality의 활용 측면에서는 좋지 않음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✔️  현재 Trend&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Larger page size&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;reference&quot;&gt;&lt;strong&gt;Reference&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;이화여자대학교 반효경 교수님 운영체제 강의&lt;/p&gt;</content><author><name></name></author><category term="반효경" /><category term="가상 메모리" /><category term="요구 페이징" /><category term="page fault" /><summary type="html">🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟</summary></entry><entry><title type="html">[운영체제 스터디] 불연속할당</title><link href="http://localhost:4000/os/2022/04/15/os-study-10.html" rel="alternate" type="text/html" title="[운영체제 스터디] 불연속할당" /><published>2022-04-15T00:00:00+09:00</published><updated>2022-04-15T00:00:00+09:00</updated><id>http://localhost:4000/os/2022/04/15/os-study-10</id><content type="html" xml:base="http://localhost:4000/os/2022/04/15/os-study-10.html">&lt;p&gt;🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟&lt;/p&gt;

&lt;h1 id=&quot;️memory-management-2&quot;&gt;🗳️ Memory Management 2&lt;/h1&gt;

&lt;h2 id=&quot;1-noncontiguous-allocation불연속할당&quot;&gt;1. Noncontiguous allocation(불연속할당)&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;불연속할당(noncontiguous allocation) 기법이란 하나의 프로세스가 물리적 메모리의 여러 위치에 분산되어 올라갈 수 있는 메모리 할당 기법을 말한다. 불연속할당 방식에는 하나의 프로그램을 분할하는 기준에 따라 동일한 크기로 나누어 메모리에 올리는 페이징 기법과, 크기는 일정하지 않지만 의미 단위(코드, 데이터, 스택 영역)로 나누어 메모리에 올리는 세그멘테이션 기법, 그리고 세그먼테이션을 기본으로 하되 이를 다시 동일 크기의 페이지로 나누어 메모리에 올리는 페이지드 세그먼테이션 기법 등이 있다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;11-paging&quot;&gt;1.1 Paging&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;페이징 기법은 프로세스의 가상 메모리를 동일한 크기의 Page로 잘라서 각 Page 별로 비어있는 물리적 메모리에 저장하는 방식을 말한다. 페이징 기법에서는 각 프로세스의 주소 공간 전체를 물리적 메모리에 한번에 올릴 필요없이 일부는 백킹스토어, 일부는 물리적 메모리에 혼재 시키는 것이 가능하다.&lt;/p&gt;

  &lt;p&gt;페이징 기법에서는 물리적 메모리를 페이지 크기와 동일한 프레임으로 나누어두기 때문에 앞서 설명한 동적 메모리 할당 문제가 발생하지 않는다. 비어있는 공간이 모두 동일한 크기여서 어떠한 위치에도 저장할 수 있기 때문이다. 하지만 이러한 특징은 복잡한 주소변환 절차를 필요로 한다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;✔️ &lt;strong&gt;하나의 Page의 크기는 4KB&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;✔️  &lt;strong&gt;Paging 기법을 사용할 경우 해당 page의 **page table 주소와 논리적 주소를 물리적 메모리의 주소로 변환한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1️⃣  &lt;strong&gt;Paging 기법의 주소변환 절차는 어떻게 이뤄지나?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;페이징 기법은 주소 변환이 페이지 단위로 이뤄져야 하기 때문에 조금 더 복잡한 주소변환 절차가 필요하다. 따라서 페이징 기법에서는 각각의 주소 변환을 위한 페이지 테이블을 가진다. 페이지 테이블은 프로세스가 가질 수 있는 페이지의 개수만큼 주소 변환 엔트리를 가지고 있으며, 엔트리는 페이지 번호와 페이지 오프셋으로 이루어져 있다. 추가로 페이지 테이블은 프로세스의 페이지 수 만큼 엔트리가 생성되기 때문에 큰 용량이 필요하여 메인 메모리에 저장된다.&lt;/p&gt;

&lt;h3 id=&quot;12-page-table&quot;&gt;1.2 &lt;strong&gt;Page Table&lt;/strong&gt;&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;페이지 테이블이란 Page의 물리적 메모리 주소 변환을 하기 위한 자료구조이다. 페이지 갯수만큼 엔트리가 생성되기 때문에 많은 용량을 필요로 하여 메인 메모리에 저장된다. CPU가 물리적 주소에 접근하려면 Page table을 거쳐서 Page Frame 까지 도달해야 하는데, 둘 다 메인 메모리에 저장되어 있기 때문에 메모리에 두 번 접근하게 되는 오버헤드가 발생한다. Page table의 문제점을 해결하기 위한 방법을 알아보자&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;✔️ &lt;strong&gt;Page Table의 구성&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Page-table base register (PTBR)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✔️  &lt;strong&gt;페이지 테이블만 있었을 때, 물리적 메모리 주소에 닿기까지 2번의 메모리 접근이 필요하다. 첫번째 접근은 CPU → Page Table 접근 두번째 접근은 Page Table → Page frame 접근이다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Page-table base register (PTBR)가 page table을 가리킴
    &lt;ul&gt;
      &lt;li&gt;메모리에 상주하고있는 page table의 시작위치&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Page-table length register (PTLR)가 테이블 크기를 보관&lt;/li&gt;
  &lt;li&gt;모든 메모리 접근 연산에는 2번의 memory acess 필요
    &lt;ul&gt;
      &lt;li&gt;page table 접근 1번, 실제 data/instruction 접근 1번&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;translation look-aside buffer (associative register or TLB)
    &lt;ul&gt;
      &lt;li&gt;속도 향상을 위해 사용되는 고속 lookup hardwore cache&lt;/li&gt;
      &lt;li&gt;메모리 접근 연산이 2번 이뤄지는 비효율적인 접근방식을 보완함&lt;/li&gt;
      &lt;li&gt;page table에서 접근이 자주 이뤄지는 엔트리를 캐싱하고 있음&lt;/li&gt;
      &lt;li&gt;CPU가 캐싱되어있는 페이지 주소를 찾을 경우 CPU → TLB → Physical Memory&lt;/li&gt;
      &lt;li&gt;TLB에 존재하지 않을 경우 CPU →  Page table(Physical Memory) → Physical Memory&lt;/li&gt;
      &lt;li&gt;물리적 페이지와 논리적 페이지 주소의 쌍으로 이뤄져있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Associative registers(TLB) : 병렬 검색이 가능&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;TLB에는 page table 중 일부만 존재&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Address translaction&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;page table 중 일부가 associative register에 보관되어 있음&lt;/li&gt;
  &lt;li&gt;만약 해당 page가 associative register에 있는 경우 곧바로 frame #을 얻음&lt;/li&gt;
  &lt;li&gt;그렇지 않은 경우 main memory에 있는 page table로 부터 frame #을 얻음&lt;/li&gt;
  &lt;li&gt;TLB는 context switch 때 flush (remove old entries)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;13-two-level-page-table&quot;&gt;1.3 Two-Level Page Table&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;속도는 느려지더라도 페이지 테이블의 크기를 줄이기 위한 방법이다.&lt;/li&gt;
  &lt;li&gt;이단계 테이블에서는 page table 자체를 page로 구성한다.&lt;/li&gt;
  &lt;li&gt;page table 자체를 page로 구성&lt;/li&gt;
  &lt;li&gt;사용되지 않는 주소 공간에 대한 outer page table의 엔트리 값은 null (대응하는 inner page table이 없음)
    &lt;ul&gt;
      &lt;li&gt;현대의 컴퓨터는 address space가 매우 큰 프로그램 지원 (최근에는 64bit 구성도 많음)
        &lt;ul&gt;
          &lt;li&gt;32 bit address 사용 시: 2의 32승의 주소 공간이 필요하다 (4GB)
            &lt;ul&gt;
              &lt;li&gt;page size가 4K 시 1M개의 page table entry 필요&lt;/li&gt;
              &lt;li&gt;각 page entry가 4B시 프로세스당 4M의 page table 필요&lt;/li&gt;
              &lt;li&gt;그러나, 대부분의 프로그램은 4G의 주소 공간 중 지극히 일부분만 사용하므로 page table 공간이 심하게 낭비된다&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;🌟  이단계 페이지 테이블 예시 &lt;/p&gt;

&lt;p&gt;✔️ Logical Address (on 32-bit machine with $K page size)의 구성&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;20 bit의 page number&lt;/li&gt;
  &lt;li&gt;12 bit의 page offset&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✔️ Page table 자체가 page로 구성되기 때문에 page Number는 다음과 같이 나뉜다&lt;/p&gt;

&lt;p&gt;(각 page table entry가 4B)&lt;/p&gt;

&lt;p&gt;10 - bit의 page number&lt;/p&gt;

&lt;p&gt;10 - bit의 page offset&lt;/p&gt;

&lt;p&gt;따라서, logical address는 다음과 같다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56028408/162226691-ddf3845a-3807-44b6-bc68-92f05e7efb7b.png&quot; alt=&quot;스크린샷 2022-04-07 오후 9 55 33&quot; /&gt;&lt;/p&gt;

&lt;p&gt;P1은 outer page table의 index이고&lt;/p&gt;

&lt;p&gt;P2는 outer page table의 page에서의 변의(displacement)&lt;/p&gt;

&lt;p&gt;✔️ 2단계 페이징에서의 Address-translation scheme&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56028408/162226209-7f026927-267b-4194-8b4e-cb4721f16f8a.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;논리적 주소에서 outer table 의 index 번호를 찾는다.&lt;/li&gt;
  &lt;li&gt;outer table에서 P1값에 위치로 이동한 후 inner page table 엔트리의 위치 값을 가져온다.&lt;/li&gt;
  &lt;li&gt;outertable에서 inner page table로 이동한다.&lt;/li&gt;
  &lt;li&gt;inner table에서 P2값에 해당하는 엔트리로 이동한 후 저장된 물리적 페이지 프레임 주소를 얻게된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;inner table의 크기는 4KB로 페이지의 크기와 동일하다.&lt;/p&gt;

&lt;p&gt;이단계 테이블은 속도는 느리더라도 페이지 테이블의 공간을 줄이는 것이 목적인 반면에&lt;/p&gt;

&lt;p&gt;여전히 inner table의 엔트리는 100만개 이상이 필요하다. 추가적으로 outer table 과 inner table로 구성되어 있어서 공간과 시간이 기존 page table에 비해서 더 손해이다.&lt;/p&gt;

&lt;p&gt;하지만 그럼에도 이단계 테이블을 사용하는 이유는 ?!&lt;/p&gt;

&lt;p&gt;프로그램을 구성하는 공간에서 사용되는 페이지의 수는 얼마 안되지만 페이지 테이블은 실제 사용하는 페이지의 수가 적더라도 논리적 메모리의 최대 크기만큼 엔트리를 생성한다. 그런데 이단계 페이지 테이블은 outer page table은 논리적 메모리 크기만큼 생성하지만 실제 사용이 되지않는 엔트리는 Null로 할당하고 inner table의 엔트리를 생성하지 않는다.&lt;/p&gt;

&lt;p&gt;실제 프로그램은 프로그램이 사용되지 않더라도 4KB의 메모리 공간을 전부 채운다.&lt;/p&gt;

&lt;h3 id=&quot;14-multilevel-paging-and-performance&quot;&gt;1.4 Multilevel Paging and Performance&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;주소공간이 더 커지면 다단계 페이지 테이블이 필요하다 다단계 테이블은 단계별로 페이지 테이블이 메모리에 존재하므로 logical address의 physical address 변환에 더 많은 메모리 접근이 필요하다 하지만 이러한 문제점은 TLB를 통하여 접근시간을 줄일 수 있다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;✔️ 4단계 페이지 테이블을 사용하는 경우&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;메모리 접근 시간이 100ns, TLB 접근 시간이 20ns이고&lt;/li&gt;
  &lt;li&gt;TLB hit ratio가 98%인 경우
    &lt;ul&gt;
      &lt;li&gt;effective memory access time = 0.98 x 120 + 0.02 x 520 = 128 nanoseconds
        &lt;ul&gt;
          &lt;li&gt;결과적으로 주소변환을 위해 28ns만 소요한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1️⃣-memory-protection&quot;&gt;1️⃣  Memory Protection&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Page table의 각 entry 마다 아래의 bit를 둔다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;✔️ Protection bit&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Page에 대한 접근 권한 (read/write/read-only)
    &lt;ol&gt;
      &lt;li&gt;페이지 테이블은 프로세스 마다 각각 생성되므로 다른 프로세스가 Page에 접근하는 것을 막기위한 것이 아니라 연산에 대한 접근 권한을 의미한다&lt;/li&gt;
      &lt;li&gt;예를 들면 코드영역은 실행도중 변경되면 안되므로  read-only 권한을 부여하고 데이터나 스택영역에는 read, write 권한을 부여한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;✔️ &lt;strong&gt;Valid (v) / Invalid (i) Bit in a Page Table&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;valid-invalid bit
    &lt;ul&gt;
      &lt;li&gt;Valid (v)
        &lt;ul&gt;
          &lt;li&gt;Page 0을 예로 들면 Page 0이 실제로 2의 주소를 가진 Page frame에 할당된 것을 의미함 (실제로 페이지가 물리적 메모리에 존재한다)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Invalid (i)
        &lt;ul&gt;
          &lt;li&gt;해당 주소의 frame에 유효한 내용이 없을을 의미한다 (접근 불허)
            &lt;ol&gt;
              &lt;li&gt;프로세스가 그 주소 부분을 사용하지 않는 경우&lt;/li&gt;
              &lt;li&gt;해당 페이지가 메모리에 올라와 있지 않고 swap area에 있는 경우&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56028408/162225826-33165124-98fc-409b-8174-0d0c05b8b653.jpeg&quot; alt=&quot;257F2E3C5757C75D31 (1)&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;14-inverted-page-table-역방향-페이지-테이블&quot;&gt;1.4 Inverted Page Table (역방향 페이지 테이블)&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Page table은 실행되는 프로세스마다 독립적으로 생성되기 때문에 메모리를 많이 차지한다. 하지만 &lt;strong&gt;Inverted Page Table&lt;/strong&gt;은 기존 Page table과 다르게 모든 프로세스가 &lt;strong&gt;Inverted Page Table&lt;/strong&gt;을 참조하게 하는 방식이다. &lt;strong&gt;Inverted Page Table은&lt;/strong&gt; Page Frame 기준으로 엔트리를 생성한다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;💡 Page table이 매우 큰 이유&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;모든 process 별로 그 logical address에 대응하는 모든 page에 대해 page table entry가 존재&lt;/li&gt;
  &lt;li&gt;대응하는 page가 메모리에 있든 아니든 간에 page table에는 entry로 존재&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✔️ &lt;strong&gt;Inverted page table (역방향 페이지 테이블)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Page frame 하나당 page table에 하나의 entry를 둔 것 (system-wide)&lt;/li&gt;
  &lt;li&gt;메모리 공간을 확보하기 위해 사용 됨&lt;/li&gt;
  &lt;li&gt;역방향 페이지 테이블의 엔트리는 논리적인 페이지 번호와 Pid를 저장하고 있음&lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;테이블 전체를 탐색해야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;조치
    &lt;ul&gt;
      &lt;li&gt;associative register 사용 (expensive)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56028408/162448838-96f5d704-d018-488d-922f-d1fc7a285b12.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;✔️  &lt;strong&gt;주소변환과정&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Page Table에서 pid와 page number로 해당 정보가 저장된 엔트리의 위치를 찾는다&lt;/li&gt;
  &lt;li&gt;찾아진 엔트리가 몇번째 위치에 존재하는지 확인하고 해당 주소의 페이지 프레임을 찾는다.&lt;/li&gt;
  &lt;li&gt;각 page tavle entry는 각각의 물리적 메모리의 page frame이 담고 있는 내용 표시 (process-id, process의 logical address)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;15-shard-page&quot;&gt;1.5 Shard Page&lt;/h3&gt;

&lt;p&gt;✔️ &lt;strong&gt;Shared code&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Re-entrant Code (=Pure code)
    &lt;ul&gt;
      &lt;li&gt;read-only로 하여 프로세스 간에 하나의 code만 메모리에 올림 (eg, text, editors, compliers, winodw, systems)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Shared code는 모든 프로세스의 logical address space에서 동일한 위치에 있어야 함 (동일한 page number를 가져야함)&lt;/li&gt;
  &lt;li&gt;Private code and data
    &lt;ul&gt;
      &lt;li&gt;각 프로세스들은 독자적으로 메모리에 올림&lt;/li&gt;
      &lt;li&gt;Private data는 logical address space의 아무 위치에 할당되어도 무방&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56028408/162453156-7a30193b-5690-4a92-a534-37d952e26fd0.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;✔️ 예를 들면?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;서로 다른 프로세스 P1, P2, P3가 동일한 코드를 사용하다면 코드를 프로세스마다 각각 올리는 것은 비효율 적이다.  즉 공유할 수 있는 코드는 별도로 올리는 것이 아니라 같은 Frame으로 매핑하여 한칸의 Page Frame 만을 할당하는 것이 효율적이라고 할 수 있다. 하지만 모든 프로세스가 같은 코드영역을 참조하고 있기 때문에 공유하는 코드영역은 read-only로 설정해야한다. 그리고 공유코드는 프로세스가 다르더라도 동일한 logical address를 가져야한다.&lt;/p&gt;

&lt;h2 id=&quot;2-segmentation&quot;&gt;2. Segmentation&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;프로그램은 의미 단위인 여러 개의 segment로 구성&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;작게는 프로그램을 구성하는 함수 하나하나를 세그먼트로 정의&lt;/li&gt;
    &lt;li&gt;크게는 프로그램 전체를 하나의 세그먼트로 정의 가능&lt;/li&gt;
    &lt;li&gt;일반적으로는 code,data,stack 부분이 하나씩의 세그먼트로 정의됨&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;Paging 방식처럼 동일한 크기로 분할하는 것이 아니라 동적 메모리 할당 문제가 발생할 수 있다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;✔️ &lt;strong&gt;Segment는 다음과 같은 logical unit 들&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;main()&lt;/li&gt;
  &lt;li&gt;function&lt;/li&gt;
  &lt;li&gt;global variables&lt;/li&gt;
  &lt;li&gt;stack&lt;/li&gt;
  &lt;li&gt;symbol table, arrays&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;21-segmentation-architecture&quot;&gt;2.1 Segmentation Architecture&lt;/h3&gt;

&lt;p&gt;✔️  Logical address 구성&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;segment-number, offset&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✔️ Segment table&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;each table entry has:
    &lt;ul&gt;
      &lt;li&gt;base - starting physical address of the segment&lt;/li&gt;
      &lt;li&gt;limit - length of ther segment&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✔️ Segment-table base register (STBR)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;물리적 메모리에서의 segment table의 위치&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✔️ Segment-table length register (STLR)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로그램이 사용하는 segment의 수
    &lt;ul&gt;
      &lt;li&gt;segment number의 크기는 STLR의 범위를 넘어서면 안됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56028408/162457379-518ac837-ad86-4c43-81e5-5d4980bfc828.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;✔️ Segmentation의 주소변환&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;논리주소의 SegmentNumber가 STLR보다 작은 값인지 확인하고 만약 더 큰 값을 요청했다면 trap을 발생시킨다.&lt;/li&gt;
  &lt;li&gt;값이 STLR 범위에 포함될 경우 offset의 값이 segment의 메모리 범위안에 포함되는 지 확인한다&lt;/li&gt;
  &lt;li&gt;포함되는 값이면 Segment 시작위치와 Offset을 더해, 물리적 메모리 주소의 위치를 찾는다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;22-sharing-of-segments&quot;&gt;2.2 Sharing of Segments&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56028408/162607258-d2d5e09d-aef6-45ed-8a06-5aebb18dff41.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;✔️ Sharing of Segments&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;첨부된 이미지를 보면 segment0은 프로세스 P1, P2가 서로 공유하여 사용하고 있다. 
하나의 세그먼트를 여러개의 프로세스가 사용할 경우 각 프로세스들은 segment0에 대해 동일한 논리적메모리 주소를 가져야한다.
반면 각 프로세스마다 따로 사용하는 private segment의 경우 각자 다른 물리적 메모리 주소에 위치해있기 때문에 프로세스마다 논리적 메모리 주소도 동일하지 않아도 된다.&lt;/p&gt;

&lt;h3 id=&quot;23-paged-segmentation&quot;&gt;2.3 Paged Segmentation&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Paged Segmentation은 Segmentation과 Paging 기법의 장점만을 가져와서 각 기법의 단점들을 보완한 방식이다.&lt;/p&gt;

  &lt;p&gt;무슨 말이냐 하면, Segmentation의 의미있는 단위로 프로그램을 나누는 방식과 Paging 기법의 동일한 크기로 프로그램을 나눈다는 장점이 합쳐진 것이다.&lt;/p&gt;

  &lt;p&gt;Paged Segmentation기법에서는 segment가 임의의 길이를 가진 것이 아닌 동일한 크기의 page들의 집합으로 구성되어 있다. 물리적 메모리에 적재하는 단위도 page 단위이기 때문에 외부조각 문제가 발생하지 않는다. 기존 Segmentation 방식과의 차이점은 segment table entry가 segment의 base address를 가지고 있는 것이 아니라 segment를 구성하는 page table의 base address를 가지고 있다는 것이다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56028408/162607255-5f3ac626-a6cc-448c-bf26-1fae59baf8da.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;✔️  &lt;strong&gt;Paged Segmentation&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Paged Segmentation 기법에선 주소 변환을 위해 외부의 세그먼트 테이블과 내부의 세그먼트 테이블을 이용한다.&lt;/li&gt;
  &lt;li&gt;하나의 세그먼트가 여러개의 페이지 테이블로 구성되기 때문에 각 세그먼트마다 페이지 테이블을 가진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✔️  &lt;strong&gt;Paged Segmentation의 주소변환 과정&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;논리적 주소의 상위 비트인 세그먼트 번호를 통해 세그먼트 테이블의 해당 항목으로 접근한다. (논리적 주소에서는 세그먼트 번호와 offset이 존재)
    &lt;ol&gt;
      &lt;li&gt;접근한 세그먼트 항목에는 세그먼트 길이와 그 세그먼트의 페이지 테이블 시작 주소가 들어 있다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;세그먼트 길이값과 논리적 주소 하위 비트인 offset 값을 비교하고 offset값이 더 크다면 유효하지 않은 접근이므로 트랩을 발생시킨다.&lt;/li&gt;
  &lt;li&gt;그렇지 않은 경우 offset 값을 다시 상위 비트와 하위비트로 나눈다. (상위 비트는 세그먼트 내의 페이지 번호로 사용하고 하위 비트는 페이지 내의 변위로 사용한다)&lt;/li&gt;
  &lt;li&gt;세그먼트 테이블에 저장된 해당 세그먼트를 위한 페이지 테이블의 시작 위치를 확인했으므로 그 위치에서 페이지 번호만큼 떨어진 페이지 테이블 항목으로부터 물리적 메모리의 페이지 프레임 위치를 얻게 된다.&lt;/li&gt;
  &lt;li&gt;해당 페이지 프레임 위치에서 offset의 하위 비트값인 페이지 내 변위만큼 떨어진 곳이 물리적 메모리 주소이다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;memory-management에서-운영체제의-역할은&quot;&gt;💡 Memory Management에서 운영체제의 역할은?&lt;/h2&gt;

&lt;p&gt;없다. 앞서 설명한 내용들은 운영체제가 아닌 하드웨어들의 역할이다. 왜냐하면 프로세스가 CPU를 할방받으면서 메모리에 접근하는 것은 운영체제가 도움을 주는 것이 아니기 때문이다. 만약 메모리에 접근할 때 사용자 프로그램이 운영체제를 필요로하게 된다면, 사용자 프로그램이 메모리에 접근을 시도할 때마다 사용자 모드에서 커널모드로 변경되는 매우 비효율적인 작업이 진행될 것이다. 사용자 프로그램이 운영체제의 도움이 필요할 때는 메모리 접근이 아닌 I/O device 접근이다.&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;&lt;strong&gt;Reference&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;이화여자대학교 반효경 교수님 운영체제 강의&lt;/p&gt;</content><author><name></name></author><category term="반효경" /><category term="불연속할당" /><category term="페이징" /><category term="세그멘테이션" /><category term="Invalid Bit / Protection Bit" /><summary type="html">🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟</summary></entry><entry><title type="html">[운영체제 스터디] 메모리 관리 - 논리적 주소와 물리적 주소</title><link href="http://localhost:4000/os/2022/04/15/os-study-09.html" rel="alternate" type="text/html" title="[운영체제 스터디] 메모리 관리 - 논리적 주소와 물리적 주소" /><published>2022-04-15T00:00:00+09:00</published><updated>2022-04-15T00:00:00+09:00</updated><id>http://localhost:4000/os/2022/04/15/os-study-09</id><content type="html" xml:base="http://localhost:4000/os/2022/04/15/os-study-09.html">&lt;p&gt;🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟&lt;/p&gt;

&lt;h1 id=&quot;️memory-management-1&quot;&gt;🗳️ Memory Management 1&lt;/h1&gt;

&lt;h2 id=&quot;1-논리적-주소와-물리적-주소&quot;&gt;1. 논리적 주소와 물리적 주소&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;✔️  논리적 주소란(Logical address)?&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스마다 독립적으로 가지는 주소 공간&lt;/li&gt;
  &lt;li&gt;각 프로세스마다 0번지부터 시작&lt;/li&gt;
  &lt;li&gt;CPU가 보는 주소는 &lt;strong&gt;logical address&lt;/strong&gt;이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;✔️  물리적 주소란(Logical address)?&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;실제 메모리에 올라가는 위치&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;12-주소-바인딩address-binding&quot;&gt;1.2 주소 바인딩(Address Binding)&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;프로세스의 물리적 메모리 주소를 결정하는 것&lt;/p&gt;

  &lt;p&gt;Symbolic Address → Logical Address → Physical Address&lt;/p&gt;

  &lt;p&gt;🌟 &lt;strong&gt;Symbolic Address?&lt;/strong&gt; 프로그래머가 사용하는 심볼릭한 주소&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;✔️ &lt;strong&gt;사용자 프로그램&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;logical address만을 다룬다&lt;/li&gt;
  &lt;li&gt;실제 physical address를 볼 수 없으며 알 필요가 없다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✔️ &lt;strong&gt;Compile time binding&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;물리적 메모리 주소(physical address)가 컴파일 시 알려짐&lt;/li&gt;
  &lt;li&gt;시작 위치 변경시 재컴파일&lt;/li&gt;
  &lt;li&gt;컴파일러는 절대 코드(absolute code) 생성&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;❗ &lt;strong&gt;논리적 메모리 주소가 물리적 메모리의 주소가 되므로 여유있는 메모리 공간이 있어도 고정적인 메모리 주소를 갖기 때문에 비효율적&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;✔️  &lt;strong&gt;Load time binding&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로그램 실행 시 물리적 주소가 결정되는 방식&lt;/li&gt;
  &lt;li&gt;컴파일러가 재배치 가능한 코드를 생성한 경우 발생 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✔️  &lt;strong&gt;Run time binding&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로그램 실행 도중 물리적 메모리 주소가 변경될 수 있는 방식&lt;/li&gt;
  &lt;li&gt;CPU가 주소를 참조할 때마다 binding을 점검해야 함 (address mapping table)&lt;/li&gt;
  &lt;li&gt;하드웨어적인 지원이 필요함
    &lt;ul&gt;
      &lt;li&gt;(base and limit registers, &lt;strong&gt;MMU&lt;/strong&gt;)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;현대에서 주로 사용되는 방식&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✔️ &lt;strong&gt;Memory-Management Unit (MMU)?&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MMU
    &lt;ul&gt;
      &lt;li&gt;logical address를 physical address로 매핑해 주는 Hardware device&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;MMU scheme
    &lt;ul&gt;
      &lt;li&gt;사용자 프로세스가 CPU에서 수행되며 생성해내는 모든 주소값에 대해 base register (=relocation register)의 값을 더한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;💡 &lt;strong&gt;운영체제 및 사용자 프로세스 간의 메모리 보호를 위해 사용하는 레지스터&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;relocation register
    &lt;ul&gt;
      &lt;li&gt;프로세스의 물리적 메모리 시작위치를 저장한다 (접근할 수 있는 물리적 메모리 주소의 최소값)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;limit register
    &lt;ul&gt;
      &lt;li&gt;물리적 메모리 주소의 한계영역을 지정하기 위해 프로그램의 최대 크기를 저장한다.&lt;/li&gt;
      &lt;li&gt;논리적 주소의 범위 (프로그램의 최대 크기)
        &lt;ul&gt;
          &lt;li&gt;예를 들어 P1의 시작 주소가 14000이고 프로그램의 크기가 3000일 때 P1은 14000~17000 사이만 접근할 수 있다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-some-terminologies&quot;&gt;2. Some Terminologies&lt;/h2&gt;

&lt;h3 id=&quot;1-dynamic-loading&quot;&gt;1. Dynamic Loading&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스 전체를 메모리에 미리 다 올리는 것이 아니라 해당 루틴이 불려질  때 메모리에 load하는 것&lt;/li&gt;
  &lt;li&gt;memory utilization의 향상&lt;/li&gt;
  &lt;li&gt;가끔식 사용되는 많은 양의 코드의 경우 유용
    &lt;ul&gt;
      &lt;li&gt;ex) 오류 처리 루틴&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;운영체제의 특별한 지원 없이 프로그램 자체에서 구현 가능(OS는 라이브러리를 통해 프로그래머를 지원함)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-overlays&quot;&gt;2. Overlays&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;메모리에 프로세스의 부분 중 실제 필요한 정보만을 올림&lt;/li&gt;
  &lt;li&gt;프로세스의 크기가 메모리보다 클 때 유용&lt;/li&gt;
  &lt;li&gt;운영체제의 지원없이 사용자에 의해 구현&lt;/li&gt;
  &lt;li&gt;작은 공간의 메모리를 사용하던 초창기 시스템에서 수작업으로 프로그래머가 구현
    &lt;ul&gt;
      &lt;li&gt;Manual Overlay&lt;/li&gt;
      &lt;li&gt;프로그래밍이 매우 복잡함&lt;/li&gt;
      &lt;li&gt;Dynamic Loading과 비슷한 역할을 하지만 OS의 지원이 하나도 없다는 점에서 차이가 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-dynamic-linking&quot;&gt;3. Dynamic Linking&lt;/h3&gt;

&lt;p&gt;Linking을 실행 시간(execution time)까지 미루는 기법&lt;/p&gt;

&lt;p&gt;✔️ &lt;strong&gt;Static Linking&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;라이브러리가 프로그램의 실행 파일 코드에 포함됨&lt;/li&gt;
  &lt;li&gt;실행 파일의 크기가 커짐&lt;/li&gt;
  &lt;li&gt;동일한 라이브러리를 각각의 프로세스가 메모리에 올리므로 메모리 낭비
    &lt;ul&gt;
      &lt;li&gt;ex) printf를 호출하는 n개의 프로세스가 있으면 동일한 라이브러리여도 각각 printf 함수의 라이브러리를 메모리에 올리게 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✔️ &lt;strong&gt;Dynamic linking&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;라이브러리가 실행시 연결(link)됨&lt;/li&gt;
  &lt;li&gt;라이브러리 호출 부분에 라이브러리 루틴의 위치를 찾기 위한 stub이라는 작은 코드를 둠&lt;/li&gt;
  &lt;li&gt;라이브러리가 이미 메모리에 있으면 그 루틴의 주소로 가고 없으면 디스크에서 읽어옴&lt;/li&gt;
  &lt;li&gt;운영체제의 도움이 필요함&lt;/li&gt;
  &lt;li&gt;Dynamic linking을 지원하는 라이브러리를 shared library 라고 함
    &lt;ul&gt;
      &lt;li&gt;window → DLL&lt;/li&gt;
      &lt;li&gt;linux → shared object&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-swapping&quot;&gt;4. Swapping&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;프로세스를 일시적으로 메모리에서 backing store로 쫓아내는 것&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;Backing store(=swap area)?&lt;/strong&gt;
      &lt;ul&gt;
        &lt;li&gt;디스크
          &lt;ul&gt;
            &lt;li&gt;많은 사용자의 프로세스 이미지를 담을 만큼 충분히 빠르고 큰 저장 공간&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;✔️ &lt;strong&gt;Swap in / Swap out&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;일반적으로 중기 스케줄러(swapper)에 의해 swap out 시킬 프로세스 선정&lt;/li&gt;
  &lt;li&gt;priority-based CPU scheduling algorithm
    &lt;ul&gt;
      &lt;li&gt;CPU 우선순위가 낮은 프로세스를 swapped out 시킴&lt;/li&gt;
      &lt;li&gt;CPU 우선순위가 높은 프로세스를 메모리에 올려놓음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Complie time 혹은 load time binding에서는 다른 메모리 공간이 비어있더라도 원래 메모리 위치로 swap in 해야 함&lt;/li&gt;
  &lt;li&gt;Execution time binding에서는 추후 빈 메모리 영역 아무 곳에나 올릴 수 있음&lt;/li&gt;
  &lt;li&gt;swap time은 대부분 transfer time(swap되는 양에 비례하는 시간)임&lt;/li&gt;
  &lt;li&gt;원칙적으로 프로세스 전체가 메모리에서 쫓겨나는 것을 Swap out 이라고 하지만 프로세스 일부분이 쫓겨나는 것도 swap out 이라고 부르기도 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-물리적-메모리-관리&quot;&gt;3. 물리적 메모리 관리&lt;/h2&gt;

&lt;p&gt;✔️ &lt;strong&gt;메모리는 일반적으로 두 영역으로 나눠어서 사용 됨&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;OS 상주 영역(커널)
    &lt;ul&gt;
      &lt;li&gt;interrupt vector와 함께 낮은 주소 영역 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용자 프로세스 영역&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✔️ &lt;strong&gt;사용자 프로세스 영역의 할당 방법&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Contiguous allocation(연속할당)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;각각의 프로세스가 메모리의 연속적인 공간에 적재되도록 하는 것
        &lt;ul&gt;
          &lt;li&gt;Fixed partition allocation&lt;/li&gt;
          &lt;li&gt;Variable partition allocation&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Noncontiguous allocation(불연속할당)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;현대 시스템의 사용 방법&lt;/li&gt;
      &lt;li&gt;하나의 프로세스가 메모리의 여러 영역에 분산되어 올라갈 수 있음
        &lt;ul&gt;
          &lt;li&gt;Paging&lt;/li&gt;
          &lt;li&gt;Segmentation&lt;/li&gt;
          &lt;li&gt;Paged Segmentation&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✔️ &lt;strong&gt;외부조각과 내부조각&lt;/strong&gt; &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;External fragmentation(외부 조각)
    &lt;ul&gt;
      &lt;li&gt;프로그램 크기보다 분할의 크기가 작은 경우&lt;/li&gt;
      &lt;li&gt;아무 프로그램에도 배정되지 않은 빈 곳인데도 프로그램이 올라갈 수 없는 작은 분할&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Internal Fragmentation(내부 조각)
    &lt;ul&gt;
      &lt;li&gt;프로그램 크기보다 분할의 크기가 큰 경우&lt;/li&gt;
      &lt;li&gt;하나의 분할 내부에서 발생하는 사용되지 않는 메모리 조각&lt;/li&gt;
      &lt;li&gt;분할에 배정된 프로그램보다 분할의 크기가 더 커서 생기는 사용되지 않는 메모리 공간&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-contiguous-allocation연속할당&quot;&gt;4. Contiguous allocation(연속할당)&lt;/h2&gt;

&lt;h3 id=&quot;41-fixed-partition고정분할&quot;&gt;4.1 &lt;strong&gt;Fixed partition(고정분할)&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;물리적 메모리를 몇 개의 영구적 분할(partition)으로 나눔&lt;/li&gt;
  &lt;li&gt;분할의 크기가 모두 동일한 방식과  서로 다른 방식이 존재&lt;/li&gt;
  &lt;li&gt;분할당 하나의 프로그램 적재&lt;/li&gt;
  &lt;li&gt;융통성이 없음
    &lt;ul&gt;
      &lt;li&gt;동시에 메모리에 load되는 프로그램의 수가 고정됨&lt;/li&gt;
      &lt;li&gt;최대 수행 가능 프로그램 크기 제한&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;internal fragmentation(=내부조각) 과  external fragmentation(=외부조각) 발생&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;42-variable-partition가변분할&quot;&gt;4.2 &lt;strong&gt;Variable partition(가변분할)&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;프로그램의 크기를 고려해서 할당&lt;/li&gt;
  &lt;li&gt;분할의 크기, 개수가 동적으로 변함&lt;/li&gt;
  &lt;li&gt;기술적 관리 기법 필요&lt;/li&gt;
  &lt;li&gt;external fragmentation(=외부조각) 발생&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1️⃣  &lt;strong&gt;Hole&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;가용 메모리 공간&lt;/li&gt;
  &lt;li&gt;다양한 크기의 hole들이 메모리 여러 곳에 흩어져 있음&lt;/li&gt;
  &lt;li&gt;프로세스가 도착하면 수용가능한 hole을 할당&lt;/li&gt;
  &lt;li&gt;운영체제는 다음의 정보를 유지
    &lt;ul&gt;
      &lt;li&gt;a) 할당 공간 b) 가용 공간(hole)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2️⃣  &lt;strong&gt;Dynamic Storage-Allocation Problem&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;가변 분할 방식에서 size n인 요청을 만족하는 가능 적절한 hole을 찾는 문제&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;First-fit&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Size가 n 이상인 것 중 최초로 찾아지는 hole에 할당&lt;/li&gt;
      &lt;li&gt;셋 중 오버헤드가 가장 적음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Best-fit&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Size가 n 이상인 가장 작은 hole을 찾아서 할당&lt;/li&gt;
      &lt;li&gt;Hole들의 리스트가 크기순으로 정렬되지 않은 경우 모든 hole의 리스트를 탐색해야함&lt;/li&gt;
      &lt;li&gt;많은 수의 아주 작은 hole들이 생성됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Worst-fit&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;가장 큰 hole에 할당&lt;/li&gt;
      &lt;li&gt;역시 모든 리스트를 탐색해야 함&lt;/li&gt;
      &lt;li&gt;상대적으로 아주 큰 hole들이 생성됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;🌟 First-fit과 Best-fit이 Worst-fit보다 속도와 공간 이용률 측면에서 횩하적인 것으로 알려짐 (실험적 결과)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;3️⃣  &lt;strong&gt;Compaction&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;external fragmentation 문제를 해결하는 한 가지 방법&lt;/li&gt;
  &lt;li&gt;사용 중인 메모리 영역을 한군데로 몰고 hole들을 다른 한 곳으로 몰아 큰 block을 만드는 것&lt;/li&gt;
  &lt;li&gt;전체 프로그램 바인딩과 관련되어 있기 때문에 비용이 많이 듬&lt;/li&gt;
  &lt;li&gt;최소한의 메모리 이동으로 compaction하는 방법 (매우 복잡한 문제)&lt;/li&gt;
  &lt;li&gt;Compcation은 프로세스의 주소가 실행 시간에 동적으로 재배치 가능한 경우에만 수행될 수 있다.
    &lt;ul&gt;
      &lt;li&gt;Runtime binding이 지원되어야 사용 가능함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;reference&quot;&gt;&lt;strong&gt;Reference&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;이화여자대학교 반효경 교수님 운영체제 강의&lt;/p&gt;</content><author><name></name></author><category term="반효경" /><category term="메모리관리" /><category term="운영체제" /><category term="가변분할" /><category term="외부조각과 내부조각" /><summary type="html">🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟</summary></entry><entry><title type="html">[네트워크 스터디] Chapter_01 웹 브라우저가 메세지를 만든다</title><link href="http://localhost:4000/networkstudy/2022/04/14/network-study-01.html" rel="alternate" type="text/html" title="[네트워크 스터디] Chapter_01 웹 브라우저가 메세지를 만든다" /><published>2022-04-14T00:00:00+09:00</published><updated>2022-04-14T00:00:00+09:00</updated><id>http://localhost:4000/networkstudy/2022/04/14/network-study-01</id><content type="html" xml:base="http://localhost:4000/networkstudy/2022/04/14/network-study-01.html">&lt;h1 id=&quot;-chapter_01-웹-브라우저가-메세지를-만든다&quot;&gt;📗 Chapter_01 웹 브라우저가 메세지를 만든다&lt;/h1&gt;
&lt;h2 id=&quot;1-http-리퀘스트-메세지를-작성한다&quot;&gt;&lt;strong&gt;1. HTTP 리퀘스트 메세지를 작성한다&lt;/strong&gt;&lt;/h2&gt;

&lt;h3 id=&quot;1️⃣-url&quot;&gt;&lt;strong&gt;1️⃣  URL&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;✔️ HTTP URL 의 구성&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ex ) &lt;a href=&quot;http://user:passwork@www.cyber.co.kr&quot;&gt;http://user:password@www.example.co.kr&lt;/a&gt;:80/dir/file1.html&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로토콜 →  http&lt;/li&gt;
  &lt;li&gt;사용자명 (생략 가능) → user&lt;/li&gt;
  &lt;li&gt;패스워드 (생략 가능) → password&lt;/li&gt;
  &lt;li&gt;웹 서버의 도메인명 → &lt;a href=&quot;http://www.example.co.kr&quot;&gt;www.example.co.kr&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;포트번호 (생략 가능) → 80&lt;/li&gt;
  &lt;li&gt;파일의 경로명 → /dir/file1.html&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;💡 HTTP 의 경우 기본 포트는 80이고 HTTPS의 기본 포트는 443이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;✔️ &lt;strong&gt;URL 은 여러 종류가 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;URL은 http로 구성되어있는 것 말고도 ftp: 나 mailto: 같은 다양한 프로토콜의 URL이 존재한다. 이유는, 브라우저는 웹 서버에 엑세스하는 클라이언트로만 사용하는 것이 아니라 파일을 다운로드/업로드하는 FTP의 기능이나&lt;/p&gt;

&lt;p&gt;메일클라이언트의 기능도 가지고 있기 때문이다. 브라우저는 URL을 토대로 여러개의 기능 중 어느것을 사용하여 데이터에 엑세스하면 될지를 판단한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;✔️ 다양한 URL의 구성&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56028408/163106926-34b4cb16-6547-41bb-b016-0b2c4e6b081a.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이와같이 쓰는 방법은 다양하지만 모든 URL에는 하나의 공통점이 있다. URL 맨 앞에 있는 프로토콜에 따라서 액세스 하는 대상이 달라진다는 것이다.&lt;/p&gt;

&lt;p&gt;예를 들어 액세스 대상이 웹 서버라면 HTTP 프로토콜을 사용하고, FTP 서버라면 FTP, 메일을 송신할 때는 mailto 프로토콜을 사용하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2️⃣--브라우저의-url-해독-방식&quot;&gt;2️⃣  &lt;strong&gt;브라우저의 URL 해독 방식&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;웹 서버에 보내는 리퀘스트 메세지를 작성하기 전에 URL을 해독한다. 아래 내용은 브라우저가 웹 서버에 엑세스하는 경우를 예로들어 설명한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;URL을 요소별로 분리하여 나열한 것은 아래와 같다.&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//www.example.co.kr](http://user:passwork@www.cyber.co.kr):80/dir/file1.html&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ] + [ 웹 서버명 ] + [ / ] + [ 디렉토리명 ] +[ / ] + .... + [ 파일명 ]   &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;http는 앞서 설명한 프로토콜이 되는 것이고 //는 나중에 이어지는 문자열이 서버의 이름임을 나타낸다.&lt;/p&gt;

&lt;p&gt;웹 서버명 다음에 이어지는 것은 서버에 파일이 저장된 위치인데 이는 생략이 가능하다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;✔️  파일명을 생략한 경우&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ex) &lt;a href=&quot;http://user:passwork@www.cyber.co.kr&quot;&gt;http://www.example.co.kr&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;예시 url은 파일명을 생략했을 때의 url이다. 파일명을 생략하면 서버가 어느 파일에 액세스해야 하는 지 알 수 없다.&lt;/p&gt;

&lt;p&gt;그래서 이와같은 문제를 대비하여 서버에서 파일명이 생략되었을 때 액세스할 default 파일을 설정해둔다. 대부분의 서버는 index.html 이나 default.html 이라는 파일명으로 설정해둔다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;💡  브라우저가 가장 먼저 하는 일은 URL 해독이다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;3️⃣http의-기본-개념&quot;&gt;3️⃣ HTTP의 기본 개념&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Hyper-Text Transfer Protocol(HTTP)란 지정된 규약을 지켜 웹 서버와 데이터를 주고받는 서버/클라이언트 모델을 따르는 비연결성 &amp;amp; 무상태 프로토콜이다.&lt;/p&gt;

  &lt;p&gt;애플리케이션 레벨의 프로토콜로 TCP/IP 위에서 작동한다. HTTP 패킷에는 여러 메타데이터와 성공 실패 정보가 담겨있으므로 서버와 클라이언트가 원활하게 대화할 수 있다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;💡  비연결성&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;연결을 유지하지 않는 것  특정한 옵션을 주면 일정시간동안 연결을 유지할 수는 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;💡  무상태&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;서버가 클라이언트의 상태를 보존하지 않는 것 매번 요청에 모든 상태값들을 전달해줘야 함 상태를 유지해줘야 할 경우 쿠키나 세션을 사용 함&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;✔️ HTTP Reuqest 패킷 구성&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56028408/163209206-2d7e3008-230e-4da7-9041-453bcfa2d23d.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;HTTP 요청 패킷은 크게 요청라인, 메세지 정보, 본문으로 나눌 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;요청라인 → HTTP Method, URL, HTTP 버전&lt;/li&gt;
  &lt;li&gt;메세지 정보 → 해당 요청에 대한 메타데이터를 담고있는 공간&lt;/li&gt;
  &lt;li&gt;본문(body) → 해당 요청의 실제 내용. POST가 아니여도 body를 사용할 수 있지만, 주로 Body를 사용하는 메소드는 POST이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;✔️ HTTP Response 패킷 구성&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56028408/163209182-d49ace5d-d8c1-4e7b-aa31-976c9cdbafb5.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;HTTP 응답 패킷은 크게 상태라인, 메세지 정보, 본문으로 나눌 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;상태라인 → HTTP Method, 버전, 응답코드
    &lt;ul&gt;
      &lt;li&gt;응답코드는 주로 권한과 서버에러, 클라이언트에러 등으로 나눠서 성공과 실패 여부를 판단하는데에 사용된다,&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;메세지 정보 → 해당 응답에 대한 메타데이터를 담고있는 공간&lt;/li&gt;
  &lt;li&gt;본문(body) → 요청의 Body와 일반적으로 동일하다. body 존재할 수도 있고 존재하지 않을수도 있다. 가장 많이 사용되는 Body의 데이터 타입은 JSON(JavaScript Object Notation)이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;✔️ HTTP Method&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;HTTP 메소드를 정리한 표이다. 버전마다 지원되는 메소드가 다르다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;메소드&lt;/th&gt;
      &lt;th&gt;의미&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;GET&lt;/td&gt;
      &lt;td&gt;지정한 정보를 도출할 때 사용된다. 파일의 경우 해당 파일의 내용을 되돌려보낸다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POST&lt;/td&gt;
      &lt;td&gt;클라이언트에서 데이터를 body에 담아 송신할 때 사용된다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PUT&lt;/td&gt;
      &lt;td&gt;URI로 지정한 서버의 파일을 치환한다. 파일이 없는 경우 새로 등록한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DELETE&lt;/td&gt;
      &lt;td&gt;URL로 지정한 서버의 파일을 삭제한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PATCH&lt;/td&gt;
      &lt;td&gt;리소스의 일부분만을 수정하는데에 쓰인다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;OPTION&lt;/td&gt;
      &lt;td&gt;통신 옵션을 통지하거나 조사할 때 사용된다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;HEAD&lt;/td&gt;
      &lt;td&gt;GET과 거의 같지만 데이터의 내용을 돌려보내지 않고 HTTP 메세지 헤더만을 반송한다. 속성 정보를 조사할 때 사용된다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TRACE&lt;/td&gt;
      &lt;td&gt;서버측에서 받은 리퀘스트 라인과 헤더를 그대로 클라이언트에 반송한다. 프록시 서버 등을 사용하는 환경에서 리퀘스트가 치환되는 상태를 조사할 떄 사용된다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CONNECT&lt;/td&gt;
      &lt;td&gt;암호화한 메세지를 프록시로 전송할 때 이용된다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;✔️ HTTP 간단한 통신과정 예시&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56028408/163209168-f37b8432-03fc-4dbf-883e-001f24d63871.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;웹서버에 특정 리소스를 얻기 위해 URI와 헤더에 요청에 필요한 정보를 담아 서버에 전송한다.&lt;/li&gt;
  &lt;li&gt;해당 리소스가 존재하면 응답 헤더에 필요한 정보를 담아서 보내거나 바디에 해당 요청 데이터를 전송한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;🌟 &lt;strong&gt;실제로 요청과 응답 사이에 검증절차나 여러가지 일들이 일어나지만 자세한 내용은 생략하겠다.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-웹-서버의-ip-주소를-dns-서버에-조회한다&quot;&gt;2. 웹 서버의 IP 주소를 DNS 서버에 조회한다&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;HTTP 메세지를 만드는 것에 성공하면 이것을 OS에 의뢰하여 액세스 대상의 웹 서버에게 송신한다.&lt;/p&gt;

  &lt;p&gt;브라우저는 URL을 해독하거나 HTTP 메세지를 만들 수는 있지만 메세지를 네트워크에 송출하는 기능은 없으므로 OS에 의뢰하는 것이다.&lt;/p&gt;

  &lt;p&gt;이때 URL 안에 쓰여있는 서버의 도메인 명에서 IP 주소를 조사해야하는데, 이는 OS에서 송신을 의뢰할때는 도메인명이 아니라 IP 주소로 메세지를 받을 상대를 지정해야하기 때문이다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;✔️  도메인명과 IP 주소를  구분하여 사용하는 이유&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;TCP/IP 네트워크는 IP 주소로 통신 상대를 지정하므로 IP주소를 모르는 상대에게 메세지를 전달할 수 없다. 이러한 이유 때문에 도메인 명과 IP 주소를 구분하는 것이다. 웹 브라우저는 Socket 라이브러리를 사용하여 도메인 명으로 IP 주소를 조회한다. 
그렇다면 URL 안에서는 서버명이 아니라 IP 주소를 사용하는 것이 더 효율적이라는 생각이 들 수 있다. 실제로 서버명 대신에 IP 주소를 사용해도 올바르게 작동한다.그렇지만 기억하기 어렵다는 단점이 있다. 실행 효율 관점에서 바라보면 IP 주소대신 도메인명으로 사용하는 것이 좋은 방법이라고 할 수 없다. IP 주소는 32비트로 4바이트에 해당하는 개수밖에 없지만, 도메인 명은 수십 바이트 부터 최대 255 바이트 까지 존재한다. 그러면 그만큼 라우터가 부하되어 데이터를 운반하는 동작에 더 많은 시간이 걸릴 것이다. 하지만 이름을 알면 IP 주소를 알 수 있다거나 IP 주소를 사용하면 이름을 알 수있다는 원리를 이용하여 양쪽의 차이를 해소한 DNS가 라우터 부하의 문제점을 해결해준다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;✔️ Socket 라이브러리의 IP 주소 조회&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;웹 브라우저는 Socket 라이브러리의 도움을 받아 DNS서버에서 도메인명의 IP 주소를 조회할 수 있다.&lt;/p&gt;

&lt;p&gt;DNS 서버에서 조회한다는 것은 DNS 서버에 메세지를 보내고 반송되는 응답 메세지를 받는 것이다. 이것은 DNS 클라이언트로 동작한다고 말할 수 있다. DNS 클라이언트에 해당되는 것을 DNS 리졸버(=리졸버)라고 한다.&lt;/p&gt;

&lt;p&gt;DNS 원리를 이용하여 IP 주소를 조사하는 것을 네임 리졸루션 (name resolution) 이라고 하는데 리졸루션을 수행하는 것이 리졸버이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;💡 Socket 라이브러리&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;OS를 이용하여 네트워크의 기능을 호출하기 위한 프로그램의 부품집&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;️리졸버-내부의-작동&quot;&gt;✔️ 리졸버 내부의 작동&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56028408/163209513-02792b34-4c07-4427-9ed5-0f0a68b403ce.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;✔️  &lt;strong&gt;리졸버를 이용하여 DNS 서버를 조회한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;리졸버의 프로그램명(gethostbyname)과 웹 서버의 이름을 쓰기만 하면 리졸버를 호출할 수 있다. &lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;브라우저 애플리케이션이 Socket 라이브러리의 리졸버를 호출한다. 이때 gethostbyname에 웹서버 이름을 전달한다.&lt;/li&gt;
  &lt;li&gt;리졸버가 DNS 서버에 조회 메세지를 보낸다. 메세지 송신 동작은 OS 내부의 프로토콜 스택을 호출하여 수행한다.&lt;/li&gt;
  &lt;li&gt;DNS 서버에서 돌아온 응답 메세지를 수신한다.&lt;/li&gt;
  &lt;li&gt;응답 메세지에서 IP 주소를 추출하고 메모리 영역에 저장한 뒤 애플리케이션으로 돌아간다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;🌟  DNS 서버에 메세지를 송신할 때도 DNS 서버의 IP 주소가 필요한데, 이는 컴퓨터의 TCP/IP 설정 항목의 하나로 컴퓨터에 미리 설정되어 있다. &lt;/p&gt;

&lt;h2 id=&quot;3-전-세계의-dns-서버가-연대한다&quot;&gt;3. 전 세계의 DNS 서버가 연대한다&lt;/h2&gt;

&lt;h3 id=&quot;1️⃣-dns-서버의-기본동작&quot;&gt;1️⃣ &lt;strong&gt;DNS 서버의 기본동작&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;DNS 서버의 기본 동작은 클라이언트에서 조회 메세지를 받고 조회의 내용에 응답하는 형태로 정보를 회답하는 일이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;✔️  조회 메세지 구성&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이름
    &lt;ul&gt;
      &lt;li&gt;서버의 메일 배송 목적지와 같은 이름, 도메인 명&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;클래스
    &lt;ul&gt;
      &lt;li&gt;네트워크 종류를 검토하기위해 사용되는 것 현재는 인터넷 외의 네트워크는 소멸되었기 때문에 항상 인터넷을 나타내는 IN 값이 전달된다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;타입
    &lt;ul&gt;
      &lt;li&gt;이름에 어떤 타입의 정보가 지원되는지를 나타낸다. 타입이 A이면 이름에 IP 주소가 지원되는 것을 나타내고 MX이면 이름에 메일 배송 목적지가 지원된다는 것을 나타낸다. 타입에 따라 클라리언트에 회답하는 정보의 내용이 달라진다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이름이 &lt;a href=&quot;http://www.example.com&quot;&gt;www.example.com&lt;/a&gt; 인 서버의 IP 주소를 조사할 때 클라이언트는 다음과 같은 메세지를 보낸다.&lt;/p&gt;

&lt;p&gt;해당 메세지를 수신했을 때 DNS가 어떠한 동작을 하는지 알아보자&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[요청 메세지 예시 ]&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이름 = www.example.com&lt;/li&gt;
  &lt;li&gt;클래스 = IN&lt;/li&gt;
  &lt;li&gt;타입 = A&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[DNS 서버 내부 등록 정보 예시]&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;이름&lt;/th&gt;
      &lt;th&gt;클래스&lt;/th&gt;
      &lt;th&gt;타입&lt;/th&gt;
      &lt;th&gt;클라이언트에 회답하는 항목&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;www.example.com&lt;/td&gt;
      &lt;td&gt;IN&lt;/td&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;192.168.2.5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;example.com&lt;/td&gt;
      &lt;td&gt;IN&lt;/td&gt;
      &lt;td&gt;MX&lt;/td&gt;
      &lt;td&gt;192.168.2.6&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[DNS 서버의 동작]&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;DNS가 메세지를 수신하면 DNS 서버는 이름, 클래스, 타입의 값이 일치하는 데이터를 찾는다.&lt;/li&gt;
  &lt;li&gt;일치하는 데이터가 있으면 요청 값에 맞는 데이터를 클라이언트에게 전송한다. (예제를 기준으로 하면 192.168.2.5)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt; &lt;strong&gt;💡  DNS 서버는 서버에 등록된 도메인명과 IP 주소의 대응표를 조사하여 IP 주소를 회답한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2️⃣-도메인의-계층&quot;&gt;2️⃣  도메인의 계층&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;인터넷에선 막대한 수의 서버가 존재하기 때문에 모든 도메인 명을 하나의 DNS 서버에 등록하는 것은 불가능하다.&lt;/p&gt;

  &lt;p&gt;이러한 문제점은 정보를 분산시켜 다수의 DNS 서버에 등록하는 방식으로 해결할 수 있다. 다수의 DNS 서버는 계층적으로 구성되어있는데, 이는 조회 메세지를 수신한 DNS 서버에 해당 정보가 등록되어 있지 않아도 계층적으로 연대하고 있는 다른 DNS 서버에서 찾을 수 있다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;DNS 서버에 등록된 모든 정보는 모든 도메인명이라는 계층적 구조를 가진 이름이 붙여져 있다. DNS에서 취급하는 이름은 &lt;a href=&quot;http://www.example.com&quot;&gt;www.example.com&lt;/a&gt; 처럼 점으로 구분되어 있는데, 점으로 게층을 구분한다. 오른쪽에 위치한 것이 상위 계층이다. 계층구조와 같은 형태로 DNS 서버가 배치되며,  각 계층은 각자의 DNS 서버에 저장된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[계층 구조 예시]&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;URL → &lt;a href=&quot;http://www.example.com&quot;&gt;www.example.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;오른쪽에 위치한 것이 상위 계층이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;com
    &lt;ul&gt;
      &lt;li&gt;example
        &lt;ul&gt;
          &lt;li&gt;www&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;✔️  담당 DNS 서버를 찾아 IP 주소를 가져온다&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;인터넷에는 DNS 서버가 수만 대가 있으므로 닥치는 대로 이를 뒤지면서 해당 도메인의 IP를 찾을 수는 없다.&lt;/p&gt;

  &lt;p&gt;그래서 다음과 같은 방법으로 이를 해결한다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h4 id=&quot;예시&quot;&gt;&lt;strong&gt;[예시]&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;URL → &lt;a href=&quot;http://www.example.com&quot;&gt;www.example.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;예시 URL 기준으로 최상위 도메인은 com이다. 하지만 실제로 URL은 com이나 kr 위에 루트 도메인이 존재한다. 루트 도메인은 com이나 kr같은 도메인 명이 존재하지 않기 때문에 보통 도메인을 쓸 때는 이것을 생략한다. 명시적으로   &lt;a href=&quot;http://www.example.com&quot;&gt;www.example.com&lt;/a&gt;. 처럼 URL 끝에 마침표를 찍기도 하지만 보통은 그렇게 사용하지 않는다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;하위의 도메인을 담당하는 DNS 서버의 IP 주소를 상위의 DNS 서버에 등록한다. &lt;/li&gt;
  &lt;li&gt;상위의 DNS 서버를 또 그 상위의 DNS 서버에 등록한다.&lt;/li&gt;
  &lt;li&gt;상위의 DNS 서버가 존재하면 이를 반복한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;💡 &lt;strong&gt;이러한 방식은 상위 DNS 서버에서 하위의 DNS 서버의 IP 주소를 알 수 있다. (루트 도메인을 모든 DNS 서버에 등록하면 루트 도메인의 모든 하위 DNS 서버를 조회할 수 있음)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;ip-조회&quot;&gt;&lt;strong&gt;[IP 조회]&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56028408/163209731-4d525bc3-91f4-4d27-8a0e-e297b3456a1a.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;가장 가까운 DNS 서버에게 해당 도메인 명의 IP를 요청한다.&lt;/li&gt;
  &lt;li&gt;IP가 등록되어있지 않을 경우 루트 도메인 서버에게 해당 IP를 요청한다.&lt;/li&gt;
  &lt;li&gt;루트 도메인에도 해당 IP가 등록되지 않았을 경우 하향식으로 접근하여 IP를 찾을 때까지 하위 도메인 서버에 해당 IP 정보를 요청한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;💡  &lt;strong&gt;앞서 설명한 내용은 기본이 되는 동작을 설명한 것으로 현실의 인터넷과 모든 동작이 일치하진 않는다. 현실의 인터넷은 한 대의 DNS 서버에 복수의 DNS 서버를 등록할 수 있으므로 한 도메인에 한대씩 DNS 서버가 존재한다고 단정할 수 없다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;3️⃣dns-서버는-캐시-기능으로-빠르게-회답할-수-있다&quot;&gt;3️⃣  DNS 서버는 캐시 기능으로 빠르게 회답할 수 있다.&lt;/h3&gt;

&lt;p&gt;DNS 서버는 한번 조사한 도메인 명을 캐싱할 수 있다. 요청받은 도메인 명이 캐싱되어 있으면 캐싱되어 있는 정보를 전달한다. 정보가 없을 경우에도 캐싱하기 때문에 정보가 존재하지 않는 다는 것도 빠르게 회답할 수 있다. 하지만 캐시된 정보가 변경될 수도 있으므로 캐시안에 저장된 정보를 올바르다고 단언할 수는 없다.&lt;/p&gt;

&lt;h2 id=&quot;4-프로토콜-스택에-메시지-송신을-의뢰한다&quot;&gt;4. &lt;strong&gt;프로토콜 스택에 메시지 송신을 의뢰한다&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;IP 주소를 조사를 마치면 액세스 대상 웹 서버에 메세지를 송신하도록 OS 내부 프로토콜 스택에 의뢰한다.&lt;/p&gt;

&lt;p&gt;이 동작에서도 Socket 라이브러리를 사용하는데, 복수의 부품을 결정된 순서대로 호출해야하므로 복잡하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;🌟 &lt;strong&gt;Socket 라이브러리를 이용한 데이터 송 수신 동작&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56028408/163209131-ddef6b53-6743-413a-abae-c4b862dcfde6.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;서버측에서 소켓을 생성하고 클라이언트가 파이프를 연결하기를 기다린다. (소켓 생성 단계)&lt;/li&gt;
  &lt;li&gt;클라이언트가 서버측 소켓에 파이프를 연결한다 (소켓 접속 단계)&lt;/li&gt;
  &lt;li&gt;연결이 성공하면 데이터를 송 수신 한다 (송 수신 단계)&lt;/li&gt;
  &lt;li&gt;송 수신 동작이 끝나면 파이프 연결을 해제한다. (연결은 클라이언트, 서버 둘 중 어느 쪽에서 분리해도 상관없다.)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;🌟  결정된 순서대로 Socket 라이브러리를 호출하는 애플리케이션 예시&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56028408/163209107-a08c09a6-c0f1-4509-b64c-adae70159364.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;socket()
    &lt;ul&gt;
      &lt;li&gt;소켓을 생성하고 완료되면 제어권을 애플리케이션에게 넘긴다. 소켓이 생성되면 &lt;strong&gt;디스크립터&lt;/strong&gt;가 반환되는데, 이는 소켓을 식별하기 위한 식별자의 용도로 사용된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;connect()
    &lt;ul&gt;
      &lt;li&gt;디스크립터, 서버의 IP 주소, 포트번호 세 가지 값을 입력하여 특정 소켓에 연결을 요청한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;wirte()
    &lt;ul&gt;
      &lt;li&gt;송신 데이터를 메모리에 할당하고 wirte() 함수를 호출할 때 디스크립터와 송신데이터를 지정한다. 소켓에는 연결된 상대가 기록되어 있으므로 디스크립터로 소켓을 지정하면 연결된 상대가 판명된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;read()
    &lt;ul&gt;
      &lt;li&gt;메세지를 수신할 때 사용된다. 수신한 응답메세지는 수신 버퍼에 저장된다. 수신버퍼는 애플리케이션 내부에 마련된 메모리 영역이므로 수신 버퍼에 메세지를 저장한 시점에 애플리케이션에게 메세지를 넘겨준다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;close()
    &lt;ul&gt;
      &lt;li&gt;메세지 송 수신이 완료되면 연결을 종료하는 함수 만약 read 동작을 수행하고 있는 도중에 연결이 종료되면 수신한 데이터를 건네주고 연결을 종료한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;🌟  디스크립터  =  애플리케이션이 소켓을 식별하는 용도&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;🌟  IP와 포트번호  = 클라이언트와 서버 간에 상대의 소켓을 식별하는 용도&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;🌟  요청에는 하나의 리소스 정보만을 표시하고 있기 때문에 여러 파일의 정보를 읽으려면 요청을 각각 보내야한다. 요청을 각각 보내면 매번 TCP Connection 을 새로 맺어야하는데, 이는 비효율적일 수 있다. 그래서 HTTP 1.1 버전부터 일정시간동안 연결을 유지할 수 있는 옵션이 추가되었다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;reference&quot;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://velog.io/@anhesu11/HTTP-%EA%B8%B0%EB%B3%B8-%EC%9D%B4%EB%A1%A0-%EC%A0%95%EB%A6%AC&quot;&gt;https://velog.io/@anhesu11/HTTP-기본-이론-정리&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;성공과 실패를 결정하는 1%의 네트워크&lt;/p&gt;</content><author><name></name></author><category term="HTTP" /><category term="Socket" /><category term="DNS" /><category term="TCP" /><category term="성공과 실패를 위한 네트워크 1%의 원리" /><summary type="html">📗 Chapter_01 웹 브라우저가 메세지를 만든다 1. HTTP 리퀘스트 메세지를 작성한다</summary></entry><entry><title type="html">[운영체제 스터디] 데드락과 데드락 발생조건 4가지</title><link href="http://localhost:4000/os/2022/04/04/os-study-08.html" rel="alternate" type="text/html" title="[운영체제 스터디] 데드락과 데드락 발생조건 4가지" /><published>2022-04-04T00:00:00+09:00</published><updated>2022-04-04T00:00:00+09:00</updated><id>http://localhost:4000/os/2022/04/04/os-study-08</id><content type="html" xml:base="http://localhost:4000/os/2022/04/04/os-study-08.html">&lt;p&gt;🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟&lt;/p&gt;

&lt;h1 id=&quot;️deadlock&quot;&gt;⚠️ Deadlock&lt;/h1&gt;

&lt;p&gt;✔️ Deadlock&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이련의 프로세스들이 서로가 가진 자원을 기다리며 block된 상태&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✔️ Resource(자원)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;하드웨어, 소프트웨어 등을 포함하는 개념&lt;/li&gt;
  &lt;li&gt;(예) I/O device. CPU cycle, memory space, semaphore 등&lt;/li&gt;
  &lt;li&gt;프로세스가 자원을 사용하는 절차
    &lt;ul&gt;
      &lt;li&gt;요청 (Request),획득 (Allocate),사용 (Use), 반납 (Release)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1-deadlock-발생의-4가지-조건&quot;&gt;1. Deadlock 발생의 4가지 조건&lt;/h2&gt;

&lt;p&gt;✔️ Mutual exclusion (상호배제)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;매 순간 하나의 프로세스만이 자원을 사용할 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✔️ No Preemption(비선점)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스 자원을 스스로 내어놓을 뿐 강제로 빼앗기지 않음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✔️ Hold and wait&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;내가 가진 자원은 양보하지 않으면서 다른 프로세스의 자원을 기다리면서 보유 자원을 내놓지않고 계속 가지고 있는 현상&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✔️ Circular wait&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;자원을 기다리는 프로세스간에 사이클이 형성되어야 함&lt;/li&gt;
  &lt;li&gt;프로세스 P0, P1 …… P5 이 있을 때
    &lt;ul&gt;
      &lt;li&gt;P0은 P1에 가진 자원을 기다림&lt;/li&gt;
      &lt;li&gt;P1은 P2가 가진 자원을 기다림&lt;/li&gt;
      &lt;li&gt;P2는 P3가 가진 자원을 기다림&lt;/li&gt;
      &lt;li&gt;P4는 P0이 가진 자원을 기다림&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-resource-allocation-graph-자원할당-그래프&quot;&gt;2. Resource-Allocation Graph (자원할당 그래프)&lt;/h2&gt;

&lt;p&gt;✔️  &lt;strong&gt;Graph에서 Deadlock 확인 방법&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;그래프에 cycle이 없으면 deadlock이 아니다&lt;/p&gt;

&lt;p&gt;그래프에 cycle이 있을 때 자원의 인스턴스가 여러개이면 deadlock 일 수도 있고 아닐수도 있다.&lt;/p&gt;

&lt;h3 id=&quot;1️⃣graph---1&quot;&gt;1️⃣ Graph - 1&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Vertex&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Process P = {P1, P2, …. Pn}&lt;/li&gt;
  &lt;li&gt;Resource R = {R1, R2, …. Rn}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Edge&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;R2를 보유한 상태로 P1 → R1 자원을 요청&lt;/li&gt;
  &lt;li&gt;R2와 R1을 보유한 상태로 P2 → R3 자원을 요청&lt;/li&gt;
  &lt;li&gt;P3가 R3를 보유&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;DeadLock ?&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;P3에 할당된 R3가 해제될 수 있기 때문에 Cycle은 있으나 &lt;strong&gt;deadlock은 아니다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img width=&quot;254&quot; alt=&quot;스크린샷 2022-04-03 오후 7 06 49&quot; src=&quot;https://user-images.githubusercontent.com/56028408/161425754-ce5a67f4-0051-4f91-84d7-00279f5e6654.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2️⃣graph---2&quot;&gt;2️⃣ Graph - 2&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Vertex&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Process P = {P1, P2, …. Pn}&lt;/li&gt;
  &lt;li&gt;Resource R = {R1, R2, …. Rn}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Edge&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;R2를 보유한 상태로 P1 → R1 자원을 요청&lt;/li&gt;
  &lt;li&gt;R2와 R1을 보유한 상태로 P2 → R3 자원을 요청&lt;/li&gt;
  &lt;li&gt;P3가 R3를 보유한 상태로 P3 → R2 요청&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;DeadLock ?&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스가 서로 가진 자원을 놓지 않고 다른 자원을 기다리고 있기 때문에 &lt;strong&gt;Deadlock 발생&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img width=&quot;238&quot; alt=&quot;스크린샷 2022-04-03 오후 7 07 06&quot; src=&quot;https://user-images.githubusercontent.com/56028408/161425752-4a3dd02a-6ac2-4112-ac99-2a6ed349f6b7.png&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-deadlock의-처리-방법&quot;&gt;3. Deadlock의 처리 방법&lt;/h2&gt;

&lt;p&gt;✔️ Deadlock Prevention&lt;/p&gt;

&lt;p&gt;✔️ Deadlock Avoidance&lt;/p&gt;

&lt;p&gt;✔️ Deadlock Detection and recovery&lt;/p&gt;

&lt;p&gt;✔️ Deadlock Ignorance&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Deadlock을 시스템이 책임지지 않음&lt;/li&gt;
  &lt;li&gt;UNIX를 포함한 대부분의 OS가 채택&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;31-deadlock-prevention&quot;&gt;3.1 Deadlock Prevention&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;자원 할당 시 Deadlock의 4가지 필요 조건 중 어느 하나가 만족되지 않도록 하는 것&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;✔️ Mutual Exclusion&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;공유해서는 안되는 자원의 경우 반드시 성립해야 함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✔️ Hold and Wait&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스가 자원을 요청할 때 다른 어떤 자원도 가지고 있지 않아야 한다&lt;/li&gt;
  &lt;li&gt;방법 1. 프로세스 시작 시 모든 필요한 자원을 할당받게 하는 법&lt;/li&gt;
  &lt;li&gt;방법 2. 다른 필요한 자원이 있으면 보유 자원을 내려놓고 다시 요청&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✔️ No Preemption(비선점)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Process가 어떤 자원을 기다려야 하는 경우 이미 보유한 자원이 선점됨&lt;/li&gt;
  &lt;li&gt;모든 필요한 자원을 얻을 수 있을 때 그 프로세스는 다시 시작된다.&lt;/li&gt;
  &lt;li&gt;State를 쉽게 저장할 수 있고 복원할 수 있는 자원에서 주로 사용된다 (CPU, Memory)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✔️ Circular Wait&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;모든 자원 유형에 할당 순서를 정하여 정해진 순서대로만 자원 할당
    &lt;ul&gt;
      &lt;li&gt;예를 들어 순서가 3인 자원 R1를 보유 중인 프로세스가 순서가 1인 자원 R2를 할당받기 위해서는 우선 R1를  반납해야한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;⚠️  &lt;strong&gt;하지만 아직 발생할지 안할지도 모르는 Deadlock을 위와같은 방법으로 미리 예방하게 된다면 사용성을 저하시키고 성능을 감소되는 문제가 발생할 수 있다. 추가로 기아현상의 위험도 발생한다 ⚠️&lt;/strong&gt; &lt;/p&gt;

&lt;h3 id=&quot;32-deadlock-avoidance&quot;&gt;3.2 Deadlock Avoidance&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;자원 요청에 대한 부가정보를 이용해서 자원 할당이 deadlock으로부터 안전(safe)한지 확인하고 할당한다. 시스템이 unsafe state에 들어가지 않는 것을 보장한다.&lt;/p&gt;

  &lt;p&gt;프로세스들이 필요로 하는 각 자원을 예측하거나 별 최대 사용량을 미리 선언하도록 하는 방법이다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;img width=&quot;284&quot; alt=&quot;스크린샷 2022-04-03 오후 3 50 26&quot; src=&quot;https://user-images.githubusercontent.com/56028408/161425758-2893dc77-0790-4cbd-af5a-26b7aa9af242.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;✔️ safe state&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;시스템 내의 프로세스들에 대한 safe sequence가 존재하는 상태&lt;/li&gt;
  &lt;li&gt;시스템이 safe state에 있으면 deadlock이 발생하지 않음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✔️ unsafe state&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;시스템이 unsafe state에 있으면 deadlock 발생 가능성이 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✔️ avoidance 알고리즘&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Resource Allocation Graph alogorithm
    &lt;ul&gt;
      &lt;li&gt;자원의 인스턴스가 하나일 경우 사용하는 알고리즘&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Banker’s Algorithm
    &lt;ul&gt;
      &lt;li&gt;자원의 인스턴스가 여러개일 경우 사용하는 알고리즘&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1️⃣resource-allocoation-graph-alogorithm&quot;&gt;1️⃣ Resource Allocoation Graph Alogorithm&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;이전에 소개한 Resource Allocoation Graph에서 점선(Clain edge)이 추가된 알고리즘&lt;/p&gt;

  &lt;p&gt;점선은 미래에 사용될 수 있는 자산을 가리킨다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;✔️ Claim edge&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스가 자원을 미래에 요구할 수 있다는 것을 뜻함 (점선)&lt;/li&gt;
  &lt;li&gt;프로세스가 해당 자원 요청시 Claime edge가 request edge로 바뀜 (실선)&lt;/li&gt;
  &lt;li&gt;요청자원이 해제되면 assignment edge는 다시 claim edge로 변경됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✔️ request edge가 assignment edge로 변경 시 (점선을 포함하여) cycle이 생기지 않는 경우에만 요청 자원을 할당한다.&lt;/p&gt;

&lt;p&gt;✔️ Cycle 생성 여부 조사시 프로세스의 수가 n일 때 O(n2)시간이 걸린다.&lt;/p&gt;

&lt;p&gt;✔️ &lt;strong&gt;Resource Allocoation Graph Alogorithm 예시&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;961&quot; alt=&quot;스크린샷 2022-04-03 오후 7 32 33&quot; src=&quot;https://user-images.githubusercontent.com/56028408/161425750-3e18dec7-0642-4e3f-8ae9-0d8344aa0261.png&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;P1과 P2가 미래에 R2를 요청할 가능성이 있음.&lt;/li&gt;
  &lt;li&gt;P2가 R1을 요청한 상태로 R2자원을 요청함.&lt;/li&gt;
  &lt;li&gt;P2가 R2을 할당받음 하지만 실제로 &lt;strong&gt;Resource Allocoation Graph Alogorithm&lt;/strong&gt; 점선을 포함하여 cycle이 생성될 경우 자원을 내어주지 않기 때문에 R2를 할당받지 못한다. P2가 R2를 할당받으려면 R1을 소유하고 있는 P1이 R2를 할당받은 후 P1의 작업이 끝나서 R1과 R2가 해제될 때 P2가 할당받을 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2️⃣bankers-algorithm&quot;&gt;2️⃣ Banker’s Algorithm&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;자원의 인스턴스가 여러개일 경우 사용되는 알고리즘&lt;/p&gt;

  &lt;p&gt;모든 프로세스의 자원의 최대 사용량을 미리 명시하여 최대 사용량이 available 가능한 자원으로 충족 될 경우에만 자원을 내어준다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;✔️  가정&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;모든 프로세스는 자원의 최대 사용량을 미리 명시한다.&lt;/li&gt;
  &lt;li&gt;프로세스가 요청 자원을 모두 할당받은 경우 유한시간 안에 이들 자원을 다시 반납한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✔️  방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;기본 개념 : 자원 요청시 safe 상태를 유지할 경우에만 할당&lt;/li&gt;
  &lt;li&gt;총 요청 자원의 수가 가용 자원의 수보다 적은 프로세스를 선택함 만약 그런 프로세스가 없다면 unsafe한 상태&lt;/li&gt;
  &lt;li&gt;그런 프로세스가 있으면 그 프로세스에게 자원을 할당&lt;/li&gt;
  &lt;li&gt;할당받은 프로세스가 종료되면 모든 자원을 반납&lt;/li&gt;
  &lt;li&gt;모든 프로세스가 종료될 때까지 이러한 과정을 반복&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✔️ &lt;strong&gt;Banker’s Algorithm 예시&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Allocation&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;현재 소유하고 있는 자원&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Max&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;최대로 요청할 수 있는 자원의 수&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Available&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;가용 자원의 수&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Need&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;앞으로 요청할수도 있는 남은 자원의 수 (Max - Allocation)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img width=&quot;508&quot; alt=&quot;스크린샷 2022-04-03 오후 7 50 06&quot; src=&quot;https://user-images.githubusercontent.com/56028408/161425748-e1727a31-270f-4a79-a9e5-8de74c0c8366.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;✔️ 5개의 프로세스가 존재한다고 가정한다.&lt;/p&gt;

&lt;p&gt;✔️ 3개의 자원이 존재한다  A(10), B(5), C(7) 각 자원은 10, 5, 7개의 인스턴스를 가지고 있다.&lt;/p&gt;

&lt;p&gt;✔️  현재 가용 자원보다 Need 자원의 더 클 경우에 해당 프로세스는 자원을 할당받지 못한다. 자원 할당이 가능한 프로세스를 순서대로 나열하면 &amp;lt;P1, P3, P4, P2, P0&amp;gt; 이 된다.&lt;/p&gt;

&lt;h3 id=&quot;33deadlock-detection-and-recovery&quot;&gt;3.3 Deadlock Detection and recovery&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Deadlock 발생은 허용하되 그에 대한 detection 루틴을 두어 deadlock 발견시 recover한다.&lt;/p&gt;

  &lt;blockquote&gt;
    &lt;p&gt;Resource type 당 single instance인 경우 자원할당 그래프에서의 cycle이 곧 deadlock을 의미한다.&lt;/p&gt;

    &lt;p&gt;Resource type 당 multiple instance인 경우 Banker’s algorithm과 유사한 방법을 활용한다.&lt;/p&gt;

  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;1️⃣wait-for-graph-algorithm&quot;&gt;1️⃣ Wait-for graph Algorithm&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;자원당 하나의 인스턴스를 가지고 있을 경우 사용됨&lt;/li&gt;
  &lt;li&gt;Wait-for graph
    &lt;ul&gt;
      &lt;li&gt;자원할당 그래프의 변형&lt;/li&gt;
      &lt;li&gt;프로세스만으로 node를 구성함
        &lt;ul&gt;
          &lt;li&gt;P1이 가지고 있는 자원을 P2가 기다리는 경우 P2 → P1&lt;/li&gt;
          &lt;li&gt;Avoidance에선 P2 → R1 → P1&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;그래프에 점선이 없음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Algorithm
    &lt;ul&gt;
      &lt;li&gt;Wait-for graph에 사이클이 존재하는지를 주기적으로 조사함 O(n2)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img width=&quot;458&quot; alt=&quot;스크린샷 2022-04-03 오후 8 05 13&quot; src=&quot;https://user-images.githubusercontent.com/56028408/161425744-b3764fa2-5213-4e4e-8254-a41d87ad2cf2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;⚠️  Graph에 Cycle이 존재할 경우 Deadlock Detection ⚠️&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;2️⃣-multiple-instance인-경우에-사용되는-알고리즘&quot;&gt;2️⃣  Multiple instance인 경우에 사용되는 알고리즘&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Banker’s Algorithm&lt;/strong&gt; 과 비슷하지만 최대 요청가능한 자산을 예측하지 않고 Allocation, Request, Available 만 관리한다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;img width=&quot;398&quot; alt=&quot;스크린샷 2022-04-03 오후 8 11 22&quot; src=&quot;https://user-images.githubusercontent.com/56028408/161425742-92f20077-6814-48c3-ac8b-3ab0da0981a5.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사용중인 자원을 해제한다는 가정하에 가용자원으로 safe sequence를 확인해보면 &amp;lt;P0, P2, P3, P1, P4&amp;gt; 와 같은 순서가 나타난다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;🌟 Request는 추가요청가능량이 아니라 현재 실제로 요청한 자원량을 나타낸다 🌟&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;✔️ Recovery&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Process termination
    &lt;ul&gt;
      &lt;li&gt;Deadlock에 연루된 모든 프로세스를 Abork 한다.&lt;/li&gt;
      &lt;li&gt;Deadlock에 연루된 프로세스를 하나씩 Abork 해보고 해결되는 지 확인한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Resource Preemption
    &lt;ul&gt;
      &lt;li&gt;Deadlock에 연루된 프로세스 중에 비용을 최소화할 victim을 선점하여 자원을 뺏는다.&lt;/li&gt;
      &lt;li&gt;Safe State로 Rollback하여 Process를 재시작한다.&lt;/li&gt;
      &lt;li&gt;Stavation 문제 발생 위험
        &lt;ul&gt;
          &lt;li&gt;동일한 프로세스가 계속해서 victim으로 선점되는 경우
            &lt;ul&gt;
              &lt;li&gt;cost factor에 Rollback횟수도 고려한다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;34deadlock-ignorance&quot;&gt;3.4 Deadlock Ignorance&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Deadlock이 일어나지 않는다고 생각하고 아무런 조치도 취하지 않는 방법으로 대부분의 범용 OS가 채택한 방법이다.&lt;/p&gt;

  &lt;blockquote&gt;
    &lt;p&gt;Deadlock은 매우 드물게 발생하므로 deadlock에 대한 조치 자체가 더 큰 overhead일 수 있다&lt;/p&gt;

    &lt;p&gt;만약, 시스템에 deadlock이 발생한 경우 시스템이 비정상적으로 작동하는 것을 사용자가 느낀 후 직접 process를 죽이는 방법 등으로 대처한다.&lt;/p&gt;

  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;reference&quot;&gt;&lt;strong&gt;Reference&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;이화여자대학교 반효경 교수님 운영체제 강의&lt;/p&gt;</content><author><name></name></author><category term="반효경" /><category term="데드락" /><category term="운영체제" /><category term="데드락 발생 4가지 조건" /><summary type="html">🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟</summary></entry><entry><title type="html">[운영체제 스터디] 프로세스 동기화 문제 3가지 해결방법과 세마포어 뮤텍스 차이</title><link href="http://localhost:4000/os/2022/04/02/os-study-07.html" rel="alternate" type="text/html" title="[운영체제 스터디] 프로세스 동기화 문제 3가지 해결방법과 세마포어 뮤텍스 차이" /><published>2022-04-02T00:00:00+09:00</published><updated>2022-04-02T00:00:00+09:00</updated><id>http://localhost:4000/os/2022/04/02/os-study-07</id><content type="html" xml:base="http://localhost:4000/os/2022/04/02/os-study-07.html">&lt;p&gt;🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟&lt;/p&gt;

&lt;h1 id=&quot;process-synchronizationconcurrency&quot;&gt;Process Synchronization(Concurrency)&lt;/h1&gt;
&lt;h3 id=&quot;️-프로세스-동기화와-관련된-3가지-문제&quot;&gt;‼️  프로세스 동기화와 관련된 3가지 문제&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Bounded-Buffer Problem&lt;/li&gt;
  &lt;li&gt;Readers and Writers Problem&lt;/li&gt;
  &lt;li&gt;Dining-Philosophers Problem&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;1-bounded-buffer-problem-producer-consumer-problem&quot;&gt;1. Bounded-Buffer Problem (Producer-Consumer Problem)&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Bounded-Buffer Problem란 생산자와 사용자의 비율이 맞지않아서 사용자나 생산자가 무한히 대기하거나, 공유데이터에 동시에 접근하여 데이터 통일성이 깨질 수 있는 문제점을 얘기한다.&lt;/p&gt;

  &lt;p&gt;아래 내용은 이러한 문제점을 세마포어로 해결한 예시이다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;img width=&quot;509&quot; alt=&quot;스크린샷 2022-03-28 오후 8 48 56&quot; src=&quot;https://user-images.githubusercontent.com/56028408/160510432-4cd492fe-4ddf-4088-80a3-6dc21e8ba5c4.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;11-bounded-buffer의-문제점-해결-방안&quot;&gt;1.1 Bounded-Buffer의 문제점 해결 방안&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;✔️ Producer - 데이터를 버퍼에 채워넣는 역할&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;비어있는 버퍼가 있는 지 확인한다. (없을 경우 대기)&lt;/li&gt;
  &lt;li&gt;비어있는 버퍼가 있으면 공유데이터에 접근하고 lock을 건다.&lt;/li&gt;
  &lt;li&gt;비어있는 버퍼에 데이터 입력 및 버퍼를 조작한다&lt;/li&gt;
  &lt;li&gt;Lock을 해제한다.&lt;/li&gt;
  &lt;li&gt;Full Buffer를 하나 증가시킨다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;✔️ Consumer - 데이터를 사용하는 역할&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;full 버퍼가 있는 지 확인한다. (없으면 대기)&lt;/li&gt;
  &lt;li&gt;full 버퍼가 있을 경우 공유데이터에 접근하고 lock을 건다.&lt;/li&gt;
  &lt;li&gt;full 버퍼에서 데이터를 읽어오고 버퍼를 조작한다.&lt;/li&gt;
  &lt;li&gt;Lock을 해제한다.&lt;/li&gt;
  &lt;li&gt;Empty Buffer를 하나 증가시킨다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;‼️  &lt;strong&gt;여기서 말하는 공유데이터는&lt;/strong&gt; ‼️&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Buffer 자체 및 Buffer 조작 변수(empty/full buffer의 시작 위치)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;12-세마포어를-적용한-동기화-기법-예제코드&quot;&gt;1.2 세마포어를 적용한 동기화 기법 예제코드&lt;/h3&gt;

&lt;p&gt; &lt;strong&gt;Producer&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Consumer&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;produce&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;an&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; 
	&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 비어있는 버퍼의 수 확인 */&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 버퍼가 비어있으면 버퍼에 진입하고 lock */&lt;/span&gt; 
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 버퍼 unlock */&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;full&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;cm&quot;&gt;/* full 자원을 증가시킴 */&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;full&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 비어있지않은 버퍼의 수 확인 */&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 버퍼가 하나라도 비어있지 않으면 버퍼에 진입하고 lock */&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;remove&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;an&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 버퍼 unlock */&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 비어있는 버퍼의 갯수 증가 */&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;consume&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;✔️ &lt;strong&gt;Synchrozination variables&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;semaphore empty = n; semaphore full = 0;
    &lt;ul&gt;
      &lt;li&gt;남은 full/empty의 buffer의 수 표시&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;semaphore mutex = 1;
    &lt;ul&gt;
      &lt;li&gt;공유 데이터의 상호배제를 위한 변수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-readers-and-writers-problem&quot;&gt;2. Readers and Writers Problem&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;다수의 Readers Writer가 공용 데이터베이스에 접근하여 데이터 일관성을 해치는 문제점을 말한다. 이는 프로세스 동기화 기법으로 해결할 수 있다.&lt;/p&gt;

  &lt;p&gt;아래 내용은 프로세스 동기화 기법을 사용하여 해결한 예시이다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56028408/160510449-35f712bd-9ed8-44eb-8425-ae22d07628e9.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;21-readers-and-writers-문제점-해결-방안&quot;&gt;2.1 Readers and Writers 문제점 해결 방안&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;✔️ Reader &amp;amp; Writer&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Reader는 데이터를 읽기만 하는 프로세스&lt;/li&gt;
  &lt;li&gt;Writer는 데이터를 읽고 수정하는 프로세스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;✔️ Reader &amp;amp; Writer Problem 방지&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;한 Writer가 임계구역에 진입한 상황일 때는 다른 프로세스가 임계구역에 접근하게 해선 안된다.
    &lt;ul&gt;
      &lt;li&gt;일단 Writer가 공유데이터에 접근 중이면 다른 Writer나 Reader들은 접근이 금지된다.&lt;/li&gt;
      &lt;li&gt;Writer가 공유데이터에서 빠져나가야만 Reader의 접근이 허용된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Reader는 여럿이 임계구역에 접근해도 된다. 하지만 Reader가 접근 중일 때 Writer가 접근하게 해선 안된다.
    &lt;ul&gt;
      &lt;li&gt;Writer는 대기 중인 Reader가 하나도 없을 때 공유데이터 접근이 허용된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Writer가 공유데이터에 접근 허가를 아직 얻지 못한 상태에서는 모든 대기중인 Reader들을 다 임계구역에 접근하게 해준다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;22-세마포어를-적용한-동기화-기법-예제코드&quot;&gt;2.2 세마포어를 적용한 동기화 기법 예제코드&lt;/h3&gt;

&lt;p&gt;✔️  &lt;strong&gt;Shared data&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;int readcount = 0&lt;/li&gt;
  &lt;li&gt;DB 자체&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;✔️ Synchronization variables&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;semaphore mutex = 1;&lt;/li&gt;
  &lt;li&gt;semaphore db = 1;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Writer&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Reader&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;writing&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DB&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;performed&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 동시에 다른 reader가 readcount를 변경하는 문제가 발생하지 않도록 lock */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;readcount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readcount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 최초의 접근일 경우 writer가 접근 못하도록 db 봉쇄 */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* readcount unlock */&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;‼️  하지만 위 코드와 같은 해결방법은 stavation 발생 위험이 있음&lt;/strong&gt; ‼️ &lt;/p&gt;

&lt;p&gt;예를 들어 writer가 대기 중일 때 reader가 끈임없이 진입하게 되면 wrtier가 무한히 대기하게 되는 현상이 발생한다.&lt;/p&gt;

&lt;p&gt;단순한 프로세스 동기화 예제일 뿐 최적의 해결방법이 아니기 때문에 참고만 하자.&lt;/p&gt;

&lt;h2 id=&quot;3-dining-philosophers-problem-식사하는-철학자-문제&quot;&gt;3. Dining-Philosophers Problem (식사하는 철학자 문제)&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;하나 이상의 프로세스가 공유데이터 중 서로에게 필요한 자원을 하나씩만 가지고 양보하지 않아서 Deadlock 이 발생할 수 있는 문제&lt;/p&gt;

  &lt;p&gt;아래 예제를 참고하여 어떤한 경우에 문제가 발생하는지 알아보고 어떻게 해결하는지 알아보자&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;문제-발생-예제-코드&quot;&gt;&lt;strong&gt;[문제 발생 예제 코드]&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;✔️ Synchronization variables&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;semaphore chopstick[5]
    &lt;ul&gt;
      &lt;li&gt;배열의 모든 값을 1로 초기화 했다고 가정한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Philosopher i&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chopstick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chopstick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;eat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chopstick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chopstick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;think&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/56028408/160510437-ee36b87b-a22f-4ae4-bd0c-342c1d9630f9.png&quot; alt=&quot;스크린샷 2022-03-29 오전 9 25 43&quot; /&gt;&lt;/p&gt;

&lt;p&gt;✔️  위 예제 코드의 문제점&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;모든 철학자가 동시에 배가 고파져 왼쪽 젓가락을 집어버린 경우 아무도 먹지 못하는 문제가 발생한다.&lt;/li&gt;
  &lt;li&gt;Deadlock 발생 위험이 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;해결방안-예제-코드&quot;&gt;&lt;strong&gt;[해결방안 예제 코드]&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;✔️ &lt;strong&gt;Synchronization variables&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;enum {thinking, hungry, eating} state[5];&lt;/li&gt;
  &lt;li&gt;semaphore self[5] = 0;&lt;/li&gt;
  &lt;li&gt;semaphore mutex = 1;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Philosopher i&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/* 실행메소드 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;pickup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;eat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;putdown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;think&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pickup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hungry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pickdown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thinking&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/* 대상 철학자의 오른쪽과 왼쪽 철학자가 식사중인지 검사하고 대상 철학자가 배고픈 상태일 때 식사를 허용한다. */&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eating&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hungry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eating&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eating&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;		
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;✔️ 해결 방안&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;4명의 철학자만이 테이블에 동시에 앉을 수 있도록 한다&lt;/li&gt;
  &lt;li&gt;젓가락을 두 개 모두 잡을 수 있을 때에만 젓가락을 집을 수 있게 한다&lt;/li&gt;
  &lt;li&gt;비대칭
    &lt;ul&gt;
      &lt;li&gt;짝수(홀수) 철학자는 왼쪽(오른쪽) 젓가락부터 집도록&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;️-여태까지의-예제코드를-살펴봤을-때-semaphore의-문제점-️&quot;&gt;‼️  여태까지의 예제코드를 살펴봤을 때 Semaphore의 문제점 ‼️&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;코딩하기 힘들다&lt;/li&gt;
  &lt;li&gt;정확성(correctness)의 입증이 어렵다&lt;/li&gt;
  &lt;li&gt;자발적 협력(voluntary cooperation)이 필요하다&lt;/li&gt;
  &lt;li&gt;한번의 실수가 모든 시스템에 치명적 영향을 끼친다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;💡 예시 1번&lt;/p&gt;

&lt;p&gt;💡 예시 2번&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Critical&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Section&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Critical&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Section&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;[예시 1번]&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Wait 시점과 Signal 시점이 반대가 되어 Mutual Exclusion이 깨진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;[예시 2번]&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;자원을 해제하는 코드가 없기 때문에 서로 필요한 자원을 얻지 못하여 Deadlock 발생 위험이 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-monitor&quot;&gt;4. Monitor&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;동시에 수행중인 프로세스 사이에서 추상 데이터 타입의 안전한 공유를 보장하기 위한 high-level synchronization construct이다. 기본적으로 Monitor는 여러 프로세스가 동시적으로 접근할 수 없기 때문에 lock, unlock이 필요없다. 이는 프로그래머가 동기화 제약 조건을 명시적으로 코딩할 필요가 사라지기 때문에 프로그래머의 부담이 줄어든다고 할 수 있다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;✔️ Monitor&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;모니터 내에서는 한번에 하나의 프로세스만이 활동 가능&lt;/li&gt;
  &lt;li&gt;프로세스가 모니터를 사용하다가 타이머 인터럽트가 발생하여도 다른 프로세스가 모니터에 접근하지 못한다. active한 프로세스가 0이 되거나 프로세스가 모니터 내부에서 잠들었을 때 다른 프로세스가 진입한다.&lt;/li&gt;
  &lt;li&gt;프로세스가 모니터 안에서 기다릴 수 있도록 하기 위해 condition variable 사용&lt;/li&gt;
  &lt;li&gt;condition x;
    &lt;ul&gt;
      &lt;li&gt;condition value는 값을 가지지 않고 자신의 큐에 프로세스를 sleep 시키거나 깨우는 역할만 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;condition variable은 wait과 signal 연산에 의해서만 접근 가능
    &lt;ul&gt;
      &lt;li&gt;x.wait();
        &lt;ul&gt;
          &lt;li&gt;x.wait()을 invoke한 프로세스는 다른 프로세스가 x.signal()을 invoke하기 전까지 suspend된다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;x.signal();
        &lt;ul&gt;
          &lt;li&gt;x.signal()은 정확하게 하나의 suspend된 프로세스를 resume한다. suspend된 프로세스가 없으면 아무 일도 일어나지 않는다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;41-모니터를-활용한-bounded-buffer-problem-문제-해결-방법&quot;&gt;4.1 모니터를 활용한 Bounded-Buffer Problem 문제 해결 방법&lt;/h3&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;monitor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bounded_buffer&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;full&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;produce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 1&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 2&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
			&lt;span class=&quot;cm&quot;&gt;/* add x to empty buffer*/&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;full&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 3&lt;/span&gt;
		
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;consume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 1&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;full&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;// 2&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; 
			&lt;span class=&quot;cm&quot;&gt;/* remove an item from buffer an store it to */&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// 3&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;앞에 소개한 Bounded-Buffer 문제를 모니터로 변경한 소스코드이다. 모니터는 한 프로세스만 접근할 수 있으므로&lt;/p&gt;

&lt;p&gt;세마포어처럼 공유변수에 lock/unlock 작업을 수행하지 않아도 된다.&lt;/p&gt;

&lt;p&gt;✔️  &lt;strong&gt;produce(int x)&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;빈 버퍼가 있는 지 확인한다.&lt;/li&gt;
  &lt;li&gt;빈 버퍼가 없으면 empty큐에서 대기한다.&lt;/li&gt;
  &lt;li&gt;빈 버퍼가 있으면 버퍼에 데이터를 추가하고 full큐에 잠들어있는 프로세스 하나를 깨운다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;✔️  &lt;strong&gt;consume(int *x)&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;버퍼에 데이터가 있는 지 확인한다.&lt;/li&gt;
  &lt;li&gt;버퍼에 데이터가 없으면 full큐에 대기한다.&lt;/li&gt;
  &lt;li&gt;데이터가 있을 경우 버퍼에서 데이터 하나를 읽어오고 empty큐에 잠들어있는 프로세스 하나를 깨운다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;reference&quot;&gt;&lt;strong&gt;Reference&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&quot;https://mangkyu.tistory.com/104&quot;&gt;https://mangkyu.tistory.com/104&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이화여자대학교 반효경 교수님 운영체제 강의&lt;/p&gt;</content><author><name></name></author><category term="반효경" /><category term="식사하는 철학자" /><category term="모니터" /><category term="세마포어" /><category term="뮤텍스" /><summary type="html">🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟</summary></entry><entry><title type="html">[운영체제 스터디] 프로세스 동기화 조건 3가지와 뮤텍스 세마포어</title><link href="http://localhost:4000/os/2022/03/28/os-study-06.html" rel="alternate" type="text/html" title="[운영체제 스터디] 프로세스 동기화 조건 3가지와 뮤텍스 세마포어" /><published>2022-03-28T00:00:00+09:00</published><updated>2022-03-28T00:00:00+09:00</updated><id>http://localhost:4000/os/2022/03/28/os-study-06</id><content type="html" xml:base="http://localhost:4000/os/2022/03/28/os-study-06.html">&lt;p&gt;🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟&lt;/p&gt;

&lt;h2 id=&quot;1-프로세스-동기화-프로그램적-해결법의-충족-조건&quot;&gt;1. 프로세스 동기화 프로그램적 해결법의 충족 조건&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;프로세스가 임계구역에 동시에 접근하는 것을 방지하고 데이터 일관성을 유지하려면 아래 세가지 조건을 충족해야한다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;✔️ Mutual Exclustion&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스 Pi가 Critical Section 부분을 수행 중이면 다른 모든 프로세스들은 그들의 Critical Section에 접근하면 안된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✔️ Progress&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Critical Section에 접근한 프로세스가 없는 상황에서 Critical Section에 접근하고자 하는 프로세스가 있으면 Critical Section에 접근하게 해야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✔️ Bounded Waiting&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스가 Critical Section에 들어가려고 요청한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 Critical Section에 들어가는 횟수에는 한계가 있어야 한다. (기다리는 시간이 유한 해야함)
    &lt;ul&gt;
      &lt;li&gt;기아현상 방지&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;‼️  &lt;strong&gt;예제 알고리즘으로 위 세가지 조건에 만족할 수 있는 방법이 무엇인지 알아보자&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;💡  실습 가정 !&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;모든 프로세스 수행 속도는 0보다 크다&lt;/li&gt;
  &lt;li&gt;프로세스들 간의 상대적인 수행 속도는 가정하지 않는다&lt;/li&gt;
  &lt;li&gt;예제 알고리즘은  두개의 프로세스가 있다고 가정한다 (P1, P2)&lt;/li&gt;
  &lt;li&gt;프로세스들은 수행의 동기화를 위해 몇몇 변수를 공유할 수 있다 (Synchronization variable)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-algorithm---1&quot;&gt;2. Algorithm - 1&lt;/h2&gt;

&lt;h3 id=&quot;변수-초기화&quot;&gt;[변수 초기화]&lt;/h3&gt;

&lt;p&gt;✔️ Synchronization variable&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;int turn; →  프로세스가 임계구역에 들어갈 수 있는 조건인지 확인하는 변수&lt;/li&gt;
  &lt;li&gt;initially turn = 1; →  첫 진입을 P1에게 허용하기 위해 1로 초기화 함&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;구현-코드&quot;&gt;[구현 코드]&lt;/h3&gt;

&lt;p&gt;✔️ Process P1 구현 코드&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* P1가 접근 가능한 상황이 될 때까지 while */&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;critical&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;  &lt;span class=&quot;cm&quot;&gt;/* 임계구역 */&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;****&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;****=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;         &lt;span class=&quot;cm&quot;&gt;/* 프로세스 P2(이)가 접근할 수 있게 값 변경*/&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;remainder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;✔️ Process P2 구현 코드&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* P2가 접근 가능한 상황이 될 때까지 while */&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;critical&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;  &lt;span class=&quot;cm&quot;&gt;/* 임계구역 */&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;****&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;****=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;         &lt;span class=&quot;cm&quot;&gt;/* 프로세스 P1(이)가 접근할 수 있게 값 변경 */&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;remainder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;💡  Algorithm - 1 은 Mutual Exclustion 을 만족하지만 Progress 조건은 만족하지 못한다. 💡&lt;/strong&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Algorithm - 1&lt;/strong&gt; 을 예로 들면 반드시 교대로 임계구역에 들어갈 수 있게 설계되어있기 때문에 P1이 임계구역 접근에 시도를 하지않을 경우 turn의 값은 영원히 바뀌지 않는다. turn이 변경되지 않을 경우 P2이 입계구역에 접근하려고 해도 접근할 수 없게 된다. 또한 임계구역 접근 빈도가 서로 다를 경우에도 문제가 발생할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;3-algorithm---2&quot;&gt;3. Algorithm - 2&lt;/h2&gt;

&lt;h3 id=&quot;변수-초기화-1&quot;&gt;[변수 초기화]&lt;/h3&gt;

&lt;p&gt;✔️ Synchronization variable&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;boolean falg[2];&lt;/li&gt;
  &lt;li&gt;initially flag[모두] = false; /* no one is in CS */&lt;/li&gt;
  &lt;li&gt;프로세스가 임계구역에 접근할 준비가 되면 (flag[i] == true)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;구현코드&quot;&gt;[구현코드]&lt;/h3&gt;

&lt;p&gt;✔️ Process P1 구현 코드&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 임계구역에 들어갈 준비가 되었다 */&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* P2가 임계구역에 접근한 상태인지? 접근했다면 P1은 대기 */&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;critical&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;  &lt;span class=&quot;cm&quot;&gt;/* 임계구역 */&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;remainder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;✔️ Process P2 구현 코드&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 임계구역에 들어갈 준비가 되었다 */&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* P1가 임계구역에 접근한 상태인지? 접근했다면 P2은 대기 */&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;critical&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 임계구역 */&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;remainder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;💡  Algorithm - 2 은 Mutual Exclustion 을 만족하지만 Progress 조건은 만족하지 못한다. 💡&lt;/strong&gt; &lt;/p&gt;

&lt;p&gt;P1과 P2가 둘 다 임계구역에 접근하려고 값을 true로 변경했을 경우 2행까지 수행 후 끊임 없이 양보하는 상황이 발생할 수 있다. 이럴 경우 P1, P2 두 프로세스가 전부 임계구역에 접근하지 못하는 상황이 발생하기 때문에 &lt;strong&gt;Progress&lt;/strong&gt; 조건을 만족하지 못한다.&lt;/p&gt;

&lt;h2 id=&quot;4-algorithm---3-petersons-algorithm&quot;&gt;4. Algorithm - 3 (Peterson’s Algorithm)&lt;/h2&gt;

&lt;h3 id=&quot;변수-초기화-2&quot;&gt;[변수 초기화]&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Combined syschronization variables of algorithms 1 and 2
    &lt;ul&gt;
      &lt;li&gt;Peterson’s Algorithm은 Algorithm - 1 , Algorithm - 2 에서 사용했던 모든 변수를 사용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;구현코드-1&quot;&gt;[구현코드]&lt;/h3&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* My intention is to enter */&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;       &lt;span class=&quot;cm&quot;&gt;/* Set to his turn */&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;turn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* wait only if */&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;critical&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 임계구역 */&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;remainder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;💡 Algorithm - 3는 프로세스 동기화의 세가지 요구사항을 모두 만족한다. 💡&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;피터슨의 알고리즘은 다른 프로세스가 임계구역에 접근한 상황인지와 다른 프로세스의 임계구역 접근 차례를 모두 검사하고 접근을 시도하기 때문에 세가지 요구사항을 모두 만족한다.&lt;/p&gt;

&lt;p&gt;‼️  &lt;strong&gt;Algorithm - 3 의 문제점 → Busy Waiting(=spin lock)! (계속 CPU와 memory를 쓰면서 wait)&lt;/strong&gt; ‼️&lt;/p&gt;

&lt;p&gt;만약 한 프로세스가 임계구역에 접근한 상황에서 다른 프로세스가 CPU를 할당받을 경우 while 조건에 충족하기 때문에 다른 작업은 수행하지 못하고 CPU를 빼앗길 때까지 while을 반복하게 된다. (의미없이 CPU 수행시간을 낭비하게 됨)&lt;/p&gt;

&lt;h2 id=&quot;5-synchronization-hardware&quot;&gt;5. Synchronization Hardware&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;프로세스 동기화 문제는 소프트웨어가 Input과 Output을 하나의 인스트럭션으로 진행할 수 없어서 생긴 문제점이다. 이러한 문제점을 하드웨어적으로 test &amp;amp; modify를 atomic하게 수행할 수 있도록 지원하면 앞의 문제는 간단히 해결된다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;✔️ Counting semaphore (세마포어)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;도메인이 0 이상인 임의의 정수값&lt;/li&gt;
  &lt;li&gt;자원의 갯수가 여러개인 경우&lt;/li&gt;
  &lt;li&gt;주로 resource counting에 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✔️ Binary semaphore (=mutex)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;0 또는 1 값만 가질 수 있는 세마포어
    &lt;ul&gt;
      &lt;li&gt;자원의 갯수가 하나인 경우&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;주로 mutual exclusion (lock/unlock)에 사용 (=mutex)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;51-mutex&quot;&gt;5.1 Mutex&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Mutex는 Mutual Exclustion의 약자이고 상호배재 한다는 뜻으로 사용된다. Mutex는 Locking 매커니즘으로 오직 하나의 쓰레드만이 동일한 시점에 뮤텍스를 얻어 임계 영역에 들어올 수 있고 오직 이 쓰레드만이 임계 영역에서 나갈 때 뮤텍스를 해제할 수 있다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;52-mutual-exclustion-with-test--set&quot;&gt;5.2 Mutual Exclustion with Test &amp;amp; Set&lt;/h3&gt;

&lt;h3 id=&quot;변수-초기화-3&quot;&gt;[변수 초기화]&lt;/h3&gt;

&lt;p&gt;✔️ Synchronization variable&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;boolean lock = false;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;구현코드-2&quot;&gt;[구현코드]&lt;/h3&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Test_and_Set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;critical&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;remainder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;section&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;💡 &lt;strong&gt;Test_and_set()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;파라미터 변수의 값을 읽고, TRUE로 변경작업을 수행한다. 이전 알고리즘 1,2,3은 값을 읽고 변경하는 작업을 따로따로 진행했다면, &lt;strong&gt;Test_and_set()&lt;/strong&gt;은 값을 읽고 변경하는 작업을 하나의 인터럭션으로 수행하므로 조금 더 간결하게 해결할 수 있도록 도와준다.&lt;/p&gt;

&lt;h2 id=&quot;6-semaphores&quot;&gt;6. Semaphores&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;세마포어란 임계구역에 진입하기 어려울 때 프로세스가 자발적으로 대기 상태로 들어가는 방식이다. 세마포어는 앞의 방식들을 추상화 시킨 방식이다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;❓ 세마포어&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;block/wakeup 알고리즘&lt;/li&gt;
  &lt;li&gt;진입 불가능 시에는 대기상태로 전환&lt;/li&gt;
  &lt;li&gt;임계구역을 떠나는 프로세스가 대기 프로세스를 준비 상태로 깨워줌&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;❓ 세마포어 구성&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;하나의 정수값 (정수변수 value)&lt;/li&gt;
  &lt;li&gt;프로세스 대기 큐&lt;/li&gt;
  &lt;li&gt;정수에 대한 3가지 연산 : init, wait, signal
    &lt;ul&gt;
      &lt;li&gt;wait 은 P 연산이라고도 불린다.&lt;/li&gt;
      &lt;li&gt;signal 은 V 연산이라고도 불린다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;✔️ Semaphore 객체를 S 라 할 때&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;S.value: 자원 활용 현황
    &lt;ul&gt;
      &lt;li&gt;양수: 남아있는 자원의 수&lt;/li&gt;
      &lt;li&gt;음수: 부족하여 대기하고 있는 대기자 수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;S.value의 초기값 n : 자원의 개수&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;아래의 두 가지 atomic 연산에 의해서만 자원에 접근 가능하다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;op&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*wait*/&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 자원 반납 */&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;세마포어의 모든 오퍼레이션은 atomic하게 실행되어야 한다. wait 연산을 하는 동안 signal 연산을 하거나, 또는 그 반대의 경우 모두 발생해서는 안된다. 이를 보장하기 위해 각 연산이 실행되는 동안 인터럽트를 disable 시킴으로써 해결할 수 있다. 만약 다중 CPU 환경이라면 모든 CPU의 인터럽트를 disable 시켜야 한다. 헌데 모든 인터럽트를 디스에이블 할 경우 성능이 저하될 수 있기 때문에 compare_and_swap()을 사용하거나 spinlock 과 같은 busy waiting 기법을 사용하기도 한다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;61-block--wakeup-inmplementation&quot;&gt;6.1 Block &amp;amp; Wakeup Inmplementation&lt;/h2&gt;

&lt;p&gt;✔️ Busy-wait 과 Block/wakeup&lt;/p&gt;

&lt;p&gt;busy-wait과 block/wakeup 방식을 비교하자면 block/wakeup 방식을 사용하는 것이 효율적이다. busy-wait 방식은 자기 차례가 아니면 의미없이 CPU 시간을 낭비하는 반면에 block/wakeup 방식은 자기 차례가 아닐 경우 block 상태로 전환하기 때문이다.&lt;/p&gt;

&lt;p&gt;그런데 임계구역의 코드가 짧을 경우에는 block/wakeup 방식보다 busy-wait 방식이 더 효율적일 수 있다. ready 상태에서 block 상태로 전환하고 다시 block 상태에서 ready 상태로 전환하는 것에 오버헤드가 따르기 때문이다.&lt;/p&gt;

&lt;p&gt;정리하자면 임계구역이 짧을 경우에는 busy-wait 방식이 효율적이고 임계구역 코드가 길 경우에는 block/wakeup 방식이 효율적이다.&lt;/p&gt;

&lt;h2 id=&quot;7-deadlock&quot;&gt;7. Deadlock&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;둘 이상의 프로세스가 서로 원하는 리소스가 상대방에게 할당되어 있을 경우 무한히 대기하는 현상을 말한다. 보통 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생한다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;reference&quot;&gt;&lt;strong&gt;Reference&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&quot;https://mangkyu.tistory.com/104&quot;&gt;https://mangkyu.tistory.com/104&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이화여자대학교 반효경 교수님 운영체제 강의&lt;/p&gt;</content><author><name></name></author><category term="반효경" /><category term="교착상태" /><category term="프로세스 동기화" /><category term="세마포어" /><category term="뮤텍스" /><summary type="html">🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟</summary></entry></feed>