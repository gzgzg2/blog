<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-06-27T18:09:06+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Your awesome title</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><author><name>GitHub User</name></author><entry><title type="html">[Java] synchronized</title><link href="http://localhost:4000/java/2022/06/26/java-syncronized.html" rel="alternate" type="text/html" title="[Java] synchronized" /><published>2022-06-26T00:00:00+09:00</published><updated>2022-06-26T00:00:00+09:00</updated><id>http://localhost:4000/java/2022/06/26/java-syncronized</id><content type="html" xml:base="http://localhost:4000/java/2022/06/26/java-syncronized.html"><![CDATA[<h1 id="java-synchronized">Java synchronized</h1>
<p>Java의 synchronized는 Thread간의 동기화 매커니즘이다. synchronized는 하나의 객체를 여러 스레드에서 동시에 사용하거나
static으로 선언한 객체를 여러 스레드에서 사용할 경우에 적용한다. 주의할 점은 synchronized는 객체 단위로 동작하기 때문에
한 객체에서 synchronized를 사용하는 여러개의 메서드가 있다면 해당 키워드가 적용된 메서드는 동시에 실행되지 않는다.
또한 내부에서 동기화를 위해 <a href="https://en.wikipedia.org/wiki/Monitor_(synchronization)"><strong>Monitor</strong></a>를 사용하고 있으므로 성능저하 문제가 발생할 수 있다.</p>

<h2 id="monitor">Monitor</h2>
<p>모니터란 동시에 수행중인 프로세스나 스레드 사이에서 동기화를 적용하기 위한 <strong>high-level synchronization construct</strong> 이다.
모니터는 하나의 <strong>lock</strong>과 여러개의 <strong>condition variable</strong>로 이루어져있다. 모니터 내에서는 한번에 하나의 프로세스나 스레드만이 활동이 가능하므로
프로세스나 스레드가 모니터를 사용하다가 봉쇄상태로 변경되어도 다른 프로세스가 모니터에 접근하지 못한다.</p>

<h2 id="java-monitor">Java Monitor</h2>
<blockquote>
  <p><strong>📌 모니터는 synchronized를 사용했을 때 이용된다.</strong></p>
</blockquote>

<p>Java의 모든 객체는 Monitor를 보유하고 있다. 객체는 heap 영역에 존재하므로 모든 스레드에서 공유가 가능하기 때문에 Monitor는 객체에 한번에 하나의 스레드만 접근할 수 있도록 막는다. 
그리고 객체는 모니터가 할당되지 않은 상태이면 호출된 스레드에게 모니터를 할당한다. 소유권을 갖게된 스레드는 모니터에 진입하게 된다. 모니터에 하나의 스레드가 진입하게 되면 다른 스레드는
모니터를 사용할 수 있을 때까지 대기하게 된다. 즉 오직 모니터를 소유한 스레드만이 임계구역에서 작업을 할 수 있는 것이다.</p>

<h2 id="1-공유객체에-접근할-때-synchronized를-사용하지-않았을-경우">1. 공유객체에 접근할 때 synchronized를 사용하지 않았을 경우</h2>

<h3 id="기부금을-처리하는-단체">기부금을 처리하는 단체</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Contribution</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">amount</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">donate</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">amount</span><span class="o">++;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getTotal</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">amount</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>단순하게 기부금 필드와 기부금을 축적하는 메서드만 보유하고 있는 클래스이다.</p>

<h3 id="기부자">기부자</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Contributor</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Contribution</span> <span class="n">contribution</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Contributor</span><span class="o">(</span><span class="nc">Contribution</span> <span class="n">contribution</span><span class="o">,</span> <span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">contribution</span> <span class="o">=</span> <span class="n">contribution</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">loop</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">loop</span><span class="o">&lt;</span><span class="mi">1000</span><span class="o">;</span> <span class="n">loop</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">contribution</span><span class="o">.</span><span class="na">donate</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"%s total=%d\n"</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">,</span> <span class="n">contribution</span><span class="o">.</span><span class="na">getTotal</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>1인당 1원씩 1000번 기부하고 기부가 완료되면 쌓인 기부금을 출력하는 클래스이다.</p>

<h3 id="실행-소스코드">실행 소스코드</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">App</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Contributor</span><span class="o">[]</span> <span class="n">contributors</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Contributor</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span>
        <span class="nc">Contribution</span> <span class="n">contribution</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Contribution</span><span class="o">();</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">loop</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">loop</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">loop</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">contributors</span><span class="o">[</span><span class="n">loop</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Contributor</span><span class="o">(</span><span class="n">contribution</span><span class="o">,</span> <span class="s">"Contributor"</span><span class="o">+</span><span class="n">loop</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">loop</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">loop</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">loop</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">contributors</span><span class="o">[</span><span class="n">loop</span><span class="o">].</span><span class="na">start</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>하나의 단체에 10명의 기부자가 1000원씩 기부하는 App 클래스이다.<br />
소스코드로 예상할 수 있는 결과의 최대값은 10,000 일 것이다. 결과를 확인해보자.</p>

<h3 id="결과">결과</h3>
<p><img src="https://user-images.githubusercontent.com/56028408/175819107-4f2f559c-e58e-4491-877b-eb90d68d0ff2.png" alt="스크린샷 2022-06-26 오후 11 27 55" /></p>

<p>결과는 우리가 예상한 값과 다르다. 물론 여러번 실행하면 10,000 이라는 값이 출력되기도 한다. 그렇지만 대부분 10,000이라는 값은 출력되지 않을 것이다.<br />
이러한 문제가 발생하는 이유는 여러개의 contributors 객체에서 하나의 contribution 객체의 donate() 메서드에 접근하기 때문이다. <br />
앞서 말했듯이 객체는 heap 영역에 생성되므로 모든 스레드가 접근할 수 있다. 모든 스레드가 동시에 공유영역에 접근할 수 있다는 것은 스레드 동기화 문제가 발생할 수 있다는 것과 같다.</p>

<h2 id="2-문제-해결-방법">2. 문제 해결 방법</h2>
<h3 id="synchronized">synchronized</h3>
<p>위와 같은 경우 문제 해결방법은 간단하다. <strong>donate()</strong> 메서드에 synchronized 를 사용하면 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">donate</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">amount</span><span class="o">++;</span>
    <span class="o">}</span>
</code></pre></div></div>

<h3 id="결과-1">결과</h3>
<p><img src="https://user-images.githubusercontent.com/56028408/175819627-034845b1-3155-40a4-b08a-c1c79bd09982.png" alt="스크린샷 2022-06-26 오후 11 39 14" /></p>

<p>synchronized 메서드를 추가하면 donamte() 메서드에 하나의 스레드만이 접근할 수 있게되므로 여러번 실행하여도 최대값은 10,000이 출력될 것이다.
하지만 이 예시는 간단한 예시이기 때문에 동기화가 필요한 메서드에 무조건 synchronized를 사용하는 방법은 옳지 않다.
메서드 내부에서 동기화가 필요하지 않은 라인도 동기화가 적용되어 성능에 큰 영향을 끼칠 수 있기 때문이다. 이번 게시물에서 소개하진 않았지만 인스턴스 메서드안에 동기화 블록을 적용하는 방법도 존재한다.</p>

<h2 id="결론">결론</h2>
<p>synchronized를 사용해야할 경우는 존재할 수 있다. 그렇지만 synchronized의 동작 방식을 모르는 상태로 사용하게 되면<br />
큰 성능이슈를 겪을 수 있다. 뿐만 아니라 클래스 변수는 인스턴스 메서드의 synchronized가 적용되지 않기 때문에 주의해서 사용해야 한다.</p>

<h1 id="reference">Reference</h1>
<h3 id="monitor-1">Monitor</h3>
<ul>
  <li><a href="https://gzgzg2.github.io/os/2022/04/02/os-study-07.html#4-monitor">https://gzgzg2.github.io/os/2022/04/02/os-study-07.html#4-monitor</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Monitor_(synchronization)">https://en.wikipedia.org/wiki/Monitor_(synchronization)</a></li>
  <li><a href="https://ssup2.github.io/programming/Java_Monitor_synchronized/">https://ssup2.github.io/programming/Java_Monitor_synchronized/</a></li>
</ul>

<h3 id="java-monitor-1">Java Monitor</h3>
<ul>
  <li><a href="https://ssup2.github.io/programming/Java_Monitor_synchronized/">https://ssup2.github.io/programming/Java_Monitor_synchronized/</a></li>
  <li><a href="https://www.artima.com/insidejvm/ed2/threadsynch.html">https://www.artima.com/insidejvm/ed2/threadsynch.html</a></li>
</ul>

<h3 id="java-synchronized-1">Java synchronized</h3>
<ul>
  <li>자바 성능 튜닝 이야기 :: story.8 synchronized는 제대로 알고 써야한다.</li>
</ul>]]></content><author><name>GitHub User</name></author><category term="Java" /><category term="Java" /><category term="monitor" /><category term="synchronized" /><category term="Thread" /><summary type="html"><![CDATA[Java synchronized Java의 synchronized는 Thread간의 동기화 매커니즘이다. synchronized는 하나의 객체를 여러 스레드에서 동시에 사용하거나 static으로 선언한 객체를 여러 스레드에서 사용할 경우에 적용한다. 주의할 점은 synchronized는 객체 단위로 동작하기 때문에 한 객체에서 synchronized를 사용하는 여러개의 메서드가 있다면 해당 키워드가 적용된 메서드는 동시에 실행되지 않는다. 또한 내부에서 동기화를 위해 Monitor를 사용하고 있으므로 성능저하 문제가 발생할 수 있다.]]></summary></entry><entry><title type="html">[Java] Getter Setter 필요없을까?</title><link href="http://localhost:4000/java/2022/06/12/no-getter-setter.html" rel="alternate" type="text/html" title="[Java] Getter Setter 필요없을까?" /><published>2022-06-12T00:00:00+09:00</published><updated>2022-06-26T00:00:00+09:00</updated><id>http://localhost:4000/java/2022/06/12/no-getter-setter</id><content type="html" xml:base="http://localhost:4000/java/2022/06/12/no-getter-setter.html"><![CDATA[<h2 id="들어가며">들어가며</h2>
<p>이전에 무지성으로 남발하여 주로 사용하였던 Getter Setter가 객체지향 세계에선 아주 지양해야할 패턴이라는 것을 알게 되었다.<br />
Getter Setter가 존재하는 이상 그 클래스는 능도적인 객체가 아닌 자료구조에 불과하다고 한다. 그런데 가끔 특정한 라이브러리에서 Getter Setter 를 필요로 하는 것을 느꼈다.<br />
물론 옵션을 설정할 수 있지만 주의해야 하는 것은 마찬가지이다. 그래서 이번에는 Getter Setter 에서 벗어나고 싶은데, 완전히 자유로워지기 힘든 이유를 정리하고자 한다.</p>

<h2 id="getter-setter-지양해야-하는-이유">Getter, Setter 지양해야 하는 이유</h2>
<p>자바 개발자라면 객제지향 프로그래밍의 4대 원칙을 한번쯤 들어봤을 것이다. 간단하게 소개하자면 아래와 같다.</p>

<h3 id="oop-4대-원칙"><strong>OOP 4대 원칙</strong></h3>
<p><strong>1. 추상화(Abstraction)</strong></p>
<ul>
  <li>구체적인 것을 <strong>분해</strong> 하여 <strong>재조립</strong> 하는 것</li>
</ul>

<p><strong>2. 상속(Inheritance)</strong></p>
<ul>
  <li><strong>상위 클래스</strong> 의 특성을 <strong>하위 클래스</strong> 가 물려받는 것</li>
</ul>

<p><strong>3. 캡슐화, 정보은닉 (Encapsulation)</strong></p>
<ul>
  <li>역할에 관련있는 객체의 속성과 실제 행위를 묶어 실제 구현 내용을 외부에 노출하지 않는 것</li>
</ul>

<p><strong>4. 다형성(Polymorphism)</strong></p>
<ul>
  <li>같은 형태를 가지고 있지만 다른 행위를 할 수 있음</li>
</ul>

<h3 id="1-캡슐화">1. 캡슐화</h3>
<p>Getter와 Setter의 경우 캡슐화를 위반한다. 객체가 무엇을 캡슐화 하고 있는지와 객체 내부의 복잡성은 오직 객체만이 알고 있어야 한다.<br />
그런데 Getter와 Setter는 외부에 객체의 데이터를 노출하게 만든다. 물론 필드에 직접 접근하는 것이 아닌 메서드를 이용하여 접근하는 것이지만 <br />
우리는 Getter가 데이터에 직접 접근하여 해당 필드의 데이터만을 반환할 것이라고 믿고있다.</p>

<p><br /></p>

<p>객체지향 세계에선 객체에게 특정한 행위를 요청했을 때, 외부에서는 객체가 어떠한 재료들로 무엇을 만드는지 알아선 안되고 알 필요도 없다.</p>

<h3 id="2-객체를-자료구조로-전락시킨다">2. 객체를 자료구조로 전락시킨다</h3>
<p>객체지향 세계에서의 객체는 살아있고 능동적이다. 그런데 Getter/Setter가 남발된 객체는 생명이 없다. 그저 데이터를 외부에 노출하는 단순 자료구조일 뿐이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//안 좋은 예시</span>
<span class="kd">class</span> <span class="nc">Cash</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">value</span><span class="o">;</span> 

  <span class="kd">public</span>  <span class="kt">int</span> <span class="nf">getDollars</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">value</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 좋은 예시</span>
<span class="kd">class</span> <span class="nc">Cash</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>

  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">dollars</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>차이는 메서드 이름밖에 없다고 생각할 수 있다. 그렇지만 메서드 이름에서 가져오는 뉘앙스는 완전히 다르다.<br />
앞에서 설명했듯 객체는 살아있고 능동적이다. 그런데 getDollars()는 객체에게 달러를 찾아 반환하라고 <strong>명령</strong> 한다.<br />
반면 dollars()의 경우 객체에게 얼마나 많은 달러가 필요한지 묻는다. 객체를 생명체로서 존중하고 있는 것이다.<br />
또한 dollars()는 객체가 요청을 듣고 반환할 때 외부에선 객체가 어떠한 재료와 행위로 값을 반환하는지 유추하기 힘들다.</p>

<h3 id="3-불변객체가-될-수-없다">3. 불변객체가 될 수 없다</h3>
<p><strong>Setter</strong>를 사용하면 누구나 객체의 값을 쉽게 수정할 수 있다. 이는 Setter가 존재하는 클래스는 불변객체가 될 수 없다는 의미이다.<br />
불변객체는 생성과 동시에 값을 초기화 하므로 개발자가 이후에 객체의 상태값을 변경할 수 없다. 값이 변하지 않으면 <strong>“식별자 가변성”</strong>  문제와 <strong>“부수효과”</strong> <strong>“시간적 결합”</strong> 문제에서 자유롭다. 뿐만 아니라 불변객체는 <strong>“실패 원자성”</strong> 의 장점이 있다. 그런데 <strong>Setter</strong>를 사용하게 되면 이러한 장점을 전부 누리기 어려워진다.</p>

<p><br />
객체의 값을 쉽게 수정할 수 있게 된다면 개발자의 실수로 의도하지 않았던 결과를 초래할 수 있다. 문제를 해결하기 위해 실수로 발생한 부수효과(side effect)를 제거하려면 값을 수정하는 코드를 전부 찾아서 디버깅 해야하기 때문에 많은 시간이 소요된다.</p>

<h2 id="getter-setter-없어도-아무런-문제가-없을까">Getter, Setter 없어도 아무런 문제가 없을까?</h2>
<p>앞에서 설명한 내용들을 보면 java beans pattern 은 정말 안티패턴 처럼 느껴진다. 나만 그럴수도,,?</p>

<p>여튼 그래서 실제로 업무를 진행하면서 Setter 뿐만 아니라 Getter도 생성하지 않고 개발했던 적이 있었다.  자주 사용하던 방법이 아니여서 익숙하진 않았지만 크게 불편함은 없었다. 그런데 .. 예상하지도 못했던 부분에서 문제가 발생하였다. ObjectMapper로 Json을 역직렬화 할 때 멤버변수를 찾지 못하여 실패하는 이슈가 발생한 것이었다.</p>

<h3 id="1-objectmapper">1. ObjectMapper</h3>
<p>ObjectMapper에서 JSON을 자바 객체로 역직렬화 할 때 getter, setter 메서드 이름의 “get”과 “set”을 제거하여 객체의 멤버변수를 찾는다. getter, setter 없이 다른 방법으로도 필드명을 알아낼 수 있지만 따로 옵션을 설정하거나 어노테이션을 지정해줘야 한다.</p>

<p><br /></p>

<p><strong>📌 @JsonProperty</strong></p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"dollars"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">100</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Cash</span> <span class="o">{</span>

  <span class="nd">@JsonProperty</span><span class="o">(</span><span class="s">"dollars"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">Integer</span> <span class="n">dollars</span><span class="o">;</span>

<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<p><strong>📌 ObjectMapper 설정 변경</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ObjectMapper</span> <span class="n">objectMapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectMapper</span><span class="o">();</span>
<span class="n">objectMapper</span><span class="o">.</span><span class="na">setVisibility</span><span class="o">(</span><span class="nc">PropertyAccessor</span><span class="o">.</span><span class="na">FIELD</span><span class="o">,</span> <span class="nc">JsonAutoDetect</span><span class="o">.</span><span class="na">Visibility</span><span class="o">.</span><span class="na">ANY</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="결론">결론</h3>
<p>Getter/Setter는 특별한 이유가 아니라면 지양하는 것이 맞다고 생각하지만, 자주 사용되는 라이브러리에서 ObjectMapper와 같이 Getter/Setter를 필요로 할 수 있기 때문에 주의하는 것이 좋을 것 같다.</p>

<p><br />
<br /></p>

<h1 id="reference">Reference</h1>
<p><a href="https://jenkov.com/tutorials/java-json/jackson-objectmapper.html#how-jackson-objectmapper-matches-json-fields-to-java-fields">https://jenkov.com/tutorials/java-json/jackson-objectmapper.html#how-jackson-objectmapper-matches-json-fields-to-java-fields</a></p>

<p><a href="https://bactoria.github.io/2019/08/16/ObjectMapper%EB%8A%94-Property%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%B0%BE%EC%9D%84%EA%B9%8C/">https://bactoria.github.io/2019/08/16/ObjectMapper%EB%8A%94-Property%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%B0%BE%EC%9D%84%EA%B9%8C/</a></p>]]></content><author><name>GitHub User</name></author><category term="Java" /><category term="Java" /><category term="Getter, Setter" /><category term="OOP" /><summary type="html"><![CDATA[들어가며 이전에 무지성으로 남발하여 주로 사용하였던 Getter Setter가 객체지향 세계에선 아주 지양해야할 패턴이라는 것을 알게 되었다. Getter Setter가 존재하는 이상 그 클래스는 능도적인 객체가 아닌 자료구조에 불과하다고 한다. 그런데 가끔 특정한 라이브러리에서 Getter Setter 를 필요로 하는 것을 느꼈다. 물론 옵션을 설정할 수 있지만 주의해야 하는 것은 마찬가지이다. 그래서 이번에는 Getter Setter 에서 벗어나고 싶은데, 완전히 자유로워지기 힘든 이유를 정리하고자 한다.]]></summary></entry><entry><title type="html">[네트워크 스터디] Chapter_04 엑세스 회선을 통해 인터넷의 내부로 !</title><link href="http://localhost:4000/networkstudy/2022/06/08/network-study-04.html" rel="alternate" type="text/html" title="[네트워크 스터디] Chapter_04 엑세스 회선을 통해 인터넷의 내부로 !" /><published>2022-06-08T00:00:00+09:00</published><updated>2022-06-08T00:00:00+09:00</updated><id>http://localhost:4000/networkstudy/2022/06/08/network-study-04</id><content type="html" xml:base="http://localhost:4000/networkstudy/2022/06/08/network-study-04.html"><![CDATA[<h2 id="adsl-기술을-이용한-엑세스-회선의-구조와-동작">ADSL 기술을 이용한 엑세스 회선의 구조와 동작</h2>

<h3 id="️-인터넷의-기본은-가정이나-회사의-lan과-같다"><strong>✔️  인터넷의 기본은 가정이나 회사의 LAN과 같다</strong></h3>

<ul>
  <li>인터넷은 거대하고 복잡한 시스템이지만 패킷을 중재하는 부분은 가정, 회사의 LAN과 동일하다.</li>
  <li>라우터의 기본적인 구조나 동작도 전혀 다르지 않다</li>
  <li>가정이나 회사의 네트워크 규모가 커진 것이 인터넷</li>
</ul>

<h3 id="️가정회사의-네트워크와-인터넷의-차이점"><strong>✔️ 가정, 회사의 네트워크와 인터넷의 차이점</strong></h3>

<ul>
  <li>인터넷은 중계 장치의 거리가 매우 멀다.</li>
  <li>대한민국과 미국을 연결하려면 태평양을 넘어야하기 때문에 이더넷 케이블로 연결은 어렵다.</li>
  <li>라우터의 등록정보가 수시로 바뀌기 때문에 경로 등록을 자동화 해야한다.
    <ul>
      <li>통신 장애가 발생하거나 인터넷에 새로 접속하는 회사가 있을 때마다 변경하는 것은 무리가 있음</li>
    </ul>
  </li>
  <li>요약하자면 거리의 차이와 경로 정보의 등록 방법 차이가 인터넷과 회사, 가정 LAN과의 차이</li>
</ul>

<h3 id="️사용자-인터넷을-연결하는-액세스-회선">✔️ 사용자 인터넷을 연결하는 액세스 회선</h3>

<ul>
  <li>인터넷 접속용 라우터는 액세스 회선의 규칙에 따라 패킷 송신 동작을 실행한다. (이더넷의 규칙과 다른 부분)</li>
  <li>일반 가정에선 ADSL, FTTH, CATV, ISDN 등을 액세스 회선으로 사용한다.</li>
</ul>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>💡 액세스 회선은 인터넷과 가정, 회사의 LAN을 연결하는 통신회선이다. 
💡 액세스 회선은 통신 회선의 사용법을 나타내므로 통신 회선의 원리나 구조를 나타내는 것이 아니다. 
</code></pre></div></div>

<h3 id="️adsl-모델에서의-패킷-신호화-과정">✔️ADSL 모델에서의 패킷 신호화 과정</h3>

<p>[<strong>ADSL 기술을 사용한 액세스 회선의 구성도]</strong></p>

<p><img src="https://user-images.githubusercontent.com/56028408/166886670-ba59b0f3-34a8-4980-9dfb-a1c4571b0ea3.png" alt="스크린샷 2022-05-04 오전 9 44 48" /></p>

<p>위 그림의 오른쪽에서 왼쪽으로 패킷이 흘러간다. 즉 사용자의 라우터에서 송신된 패킷은 ADSL 모뎀이나 전화의 케이블을 통해 전화국에 도착하며 도착한 패킷은 ADSL 사업자의 네트워크를 경유하여 프로바이더 (ISP: Internet Service Provider)에 도착하는데, 이때 패킷은 도착하는 동안 여러 형태로 모습을 바꾼다.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>💡 ADLS(Asymmetric Digital Subscriber)모델이란 전주에 부설된 전화용 금속제 케이블을 이용하여
  고속으로 통신하는 기술의 일종으로 사용자로부터 인터넷으로 향하는 상향(업로드)과 인터넷에서 사용자로 향하는 
  하향(다운로드)의 통신 속도가 서로 다른 것을 가리킵니다.
</code></pre></div></div>

<p><strong>[액세서 회선을 통한 패킷의 전송 과정]</strong></p>

<p><img src="https://user-images.githubusercontent.com/56028408/166886653-c4bdfeaa-6bda-43e8-945f-9dc54eb1ced5.png" alt="스크린샷 2022-05-04 오전 9 55 29" /></p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(1~4) 위 그림의 4번까지는 이더넷의 라우터와 큰 차이가 없음
(5) 인터넷 접속용 라우터와 **ADSL** 모뎀이 이더넷으로 연결되어 있으면 이더넷의 규칙에 따라 패킷을 송수신
(5) 이더넷의 헤더가 액세스 회선 사업자에따라 변형된다.
(5) MAC헤더 PPoE헤더 PPP헤더라는 3개의 헤더가 추가로 붙고 이더넷의 규칙따라 신호를 변환하여 송신한다
(6) 인터넷 접속용 라우터가 송신한 패킷을 ADSL 모뎀이 받아서 작게 분할하여 **셀**에 저장한다.
(7) 분할된 셀은 ATM 이라는 통신 기술에 사용된다.
(8) 셀에 저장된 패킷을 신호로 변환한다. 변환할 때는 직교 진폭 변조(QAM)라는 방식을 사용한다.
(9) 전화 케이블을 통해 전화국에 도착한 신호가 배선반과 스플리터를 통과하여 **DSLAM** 에 도착한다.
(10) DSLAM이 신호의 파형을 읽어 진폭과 위상을 조사하고 이것이 어느 비트에 대응하는지 판단하여 디지털 신호로 복원하여 전송한다.
(11) ATM 인터페이스가 셸을 수신한다.
(12) ATM 인터페이스가 셸을 원래의 패킷 형태로 되돌린다. (ATM 인터페이스를 셸을 원래 패킷으로 되돌리는 기능이 있음)
(13) BAS에 건내주기 위한 용도로 사용된 MAC 헤더와 PPoE헤더를 제거하고 PPP 헤더 이후 부분을 추출한다.
(14) 터널링에 필요한 헤더를 붙여서 출구를 향해 중계한다.
(15) 패킷이 터널링 출구에 있는 터널링용 라우터에 도착한다.
(16) 터널링용 헤더를 분리하고 IP 헤더 이후 부분의 패킷을 추출한다.
(17) 인터넷 내부에 중계한다.

💡 ADSL 모뎀은 패킷을 셀로 분할하고 전기 신호로 바꾸어 스플리터에 송신한다.
💡 셀은 맨 앞부분에 5바이트의 헤더와 48바이트의 데이터가 이어지는 작은 디지털 데이터의 덩어리이다.
💡 DSLAM이란 다수의 ADSL 모뎀의 기능을 여러개로 묶어서 하나의 케이스에 넣은 것
💡 DSLAM은 ATM 인터페이스를 가지고 있고 패킷을 분할한 셸 형태 그대로 후방의 라우터와 주고받는다. 
💡 BAS는 ATM 셸을 패킷으로 복원하여 인터넷 내부에 중계한다.
</code></pre></div></div>

<h2 id="액세스-회선으로-이용하는-ppp와-터널링">액세스 회선으로 이용하는 PPP와 터널링</h2>

<blockquote>
  <p>내용을 설명하기전 다시한번 짚어보자면, ADSL이나 FTTH 등의 액세스 회선에서 인터넷을 향해 흘러온 패킷은 액세스 회선을 소유한 사업자가 운영하는 BAS에 도착한다.</p>

  <p>인터넷은 다수의 라우터를 함께 연결하여 만든 것으로 액세스 회선을 라우터에 연결하는 것이 원칙이다. 그리고 액세스 회선이 ADSL이나 FTTH로 진화한 것으로 이것에 맞게 액세스 회선을 연결하는 라우터도 진화했다. 진화한 라우터를 BAS 라고 한다. 아래 내용은 무엇이 진화했는 지 설명하는 내용이다.</p>

</blockquote>

<h3 id="️인터넷에-엑세스-하기-위한-액세스-회선의-준비동작"><strong>✔️인터넷에 엑세스 하기 위한 액세스 회선의 준비동작</strong></h3>

<ul>
  <li>ADSL이나 FTTH의 액세스 회선은 최초에 사용자명과 패스워드를 입력하여 로그인을 해야함. 그러나 BAS를 케이블로 고정적으로 접속하므로 PPP처럼 본인인지 확인할 필요가 없어진다.</li>
  <li>ADSL이나 FTTH는 PC에 글로벌 주소를 설정하지 않으면 인터넷에 접속할 수 없다.</li>
</ul>

<h3 id="️bas의-기능">✔️BAS의 기능</h3>

<ul>
  <li>BAS가 ADSL, FTTH 로그인 동작의 창구가 됨 (본인확인)</li>
  <li>터널링이라는 개념을 사용하여 패킷을 운반하는 기능</li>
  <li>TCP/IP의 설정 정보를 통지 (PPP와 동일)</li>
</ul>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>터널링은 소켓과 소켓사이를 연결하는 TCP의 커넥션과 비슷하다. TCP 커넥션의 한쪽 출입구(소켓)에서
데이터를 넣으면 데이터가 그대로의 모습으로 반대쪽 출입구에 도착하는데 터널링은 이것과 같다. 
</code></pre></div></div>

<h3 id="️터널링-기능에-의해-프로바이더에-패킷을-전달한다">✔️터널링 기능에 의해 프로바이더에 패킷을 전달한다</h3>

<ul>
  <li>사용자와 가장 가까운 전화국의 BAS와 프로바이더 라우터 사이에 있는 ADSL/FTTH 접속 서비스 사업자의 네트워크 안에 터널을 만든다. (액세스 회선이 프로바이더의 라우터까지 연결된다는 것)</li>
  <li>터널링 실현 방식에는 TCP의 커넥션을 이용한 터널링과 캡슐화 방식의 터널링이 존재한다.</li>
  <li>패킷을 그대로의 모습으로 운반할 수 있는 구조라면 원리적으로는 어떤 것에도 터널링을 이용할 수 있다.</li>
</ul>

<h2 id="프로바이더의-내부">프로바이더의 내부</h2>

<blockquote>
  <p>액세스 회선을 통과한 패킷은 프로바이더의 라우터에 도착한다. 프로바이더의 라우터는 인터넷이 입구이며 여기에서부터 패킷은 인터넷의 내부로 들어간다. 인터넷의 실체는 단일 네트워크가 아닌 다수의 프로바이더의 네트워크를 서로 접속한 것이다. 프로바이더의 내부에는 POP 라우터와 NOC 라우터가 존재한다.</p>

</blockquote>

<h2 id="프로바이더를-경유하여-흐르는-패킷">프로바이더를 경유하여 흐르는 패킷</h2>

<h3 id="️bgp"><strong>✔️ BGP</strong></h3>

<p>프로바이더 간에는 서로 경로 정보를 교환하여 라우터에 자동 등록한다. 예를 들면 프로바이더 A가 102.47.0.0 의 경로를 알고있으면 접속 상대 (프로바이더 B)에게 102.47.0.0로 가려면 여기로 경유하세요 라고 알리는 것이다. 프로바이더 B는 A에게 받은 정보를 경로표에 등록하고 목적지가 102.47.0.0 일 때 프로바이더 A에게 패킷을 전송한다. 이러한 구조를 <strong>BGP</strong>라고 한다.</p>

<h3 id="️트랜지트transit-peer">✔️ <strong>트랜지트(transit, peer)</strong></h3>

<p>경로 정보 교환은 통지하는 경로 정보의 내용에 따라 두 가지 유형으로 나눌 수 있다. 하나는 인터넷의 경로를 전부 상대에게 통지하는 것이다.</p>

<p><img width="340" alt="스크린샷 2022-05-05 오후 4 43 40" src="https://user-images.githubusercontent.com/56028408/166886633-f21e7632-7aee-43e0-8350-50cda065e094.png" /></p>

<p>위 그림으로 예를 들자면, 프로바이더 E와 연결되어 있는 프로바이더 D가 프로바이더 E에 대한 경로를 프로바이더 B, C에게 전부 통지하는 것이다. 그러면 프로바이더 B,C도 연결되어 있는 다른 프로바이더에게 프로바이더 E의 경로를 통지하게 된다. 그 결과 프로바이더 D를 통과하여 인터넷의 모든 프로바이더에게 패킷을 보낼 수 있게되는데, 이것을 <strong>트랜지트(transit)</strong>라고 한다.</p>

<h3 id="️비트랜지트-peer"><strong>✔️비트랜지트(= peer)</strong></h3>

<p>트랜지트와 또 다른 개념으로 비트랜지트 또는 피어라는 개념도 존재한다. 이것은 트랜지트와는 다르게 자신에게 직접 접속되어 있는 네트워크에 대한 경로만 상대에게 통지하는 것이다. 그러면 상대는 자신에게 직접 접속한 네트워크로 갈 패킷만 보내게 된다.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>💡 이더넷의 내부에는 BGP라는 구조를 사용하여 프로바이더간에 경로 정보를 교환한다. 
💡 BGP의 구조에서는 정보를 교환하는 상대를 'peer'라고 한다. 'peer'는 비트랜지터와 트랜지터를 모두 포함한다.
</code></pre></div></div>

<h3 id="️ixinternet-exchange"><strong>✔️ IX(Internet exchange)</strong></h3>

<p>프로바이더끼리 접속하는 방법은 위 그림처럼 프로바이더 D와 프로바이더 C와 같이 1 대 1 형태로 접속하는 것이 기본이다. 지금도 이 방법을 사용 중이지만 이 방법만으로는 불편하다. 프로바이더끼리 1대1로 접속하는 방법밖에 없으면 모든 프로바이더가 서로 연결되어 있어야 한다. 현재는 국내에만 해도 여러 회사가 있으므로 이것은 보통일이 아니다. 이러한 상황에서 중심이 되는 설비를 설치하고 이것을 경유하여 접속하는 방법을 선택하면 통신 회선의 수를 억제할 수 있다. 이 경우 중심 설비를 IX라고 한다.</p>

<p><img width="744" alt="스크린샷 2022-05-05 오후 5 21 23" src="https://user-images.githubusercontent.com/56028408/166886529-a204e1df-ccb3-42b6-aa06-f8972aadc274.png" /></p>

<h1 id="reference">Reference</h1>

<p>성공과 실패를 결정하는 1%의 네트워크</p>]]></content><author><name>GitHub User</name></author><category term="networkStudy" /><category term="인터넷" /><category term="액세스 회선" /><category term="ADSL" /><category term="LAN" /><summary type="html"><![CDATA[ADSL 기술을 이용한 엑세스 회선의 구조와 동작]]></summary></entry><entry><title type="html">[네트워크 스터디] Chapter_03 케이블의 앞은 LAN 기기였다.</title><link href="http://localhost:4000/networkstudy/2022/05/29/network-study-03.html" rel="alternate" type="text/html" title="[네트워크 스터디] Chapter_03 케이블의 앞은 LAN 기기였다." /><published>2022-05-29T00:00:00+09:00</published><updated>2022-05-29T00:00:00+09:00</updated><id>http://localhost:4000/networkstudy/2022/05/29/network-study-03</id><content type="html" xml:base="http://localhost:4000/networkstudy/2022/05/29/network-study-03.html"><![CDATA[<h1 id="-chapter_03-케이블의-앞은-lan-기기였다-_허브와-스위치-라우터의-탐험">📗 Chapter_03 케이블의 앞은 LAN 기기였다. _허브와 스위치, 라우터의 탐험</h1>

<h3 id="3장의-요점-짚고-넘어가기-">🌟 3장의 요점 짚고 넘어가기 🌟</h3>

<blockquote>
  <p>해당 챕터는 클라이언트 PC가 가정이나 회사의 LAN에 접속되고, 앞부분이 ADSL이나 광섬유(FTTH)등의 광대역 회선에 의해 인터넷에 접속된다는 최신의 대표적인 상황을 가정하여 설명한다.</p>

  <p>이 경우 LAN 어댑터가 송신한 패킷은 스위칭 허브 등을 경유하여 인터넷 접속용 라우터에 도착한다. 라우터의 앞부분은 이미 인터넷이므로여기에서부터 앞부분은 통신사가 패킷을 상대에게 운반한다. 우체통에 봉투를 넣으면 그 후에는 집배원이 편지를 상대에게 전달하는 것과 유사하다.</p>

</blockquote>

<h1 id="1-케이블과-리피터-허브속을-신호가-흘러간다">1. 케이블과 리피터 허브속을 신호가 흘러간다.</h1>

<h3 id="하나하나의-패킷이-독립된-것으로-동작한다">하나하나의 패킷이 독립된 것으로 동작한다.</h3>

<p>컴퓨터에서 송신된 패킷은 허브나 라우터라는 중계 장치에 의해 중계되어 목적지에게 운반된다. 이때 중계장치는 패킷의 데이터 정보를 확인하지 않는다. 이는 애플리케이션의 데이터나 TCP 프로토콜의 제어정보는 패킷 운반 동작에 아무런 영향을 주지 못하는 것이다. 즉 HTTP 메세지나 TCP 수신확인 서버와 클라이언트의 관계 같은 것들은 모두 무시된다고 보면 된다. 따라서 모든 패킷은 독립적인 패킷으로 판단되어 목적지에 운반된다.</p>

<h3 id="lan-케이블은-신호를-약화시키지-않는-것이-핵심이다">LAN 케이블은 신호를 약화시키지 않는 것이 핵심이다</h3>

<p>LAN 어댑터가 흘려보낸 전기신호가 케이블을 통해 허브에 도착될 때 송출한 신호 그대로 허브에 도착하지 않는다. 케이블을 통과하는 사이에 신호의 에너지가 조금씩 떨어지므로 케이블의 길이가 길어질수록 신호가 약해진다.</p>

<p>신호가 약해지는 것 뿐만 아니라 이더넷의 경우 사각형의 각진 신호가 뭉개져서 둥글게 변한다. 신호의 각진 부분은 주파수가 높을수록 전압이 급격하게 변화하게 된다. 이처럼 급격하게 변화하다가 신호가 약해져서 변화가 없어질 때 각이 뭉개진다.</p>

<p>잡음이 없을 경우에도 신호가 도착할 때는 변형돼서 도착할 때가 대부분인데 잡음의 영향까지 더해지면 매우 심각하게 변화한다. 약해진 신호가 더욱 변형되어 0과 1을 잘못 판독할 수 있는데 이것이 통신 오류의 원인이 될 수 있다.</p>

<h3 id="리피터-허브는-연결되어-있는-전체-케이블에-신호를-송신한다">리피터 허브는 연결되어 있는 전체 케이블에 신호를 송신한다.</h3>

<p>신호가 리피터 허브에 도달하면 리피터 허브는 LAN 전체에 신호를 흘린다. 이더넷의 기본 원리인 전체에 패킷의 신호를 뿌리고 수신처 MAC주소에 해당하는 기기만 패킷을 수신한다는 원리를 그대로 실현했다고 보면 된다.</p>

<p>리피터 허브의 내부는 아래 그림과 같은데 각 커넥터의 안쪽에는 LAN 어댑터 내부에 있는 PHY 회로와 역할이 같은 회로가 존재한다. 이를 LAN 어댑터 측과 같이 RJ-45 커넥터에 직접 접속하면 신호를 제대로 수신할 수 없다. 제대로 신호를 수신하려면 <strong>‘송신 단자’</strong>의 신호를 <strong>‘수신 단자’</strong>로 받도록 해야한다. 회로와 커넥터 사이의 신호선을 교차하는 이유는 이 때문이다.</p>

<p>리피터 허브의 끝 커넥터에는 <strong>MDI/MDI-X</strong> 라는 전환 스위치가 존재한다. MDI는 RJ-45 커넥터와 신호 송수신 회로를 직접 결선한 것이고 MDI-X는 교차하여 결선하는 것을 나타낸다. 허브의 커넥터 부분은 보통 MDI-X 이므로 허브끼리 접속할 때는 한쪽을 MDI로 설정해야 한다. MDI로 전환하는 스위치가 없고 모든 커넥터가 MDI-X인 경우에는 크로스 케이블로 허브들에 접속한다.</p>

<p><img src="https://user-images.githubusercontent.com/56028408/165674870-5c7164fe-ca2b-4209-acb3-0e01af53d00a.png" alt="image" /></p>

<p><strong>✔️  리피터 허브</strong></p>

<ul>
  <li>이더넷의 기본을 따르는 하드웨어</li>
  <li>리피터 허브에 도달한 신호를 LAN 전체에 전달하지만 수신처 MAC 주소에 해당하는 패킷만 수신한다.</li>
  <li>전체에 패킷의 신호를 뿌리고 수신처 MAC 주소에 해당하는 기기만 패킷을 수신한다는 의미
    <ul>
      <li>MAC 헤더의 값을 확인 함</li>
    </ul>
  </li>
  <li>리피터 허브의 내부에는 PHY(MAU) 회로와 역할이 같은 회로가 존재한다.</li>
  <li>리피터 허브의 끝 커넥터에서는 MDI/MDI-X와 같이 쓰여있는 전환 스위치가 존재한다.</li>
  <li>MDI로 전환하는 스위치가 없고 모든 커넥터가 MDI-X인 경우에는 크로스 케이블로 허브들에 접속한다.</li>
  <li>잡음의 영향을 받아 데이터가 변화한 것 같은 신호도 전송한다.</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">💡</span> <span class="err">리피터</span> <span class="err">허브는</span> <span class="err">연결된</span> <span class="err">케이블</span> <span class="err">전체에</span> <span class="err">신호를</span> <span class="err">송신한다</span><span class="p">.</span>
</code></pre></div></div>

<h1 id="2-스위칭-허브의-패킷중계-동작">2. 스위칭 허브의 패킷중계 동작</h1>

<h3 id="스위칭-허브는-주소-테이블로-중계한다">스위칭 허브는 주소 테이블로 중계한다</h3>

<p><strong>“스위칭 허브”</strong> 의 신호가 커넥터 부분에 도달하여 PHY 회로에서 수신되는 부분까지는 리피터 허브와 동일하다. PHY 회로에서 케이블을 흐르는 신호의 형식부터 공통의 신호 형식으로 변환한 후 신호는 MAC 회로에 들어간다. 이후 패킷을 디지털 데이터로 변환한 후 패킷의 맨 끝에 있는 FCS를 대조하여 오류의 유무를 검사하고 문제가 없으면 버퍼 메모리에 저장하고 오류가 있었던 패킷이면 폐기한다. 이 부분은 LAN 어댑터와 거의 같고 각 스위칭 허브의 커넥터 안쪽에는 LAN 어댑터와 같은 회로가 존재한다.</p>

<p>커넥터 안쪽에 있는 회로 부분을 포트라고 한다. 스위칭 허브의 각 포트는 PC의 LAN 어댑터와 거의 같지만 스위칭 허브의 포트는 MAC 주소를 검사하지 않고 모든 패킷을 수신하여 버퍼 메모리에 저장하기 때문에 스위칭 허브의 포트에는 LAN 어댑터와 달리 MAC 주소가 할당되어 있지 않다.</p>

<p>패킷을 버퍼 메모리에 저장하면 MAC 주소와 일치하는 것이 MAC 주소표에 등록되어 있는 지 조사한다.  주소표에 수신처 주소와 동일한 MAC 주소가 존재하면 주소표에쓰여있는 포트 위치에 패킷을 송신한다.</p>

<p>포트사이에 패킷을 운반할 때는 “<strong>스위치 회로”</strong> 에 패킷의 신호를 흘린다. 예를 들어 2번 포트에서 7번 포트로 패킷을 운반하려면 신호는 2번에서 들어올 것이다. 이때 선의 가로로 나열된 스위치의 왼쪽에서 7개까지의 스위치는 가로방향으로, 8번째의 스위치는 세로방향으로 전환한다.  그러면 아래 그림과 같이 신호는 출력측의 7번으로 흘러가서 7번 포트에 패킷이 도착한다. 이처럼 신호의 교점에 있는 스위치는 각각 독립적으로 움직이므로 신호가 중복되지 않으면 복수의 신호를 흘릴 수 있다.</p>

<p><img src="https://user-images.githubusercontent.com/56028408/165674867-1b3b5560-d81f-4548-a926-1797fb1aa1b7.png" alt="image" /></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">💡</span> <span class="err">스위칭</span> <span class="err">허브는</span> <span class="n">MAC</span> <span class="err">주소표에서</span> <span class="n">MAC</span> <span class="err">주소를</span> <span class="err">조사하고</span> <span class="err">해당하는</span> <span class="err">포트에</span> <span class="err">신호를</span> <span class="err">송신한다</span><span class="p">.</span>
</code></pre></div></div>

<p>✔️ <strong>스위칭 허브</strong></p>

<ul>
  <li>스위치 내부에는 MAC 주소와 포트번호를 등록한 테이블이 존재한다.
    <ul>
      <li>여기에는 수신포트와 송신 포트도 함께 등록된다.</li>
    </ul>
  </li>
  <li>스위치 내부 테이블 정보를 확인하고 패킷을 중계한다. (목적지 확인)</li>
  <li>스위치 허브의 포트에는 MAC 주소가 할당되어 있지 않다.</li>
  <li>누군가 스위칭 허브에서 신호를 송신 중이면 신호를 보내지 않고 대기한다.</li>
  <li>신호의 교점에 있는 스위치는 독립적이므로 신호가 중복되지 않으면 복수의 신호를 동시에 흘린다.</li>
  <li>패킷이 충돌하지 않도록 재밍신호를 보낸다.</li>
</ul>

<p>✔️ <strong>스위치 회로의 구조</strong></p>

<ul>
  <li>그림과 같은 구조를 전자회로로 만든 것</li>
  <li>신호선은 격자 모양으로 배치되고 교점에 스위치가 존재함</li>
  <li>스위치는 전자적으로 개폐를 제어할 수 있음</li>
  <li>전자적 개폐를 통해 신호가 흐르는 대상을 제어함</li>
  <li>입력측은 수신측 포트에 접속되어 있고 출력측은 송신측 포트에 접속되어 있음</li>
</ul>

<h3 id="mac-주소-테이블을-등록-및-갱신한다">MAC 주소 테이블을 등록 및 갱신한다.</h3>

<p>스위칭 허브는 패킷을 중계할 때 MAC 주소표의 내용을 갱신하는 동작도 실행한다. 갱신 동작에는 두 가지 종류가 있다. 첫번째는 패킷을 수신했을 때 송신처 MAC 주소를 조사하고, 수신한 입력 포트 번호와 하나의 세트로 MAC 주소표에 등록하는 것이다.</p>

<p>MAC 주소표를 등록하는 동작 말고도 등록되어 있는 내용을 지우는 또 하나의 동작이 존재한다. 이것은 기기를 이동했을 때 이동한 기기의 정보 수정없이 패킷을 전달하는 작업을 방지하기 위한 동작이다. 스위치 허브는 오래된 정보를 갱신하기 위해 일정시간 동안 사용되지 않은 정보를 지운다.</p>

<p>✔️ <strong>스위칭 허브의 두 가지 갱신 동작</strong></p>

<ul>
  <li>송신처 MAC 주소 조사 후 수신한 입력포트와 하나의 세트로 MAC 주소표에 등록</li>
  <li>사용하지 않고 일장시간이 지나면 등록된 정보를 삭제하는 동작</li>
</ul>

<h2 id="예외적인-동작">예외적인 동작</h2>
<p>스위칭 허브와 리피터 허브가 같이 접속할 때 송신 포트가 패킷을 수신한 포트와 같을 수 있다. 이때 스위칭 허브는 수신한 포트와 송신하는 포트가 같은 것을 확인하고 같은 값이라면 패킷을 폐기한다. 이뿐만 아니라 MAC 주소표에 수신처 MAC 주소와 일치하는 주소가 등록되어있지 않은 경우도 있다. 이 경우에는 어느 포트에서 송신해야 할지 판단할 수 없으므로 패킷을 수신한 포트 이외의 전체 포트에 패킷을 송신한다. 또한 수신처 MAC 주소가 브로드캐스트 주소인 경우에도 수신 포트를 제외하고 모든 포트에서 패킷을 송신한다.</p>

<h2 id="스위칭-허브는-복수의-중계-동작을-동시에-실행한다">스위칭 허브는 복수의 중계 동작을 동시에 실행한다</h2>

<p>스위칭 허브는 수신처 MAC 주소의 기기가 존재하는 포트 이외에는 송신동작을 실행하지 않으므로 다른 포트는 빈    상태가 된다. 비어있는 포트에는 별도의 패킷을 흘릴 수 있으므로 스위칭 허브는 동시에 여러개의 패킷을 중계할 수 있다. 반면 리피터 허브는 들어온 신호를 모든 포트에 뿌리므로 동시에 두 개 이상의 신호가 들어오면 패킷이 충돌하기 때문에 복수의 신호를 동시에 흘릴 수 없다.</p>

<h1 id="3-라우터의-패킷-중계-동작">3. 라우터의 패킷 중계 동작</h1>

<h3 id="라우터의-기본">라우터의 기본</h3>

<p>라우터의 원리도 스위칭 허브와 비슷하다. 그러나 구체적인 동작은 스위칭 허브와 다른데 라우터는 스위칭 허브와 달리 IP라는 개념을 바탕으로 하기 때문이다. 라우터의 내부 구조는 중계 부분과 포트 부분이라는 두 부분으로 구성되어 있다. 라우터의 중계 부분과 포트 부분의 역할은 LAN 어댑터의 역할 분담과 같다. 즉 라우터의 중계 부분은 IP를 담당하고 포트 부분은 LAN 어댑터와 같다고 생각하면 된다.</p>

<p><img src="https://user-images.githubusercontent.com/56028408/165739277-13c76eb2-cacd-45f4-b842-86189f8fc284.png" alt="image" /></p>

<p><strong>✔️ 라우터의 원리</strong></p>

<ul>
  <li>패킷은 라우터의 포트 부분에서 수신한다. (포트 부분의 하드웨어에 의뢰하여 패킷을 수신)</li>
  <li>패킷 수신 동작은 포트 부분에 연결된 하드웨어의 통신규칙에 따른다.</li>
  <li>중계 부분에서는 받은 패킷의 IP 패킷에 기록되어있는 수신처 IP 주소와 중계 대상을 등록한 표를 대조하여 중계 대상을 판단한다.</li>
  <li>라우터는 스위칭 허브와 달리 송신처나 수신처 둘 다 될 수 있음</li>
  <li>라우터의 포트에는 IP주소가 할당되어 있음 만약 포트가 이더넷인 경우 MAC도 같이 할당 됨</li>
</ul>

<p><strong>✔️ 라우터의 구성</strong></p>

<ul>
  <li>중계 부분과 포트 구분으로 구성되어 있음</li>
  <li>IP개념을 바탕으로 설계되어 있음</li>
  <li>라우터의 중계 부분이 패킷의 중계 대상을 판단함</li>
  <li>라우터의 포트 부분은 패킷의 송수신 동작을 담당함</li>
  <li>라우터의 포트 부분에는 다양한 하드웨어를 장착할 수 있고 라우터는 장착한 하드웨어에 맞는 통신 기술을 지원함</li>
</ul>

<h3 id="경로표에-등록된-정보">경로표에 등록된 정보</h3>

<p>라우터는 스위칭 허브와 달리 IP 헤더에 기재되어 있는 <strong>수신처 IP 주소로 중계 대상을 판단</strong>한다. 라우터는 스위칭 허브와 취급하는 주소가 다르므로 중계 대상을 등록하는 테이블의 내용도 다르다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">💡</span> <span class="err">라우터는</span> <span class="n">IP</span> <span class="err">주소로</span> <span class="err">중계</span> <span class="err">대상을</span> <span class="err">판단한다</span><span class="p">.</span>
</code></pre></div></div>

<p>라우터의 테이블은 <strong>라우팅 테이블</strong> 또는 <strong>경로표</strong>라고 불린다. 여기엔 아래와 같은 정보들이 등록되어 있다.</p>

<table>
  <thead>
    <tr>
      <th>수신처(Destination)</th>
      <th>넷마스크(Netmast)</th>
      <th>게이트웨이(Gateway)</th>
      <th>인터페이스(Interface)</th>
      <th>메트릭(Metric)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>10.10.1.0</td>
      <td>255.255.255.0</td>
      <td> </td>
      <td>e2</td>
      <td>1</td>
    </tr>
    <tr>
      <td>10.10.1.101</td>
      <td>255.255.255.255</td>
      <td> </td>
      <td>e2</td>
      <td>1</td>
    </tr>
    <tr>
      <td>192.168.1.0</td>
      <td>255.255.255.0</td>
      <td> </td>
      <td>e3</td>
      <td>1</td>
    </tr>
    <tr>
      <td>192.168.1.10</td>
      <td>255.255.255.255</td>
      <td> </td>
      <td>e3</td>
      <td>1</td>
    </tr>
    <tr>
      <td>0.0.0.0</td>
      <td>0.0.0.0</td>
      <td>192.0.2.1</td>
      <td>e1</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p><strong>✔️  라우팅 테이블 속성 정보</strong></p>

  <ul>
    <li>수신처
      <blockquote>
        <ul>
          <li>서브넷 자체를 나타내는 주소, 라우터가 중계할 대상</li>
        </ul>
      </blockquote>
    </li>
    <li>넷마스크
      <blockquote>
        <ul>
          <li>넷마스크 값에 따라 네트워크의 비트 수를 판단함</li>
        </ul>
      </blockquote>
    </li>
    <li>게이트웨이
      <blockquote>
        <ul>
          <li>라우터가 수신처에게 패킷을 전송할 때 거쳐야 하는 곳</li>
        </ul>
      </blockquote>
    </li>
    <li>인터페이스
      <blockquote>
        <ul>
          <li>인터페이스 항목에 등록되어있는 인터페이스(포트)에서 게이트웨이 항목에 등록되어있는 IP 주소를 가진 라우터에게 패킷을 중계함</li>
        </ul>
      </blockquote>
    </li>
    <li>메트릭
      <blockquote>
        <ul>
          <li>수신처 IP에 기록되어 있는 주소가 먼지, 가까운지를 판단하는 값</li>
        </ul>
      </blockquote>
    </li>
  </ul>
</blockquote>

<p>라우팅 테이블 수신처 항목에는 서브넷을 나타내는 IP 말고도  <strong>주소 집약</strong> 이라는 개념을 사용하여 몇개의 서브넷을 한개의 서브넷으로 간주한 후 묶은 서브넷을 경로표에 등록하기도 한다. 예를 들어 A 라우터에 10.10.1.0/24, 10.10.2.0/24, 10.10.3.0/24 서브넷이 연결되어 있을 때 B 라우터는 A라우터에 연결되어 있는 서브넷에게 패킷을 건낼 때 A 라우터에 패킷을 중계해야 한다는 사실은 변하지 않으므로 3개의 서브넷을 일괄적으로 통합하여 라우팅 테이블에 등록한다. 이것을 <strong>주소 집약</strong> 이라고 한다.</p>

<p><img src="https://user-images.githubusercontent.com/56028408/165739256-7e87212d-d23c-477d-b71d-0a69d1d453ba.png" alt="image" /></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">💡</span> <span class="err">라우터는</span> <span class="err">호스트</span> <span class="err">번호를</span> <span class="err">무시하고</span> <span class="err">네트워크</span> <span class="err">번호</span> <span class="err">부분만</span> <span class="err">조사한다</span><span class="p">.</span>
<span class="err">💡</span> <span class="err">라우터의</span> <span class="err">경로표에서</span> <span class="err">'넷마스크'</span> <span class="err">항목은</span> <span class="err">경로표의</span> <span class="err">수신처와</span> <span class="err">패킷의</span> <span class="err">수신처</span> <span class="err">주소를</span> <span class="err">대조할</span> <span class="err">때</span> <span class="err">비트</span> <span class="err">수를</span> <span class="err">나타낸다</span><span class="p">.</span>
</code></pre></div></div>

<h3 id="라우터의-패킷-수신-동작">라우터의 패킷 수신 동작</h3>

<p>라우터 포트에는 MAC 주소와 IP가 할당되어 있으며 라우터는 자신의 주소에 해당하는 패킷만 수신하고 해당하지 않는 패킷은 폐기한다.</p>

<h3 id="경로표를-검색하여-출력-포트를-발견한다">경로표를 검색하여 출력 포트를 발견한다.</h3>

<p>MAC 헤더의 역할은 라우터에게 패킷을 건네주는 것이다. 때문에 라우터는 패킷 수신 동작이 끝나면 맨 앞의 MAC 헤더를 폐기한다. 수신동작이 끝나면 MAC 헤더 뒤에 있는 IP 헤더의 내용을 보고 패킷 중계 동작에 들어간다.</p>

<p><strong>✔️ 중계 동작</strong></p>
<ol>
  <li>수신한 패킷의 IP 주소와 경로표에 등록된 수신처 항목을 대조한다.</li>
  <li>복수의 후보가 발견되면 네트워크 번호의 비트 수가 가장 긴 것을 찾는다.</li>
  <li>네트워크 번호의 비트 수가 동일한 것이 존재하면 메트릭 값으로 판단한다.</li>
  <li>해당하는 행이 하나도 발견되지 않을 경우 패킷을 폐기하고 ICMP 메세지로 송신처에 통지한다.</li>
</ol>

<p><br /></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">💡</span> <span class="err">라우터에서</span> <span class="err">중계하는</span> <span class="err">패킷의</span> <span class="err">수신처</span> <span class="n">MAC</span> <span class="err">주소에는</span> <span class="err">라우터의</span> <span class="err">포트에</span> <span class="err">할당된</span> <span class="n">MAC</span> <span class="err">주소가</span> <span class="err">기록되어</span> <span class="err">있다</span><span class="p">.</span>
</code></pre></div></div>

<h1 id="reference">Reference</h1>

<p>성공과 실패를 결정하는 1%의 네트워크</p>]]></content><author><name>GitHub User</name></author><category term="networkStudy" /><category term="리피터 허브" /><category term="스위칭 허브" /><category term="라우팅" /><summary type="html"><![CDATA[📗 Chapter_03 케이블의 앞은 LAN 기기였다. _허브와 스위치, 라우터의 탐험]]></summary></entry><entry><title type="html">[글또 7기] 다짐</title><link href="http://localhost:4000/daily/2022/05/14/%EA%B8%80%EB%98%907%EA%B8%B0-%EB%8B%A4%EC%A7%90.html" rel="alternate" type="text/html" title="[글또 7기] 다짐" /><published>2022-05-14T00:00:00+09:00</published><updated>2022-05-14T00:00:00+09:00</updated><id>http://localhost:4000/daily/2022/05/14/%EA%B8%80%EB%98%907%EA%B8%B0-%EB%8B%A4%EC%A7%90</id><content type="html" xml:base="http://localhost:4000/daily/2022/05/14/%EA%B8%80%EB%98%907%EA%B8%B0-%EB%8B%A4%EC%A7%90.html"><![CDATA[<h2 id="들어가며">들어가며</h2>
<p>읽기 좋은 글을 꾸준하게 작성하고 싶어서 <a href="https://www.notion.so/zzsza/ac5b18a482fb4df497d4e8257ad4d516">글또</a>라는 개발자 커뮤니티에서 활동하게 되었다. 
꾸준하게 글을 작성하는 것이 목표인데….  5월 초에 포스팅한 이후로 인제야 글을 작성한다. 느슨해지지 않기 위해 활동하면서 이루고 싶은 목표들을 정하기로 결심 !</p>

<h2 id="참여한-이유">참여한 이유</h2>
<h3 id="1-가독성-높은-글">1. 가독성 높은 글</h3>
<p>많은 글을 작성해보진 않았지만, 지금까지 포스팅했던 내용을 다시 읽어보면 가독성이 매우 떨어진다. 그리고 불친절한 설명 때문에 다른 사람이 내가 작성한 글을 읽었을 때 큰 혼란이 올 것 같았다. 이런 문제점을 어떻게 고쳐야 하나 고민하고 있을 때 운 좋게 발견한 것이 글또이다.</p>

<h3 id="2-게으름-탈출">2. 게으름 탈출</h3>
<p>강의를 듣거나 책을 읽는 것은 꾸준하게 하는 것이 어렵지 않은데 이상하게 글을 작성하려고 하면 게을러진다. 마음먹고 자리에 앉아도 포스팅하고 싶었던 내용을 정리하는 것이 그렇게 어렵다. 그래도 강제적으로 할 수밖에 없는 환경에 내던져지면 잘 적응하는 편이여서 글또는 나에게 딱 맞았다.</p>

<h3 id="3-학습한-내용-머릿속에-각인하기">3. 학습한 내용 머릿속에 각인하기</h3>
<p>가끔 학습한 내용을 전부 이해하지 못하고 그냥 지나칠 때 내용을 전부 잊어먹는 경우가 있다. 이럴 때 배운 내용을 다시 곱씹으면서 글로 작성하면 머릿속에 더 깊이 각인되는 효과가 있는 것 같다. 글또에서는 주로 공부한 내용을 포스팅할 것이기 때문에 글솜씨와 함께 나의 개발력도 상승하길 바라고 있다.</p>

<h2 id="목표">목표</h2>
<h3 id="1-작성하고-싶은-글">1. 작성하고 싶은 글</h3>
<p>원래 글또를 신청했을 당시에는 참여했던 스터디 중 가장 만족도가 높았던 JSCODE 운영체제 스터디의 후기를 작성할 생각이었는데 마음이 변했다. 지금은 아래와 관련된 내용의 게시물을 포스팅할 생각이다. 전부 작성할 수 있을진 모르겠지만 일단 도전 !</p>

<p><br /></p>

<p>👊 <strong>작성하고 싶은 글 카테고리</strong></p>

<ul>
  <li>읽었던 개발관련 도서 내용 정리</li>
  <li>인상깊은 트러블슈팅 경험</li>
  <li>Java의 모든 것 ?</li>
  <li>Spring 뿌수기</li>
  <li>컴퓨터 사이언스</li>
</ul>

<h3 id="2-내성적인-인간-탈출">2. 내성적인 인간 탈출</h3>
<p>매우 내성적인 성격이라 먼저 나서지도 못하고 말수도 적지만, 글또에서는 좋은 것들은 공유하고 많은 사람과 교류하면서 서로 좋은 영향을 나누고 싶다. 적극적인 사람으로 변할 수 있길 🙏🏻</p>

<h2 id="마치며">마치며</h2>
<p>6개월 동안 초라한 블로그를 화려하게 바꿀 수 있길 ! 이번에는 마감일에 가깝게 글을 작성하였는데 다음번에는 미루지 않고 부지런하게 작성해야겠다. 앞으로도 계속 마감일에 가깝게 글을 작성하면 글 쓰는 게으름을 많이 고치지 못할 것 같다. 그리고 나의 피드백이 많은 사람에게 도움이 되면 좋겠다 !! 글또 화이팅 !</p>]]></content><author><name>GitHub User</name></author><category term="daily" /><category term="글또 7기" /><summary type="html"><![CDATA[들어가며 읽기 좋은 글을 꾸준하게 작성하고 싶어서 글또라는 개발자 커뮤니티에서 활동하게 되었다. 꾸준하게 글을 작성하는 것이 목표인데…. 5월 초에 포스팅한 이후로 인제야 글을 작성한다. 느슨해지지 않기 위해 활동하면서 이루고 싶은 목표들을 정하기로 결심 !]]></summary></entry><entry><title type="html">DNS 란?</title><link href="http://localhost:4000/web/2022/05/01/dns.html" rel="alternate" type="text/html" title="DNS 란?" /><published>2022-05-01T00:00:00+09:00</published><updated>2022-05-04T00:00:00+09:00</updated><id>http://localhost:4000/web/2022/05/01/%08dns</id><content type="html" xml:base="http://localhost:4000/web/2022/05/01/dns.html"><![CDATA[<h2 id="브라우저에-wwwnavercom-입력하면">브라우저에 “www.naver.com” 입력하면?</h2>

<p>DNS가 무엇인지 알아보기 전에 먼저 브라우저에 “www.naver.com” 을 입력했을 때 벌어지는 일들의 일부만 간략하게 알아보자.</p>

<ol>
  <li>브라우저 애플리케이션이 “도메인명”을 조회하는 DNS 리졸버 호출</li>
  <li>DNS 리졸버가 DNS 서버에 보내는 조회 메시지를 생성</li>
  <li>프로토콜 스택이 DNS 서버에 DNS 리졸버가 생성한 메시지를 송신</li>
  <li>DNS 리졸버가 응답 결과를 수신</li>
</ol>

<p><strong>🤔 브라우저 애플리케이션이 “도메인명”을 조회한다고 했는데, 여기서 “도메인명” 이란 무엇을 말하는 걸까?</strong> 
“www.naver.com”를 예시로 들었을 때 도메인명이란 www, naver, com 모두 해당된다. 보통 우리는 특정 웹사이트에 접속할 때 IP 주소가 아닌 도메인명을 입력해서 접속한다.</p>

<h2 id="dns-란">DNS 란?</h2>

<p>사용자는 특정 웹사이트의 도메인명이 아닌 실제 IP를 알 필요가 없다. 하지만 OS 내부에서 다른 서버에 패킷을 송신할 때는 도메인명이 아닌 IP 주소가 필요하다.
앞서 설명한 것처럼 브라우저 애플리케이션은 도메인명으로 해당 서버의 IP 주소를 조회한다. 그렇다면 DNS란 무엇일까? DNS는 도메인명에 해당하는 IP와 기타 정보를 저장해둔 서버이다. 보통 아래와 같은 정보가 저장되어 있다.</p>

<table>
  <thead>
    <tr>
      <th>이름</th>
      <th>클래스</th>
      <th>타입</th>
      <th>클라이언트에 회답하는 항목</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>www.example.com</td>
      <td>IN</td>
      <td>A</td>
      <td>192.168.2.5</td>
    </tr>
    <tr>
      <td>example.com</td>
      <td>IN</td>
      <td>MX</td>
      <td>192.168.2.6</td>
    </tr>
  </tbody>
</table>

<p>✔️ 등록정보의 구성</p>
<ul>
  <li>이름
    <ul>
      <li>이름은 앞서 말한 도메인명에 해당된다.</li>
    </ul>
  </li>
  <li>클래스
    <ul>
      <li>클래스는 네트워크의 종류를 나타낸다. IN은 인터넷을 뜻한다.</li>
    </ul>
  </li>
  <li>타입
    <ul>
      <li>해당 도메인명에 어떤 타입의 정보가 지원되는지를 뜻한다. 예를 들면 MX는 메일의 배송 목적지, A는 도메인명에 IP 주소가 지원된다는 뜻</li>
    </ul>
  </li>
  <li>클라이언트에 회답하는 항목
    <ul>
      <li>이 항목은 도메인명에 해당하는 IP 주소를 의미한다.</li>
    </ul>
  </li>
</ul>

<p>자 그러면 DNS에 등록되어 있는 정보도 알아보았다. 대충 살펴보면 도메인명으로 해당하는 IP를 매칭 해둔 서버인 것 같다.
그런데? 대체 왜 필요한 것일까?</p>

<h2 id="dns를-사용하는-이유">DNS를 사용하는 이유</h2>

<p>간단하게 전화번호부를 예로 들어보자. 평소에 우리는 지인들의 전화번호를 전부 외우지 못한다.
하지만 우리는 현대인이기 때문에 전화번호를 외우지 못하는 것이 아무런 문제가 되지 않는다. 전화번호를 전화번호부에 이름으로 저장해두면 되기 때문이다. 
DNS도 비슷한 맥락이다. 우리가 자주 접근하는 웹 사이트 전부를 IP 주소만을 사용해서 접근할 수 있다고 생각하면 너무 끔찍하다. 북마크 기능이 있지만 접근하는 사이트마다 북마크를 해놓을수도 없는 노릇이다. DNS 서버는 우리가 도메인명으로 웹 사이트에 접근할 수 있도록 해주는 아주 고마운 서버이다. 그런데 DNS 서버없이 그냥 도메인명으로 통신하면 안될까? 라는 의문도 들 수 있다. 
하지만 IP 주소는 32bit 만으로 이뤄져있는 반면에 도메인명은 수십 바이트부터 255 바이트까지 존재하기 때문에 라우터의 부하가 발생하여 통신이 지연될 수 있다.</p>]]></content><author><name>GitHub User</name></author><category term="Web" /><category term="DNS" /><summary type="html"><![CDATA[브라우저에 “www.naver.com” 입력하면?]]></summary></entry><entry><title type="html">[네트워크 스터디] Chapter_02 TCP/IP의 데이터를 전기 신호로 만들어 보낸다</title><link href="http://localhost:4000/networkstudy/2022/04/29/network-study-02.html" rel="alternate" type="text/html" title="[네트워크 스터디] Chapter_02 TCP/IP의 데이터를 전기 신호로 만들어 보낸다" /><published>2022-04-29T00:00:00+09:00</published><updated>2022-04-29T00:00:00+09:00</updated><id>http://localhost:4000/networkstudy/2022/04/29/network-study-02</id><content type="html" xml:base="http://localhost:4000/networkstudy/2022/04/29/network-study-02.html"><![CDATA[<h1 id="-chapter_02-tcpip의-데이터를-전기-신호로-만들어-보낸다">📗 Chapter_02 TCP/IP의 데이터를 전기 신호로 만들어 보낸다</h1>
<h3 id="2장의-요점-짚고-넘어가기-">🌟 2장의 요점 짚고 넘어가기 🌟</h3>

<blockquote>
  <p>Chapter 02에선 OS에 내장된 프로토콜 스택이 처음 등장한다. 프로토콜 스택은 네트워크 제어용 소프트웨어이다. 프로토콜 스택은 브라우저에서 받은 메세지를 패킷 속에 저장하고, 수신처 주소 등의 제어 정보를 덧붙인다. 프로토콜 스택은 통신 오류가 발생했을 때 패킷을 고쳐서 보내거나 통신의 기본을 조절하는 등의 다양한 역할을 한다.</p>

  <p>이뿐만 아니라 프로토콜 스택은 패킷을 LAN어댑터(이더넷이나 무선 LAN으로 통신할 때 사용하는 하드웨어)에 넘긴다. 그리고 LAN 어댑터가 패킷을 전기신호로 변환하고 LAN의 케이블에 송출하는 과정을 통해 패킷이 네트워크 속으로 전달된다.</p>

</blockquote>

<h2 id="1-소켓을-작성한다"><strong>1. 소켓을 작성한다.</strong></h2>

<h3 id="1️⃣프로토콜-스택의-내부-구성"><strong>1️⃣ 프로토콜 스택의 내부 구성</strong></h3>

<p>아래 이미지는 브라우저에서 데이터를 전송했을 때 어떠한 소프트웨어와 하드웨어를 거쳐 서버에 도착하는 지</p>

<p>간단하게 요약한 이미지이다.</p>

<p><img src="https://user-images.githubusercontent.com/56028408/164371689-8ed7cd05-d86f-4853-bbb5-9d900e6b5ef0.png" alt="image" /></p>

<p><strong>✔️ 네트워크 어플리케이션</strong></p>

<ul>
  <li>브라우저, 메일러, 웹 서버, 메일 서버 등의 프로그램이 여기에 해당됨</li>
  <li>네트워크 어플리케이션부터 아래로 향하여 데이터 송 수신 등의 일을 의뢰함</li>
  <li>Socket
    <ul>
      <li>네트워크 애플리케이션 아랫부분에는 Socket 라이브러리가 존재하고 그 안에는 리졸버가 내장되어 있음</li>
      <li>Socket 라이브러리는 DNS서버에서 목적지의 IP 주소를 조회하는 역할을 담당함</li>
    </ul>
  </li>
</ul>

<p><strong>✔️  프로토콜 스택</strong></p>

<ul>
  <li>프로토콜 스택은 OS 내부에 존재하는 네트워크 제어용 소프트웨어이다.</li>
  <li>TCP, UDP 프로토콜을 사용하는 소프트웨어
    <ul>
      <li>프로토콜 스택의 윗부분에는 TCP, UDP 프로토콜을 사용하여 데이터 송수신을 담당하는 부분이 존재한다. 이 둘이 어플리케이션의 의뢰를 받아 송수신 동작을 실행한다.</li>
    </ul>
  </li>
  <li>IP 프로토콜을 사용하는 소프트웨어
    <ul>
      <li>데이터를 작게 나눈 패킷을 통신 상대까지 운반하는 것이 해당 소프트웨어의 주 역할</li>
      <li>IP 안에는 ICMP와 ARP라는 프로토콜을 다루는 부분이 존재함</li>
      <li>ICMP는 패킷을 운반할 때 발생하는 오류를 통지하거나 제어용 메세지를 통지할 때 사용됨</li>
      <li>ARP는 IP 주소에 대응하는 이더넷의 MAC 주소를 조사할 때 사용됨</li>
    </ul>
  </li>
</ul>

<p><strong>✔️ LAN 드라이버</strong></p>

<ul>
  <li>LAN 어댑터의 하드웨어를 제어함</li>
  <li>LAN 드라이버 아래에 있는 LAN 어댑터가 실제 송 수신 동작, 즉 케이블에 대해 신호를 송 수신 하는 동작을 실행함</li>
</ul>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">💡 프로토콜</span><span class="w"> </span><span class="err">스택이란</span><span class="w"> </span><span class="err">네트워크</span><span class="w"> </span><span class="err">제어용</span><span class="w"> </span><span class="err">소프트웨어이다.</span><span class="w"> </span><span class="err">프로토콜</span><span class="w"> </span><span class="err">스택은</span><span class="w"> </span><span class="err">제어</span><span class="w"> </span><span class="err">정보를</span><span class="w"> </span><span class="err">저장하거나</span><span class="w"> </span><span class="err">패킷을</span><span class="w"> </span><span class="err">LAN</span><span class="w"> </span><span class="err">어댑터에</span><span class="w"> </span><span class="err">넘기는</span><span class="w"> </span><span class="err">역할을</span><span class="w"> </span><span class="err">담당한다.</span><span class="w">

</span><span class="err">💡 브라우저나</span><span class="w"> </span><span class="err">메일</span><span class="w"> </span><span class="err">등의</span><span class="w"> </span><span class="err">일반적인</span><span class="w"> </span><span class="err">애플리케이션이</span><span class="w"> </span><span class="err">데이터를</span><span class="w"> </span><span class="err">송</span><span class="w"> </span><span class="err">수신할</span><span class="w"> </span><span class="err">경우에는</span><span class="w"> </span><span class="err">TCP를</span><span class="w"> </span><span class="err">주로</span><span class="w"> </span><span class="err">사용</span><span class="w">

</span><span class="err">💡 DNS</span><span class="w"> </span><span class="err">서버에</span><span class="w"> </span><span class="err">대한</span><span class="w"> </span><span class="err">조회</span><span class="w"> </span><span class="err">등에서</span><span class="w"> </span><span class="err">짧은</span><span class="w"> </span><span class="err">제어용</span><span class="w"> </span><span class="err">데이터를</span><span class="w"> </span><span class="err">송수신할</span><span class="w"> </span><span class="err">경우에는</span><span class="w"> </span><span class="err">UDP 사용</span><span class="w">
</span></code></pre></div></div>

<p><strong>✔️  소켓의 메세지 송신 동작</strong>  </p>

<p><img src="https://user-images.githubusercontent.com/56028408/164371702-c3a06672-64e0-4ee6-8419-da6472697a41.png" alt="image" /></p>

<h3 id="2️⃣소켓의-실체는-통신-제어용-제어-정보">2️⃣ 소켓의 실체는 통신 제어용 제어 정보</h3>

<p>프로토콜 스택은 내부에 제어 정보를 기록하는 메모리 영역을 가지고 있다. 해당 영역에는 통신 동작 제어에 필요한 제어 정보를 기록한다. 대표적으로 <strong>통신 상대의 IP주소, 포트번호, 통신 동작 진행 상태</strong> 등이 있다.</p>

<p>본래 소켓은 개념적인 것이고 실체가 존재하지 않는다. 굳이 말하자면 프로토콜 스택 내부에 저장된 제어 정보가 소켓의 실체라고 할 수 있다. 프로토콜 스택은 소켓에 기록된 제어 정보를 참조하면서 동작한다.</p>

<h3 id="3️⃣소켓을-호출했을-때의-동작">3️⃣ 소켓을 호출했을 때의 동작</h3>

<p><strong>✔️  socket()</strong></p>

<ul>
  <li>애플리케이션이 socket을 호출하여 프로토콜 스택에게 소켓을 만들 것을 의뢰한다. 이때 프로토콜 스택은 소켓 한 개 분량의 메모리 영역을 확보하고 초기 상태임을 나타내는 제어 정보를 기록한다. 이 과정을 통해 소켓이 생성된다.</li>
  <li>소켓이 생성되면 소켓을 나타내는 디스크립터를 애플리케이션에 알려준다. 디스크립터는 프로토콜 스택의 내부에 있는 다수의 소켓 중 어느 것을 가리키는지 나타내는 번호표와 같다. 디스크립터는 프로토콜 스택이 데이터 송 수신 동작을 의뢰할 때 통지한다.</li>
</ul>

<h2 id="2-서버에-접속한다">2. 서버에 접속한다.</h2>

<h3 id="1️⃣접속의-의미"><strong>1️⃣</strong>  접속의 의미</h3>

<blockquote>
  <p>이더넷이나 통신 회선은 항상 케이블이 연결되어 있으므로 데이터를 신호로 변환하여 송신하기만 하면 언제든 통신이 가능하다. 하지만 소켓을 만든 직후에는 아무런 정보도 기록되어 있지 않기 때문에 통신 상대와의 사이에 제어 정보를 주고받아서 데이터 송 수신이 가능한 상태로 만드는 작업이 필요하다. 여기에서 주고받는 제어정보는 IP나 포트번호 등이다. 접속 동작에서 주고받는 제어 정보는 통신의 규칙으로 정해져 있다.</p>

  <p>접속을 시도할 때는 제어 정보를 주고받는 것 뿐만 아니라 송 수신 데이터를 일시적으로 저장할 버퍼 메모리 확보도 이때 같이 실행된다.</p>

</blockquote>

<h3 id="2️⃣맨-앞부분에-제어-정보를-기록한-헤더를-배치한다">2️⃣ 맨 앞부분에 제어 정보를 기록한 헤더를 배치한다.</h3>

<p><strong>✔️  헤더란?</strong> </p>

<ul>
  <li>헤더는 클라이언트와 서버가 서로 연락을 절충하기 위해 주고받는 정보가 포함되어 있다.</li>
  <li>헤더에는 데이터를 송 수신 하는 동작이나 연결을 끊는 동작도 포함되어 있기 때문에 통신 동작 전체에서 필요한 내용을 검토하여 TCP 프로토콜의 사양으로 규정하고 있다.</li>
  <li>클라이언트와 서버 사이에 주고받는 패킷 맨 앞부분부터 부가된 제어정보를 헤더라고 한다.</li>
  <li>이더넷이나 IP에도 동일한 헤더가 존재하기 때문에 <strong>TCP 헤더, 이더넷 헤더(=Mac 헤더), IP헤더</strong>와 같이 구분하여 사용해야 한다.</li>
</ul>

<p><strong>✔️  소켓에 기록되는 정보</strong></p>

<ul>
  <li>프로토콜 스택의 동작을 제어하기 위한 정보
    <ul>
      <li>애플리케이션에서 통지된 정보</li>
      <li>통신 상대로부터 받은 정보</li>
      <li>송 수신 동작의 진행 상황</li>
    </ul>
  </li>
  <li>프로토콜 스택이 소켓에 기록된 정보를 참조하면서 움직이기 때문에 소켓의 제어 정보는 프로토콜 스택과 일체화 되어있다 해도 무방하다.</li>
  <li>소켓에 기록되는 정보는 상대측에서 볼 수 없다. 이미 서로 필요한 정보를 헤더로 주고받기 때문에 통신에는 문제가 없다.</li>
</ul>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">🌟 </span><span class="w"> </span><span class="err">통신</span><span class="w"> </span><span class="err">동작에</span><span class="w"> </span><span class="err">이용하는</span><span class="w"> </span><span class="err">제어</span><span class="w"> </span><span class="err">정보는</span><span class="w"> </span><span class="err">다음의</span><span class="w"> </span><span class="err">두</span><span class="w"> </span><span class="err">종류</span><span class="w">

</span><span class="mi">1</span><span class="err">.</span><span class="w"> </span><span class="err">헤더에</span><span class="w"> </span><span class="err">기입되는</span><span class="w"> </span><span class="err">정보</span><span class="w">
</span><span class="mi">2</span><span class="err">.</span><span class="w"> </span><span class="err">소켓에</span><span class="w"> </span><span class="err">기록되는</span><span class="w"> </span><span class="err">정보</span><span class="w">
</span></code></pre></div></div>

<h3 id="3️⃣접속-동작의-실체">3️⃣ 접속 동작의 실체</h3>

<p><strong>✔️ connet()</strong></p>

<ul>
  <li>여기에 서버측의 IP 주소와 포트 번호를 입력하면 명령이 프로토콜 스택의 TCP 담당 부분에 전달된다.</li>
  <li>그러면 TCP 담당 부분은 목적지 서버측의 TCP 담당 부분과의 사이에 제어 정보를 주고 받는다.</li>
</ul>

<p><strong>✔️  클라이언트와 서버의 대화 과정</strong> </p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span><span class="err">.</span><span class="w"> </span><span class="err">데이터</span><span class="w"> </span><span class="err">송</span><span class="w"> </span><span class="err">수신</span><span class="w"> </span><span class="err">동작의</span><span class="w"> </span><span class="err">개시를</span><span class="w"> </span><span class="err">나타내는</span><span class="w"> </span><span class="err">제어</span><span class="w"> </span><span class="err">정보를</span><span class="w"> </span><span class="err">기록한</span><span class="w"> </span><span class="err">헤더를</span><span class="w"> </span><span class="err">만든다.</span><span class="w">
    </span><span class="mi">1</span><span class="err">.</span><span class="w"> </span><span class="err">헤더의</span><span class="w"> </span><span class="err">내용</span><span class="w"> </span><span class="err">중</span><span class="w"> </span><span class="err">중요한</span><span class="w"> </span><span class="err">것은</span><span class="w"> </span><span class="err">송신처와</span><span class="w"> </span><span class="err">수신처의</span><span class="w"> </span><span class="err">포트번호이다.</span><span class="w"> </span><span class="err">이를</span><span class="w"> </span><span class="err">통해</span><span class="w"> </span><span class="err">송신처와</span><span class="w"> </span><span class="err">수신처를</span><span class="w"> </span><span class="err">지정할</span><span class="w"> </span><span class="err">수</span><span class="w"> </span><span class="err">있다.</span><span class="w">
    
</span><span class="mi">2</span><span class="err">.</span><span class="w"> </span><span class="err">TCP</span><span class="w"> </span><span class="err">헤더가</span><span class="w"> </span><span class="err">만들어지면</span><span class="w"> </span><span class="err">이를</span><span class="w"> </span><span class="err">IP</span><span class="w"> </span><span class="err">담당</span><span class="w"> </span><span class="err">소프트웨어에</span><span class="w"> </span><span class="err">건네주어</span><span class="w"> </span><span class="err">송신하도록</span><span class="w"> </span><span class="err">의뢰한다.</span><span class="w">

</span><span class="mi">3</span><span class="err">.</span><span class="w"> </span><span class="err">송신</span><span class="w"> </span><span class="err">동작을</span><span class="w"> </span><span class="err">거쳐</span><span class="w"> </span><span class="err">네트워크를</span><span class="w"> </span><span class="err">통해</span><span class="w"> </span><span class="err">서버에</span><span class="w">  </span><span class="err">패킷이</span><span class="w"> </span><span class="err">도착하면</span><span class="w"> </span><span class="err">서버측의</span><span class="w"> </span><span class="err">IP</span><span class="w"> </span><span class="err">담당</span><span class="w"> </span><span class="err">소프트웨어가</span><span class="w"> </span><span class="err">이를</span><span class="w"> </span><span class="err">TCP</span><span class="w"> </span><span class="err">담당</span><span class="w"> </span><span class="err">소프트웨어</span><span class="w"> </span><span class="err">에게</span><span class="w"> </span><span class="err">전달한다.</span><span class="w">

</span><span class="mi">4</span><span class="err">.</span><span class="w"> </span><span class="err">서버측의</span><span class="w"> </span><span class="err">TCP</span><span class="w"> </span><span class="err">담당</span><span class="w"> </span><span class="err">소프트웨어가</span><span class="w"> </span><span class="err">TCP헤더를</span><span class="w"> </span><span class="err">조사하여</span><span class="w"> </span><span class="err">기록되어</span><span class="w"> </span><span class="err">있는</span><span class="w"> </span><span class="err">수신처</span><span class="w"> </span><span class="err">포트</span><span class="w"> </span><span class="err">번호에</span><span class="w"> </span><span class="err">해당하는</span><span class="w"> </span><span class="err">소켓을</span><span class="w"> </span><span class="err">찾아낸다.</span><span class="w"> 
   </span><span class="err">해당하는</span><span class="w"> </span><span class="err">소켓이</span><span class="w"> </span><span class="err">발견되면</span><span class="w"> </span><span class="err">해당</span><span class="w"> </span><span class="err">소켓에</span><span class="w"> </span><span class="err">필요한</span><span class="w"> </span><span class="err">정보를</span><span class="w"> </span><span class="err">기록하고</span><span class="w"> </span><span class="err">접속</span><span class="w"> </span><span class="err">동작</span><span class="w"> </span><span class="err">상태를</span><span class="w"> </span><span class="err">진행</span><span class="w"> </span><span class="err">중으로</span><span class="w"> </span><span class="err">변경한다.</span><span class="w">
    
</span><span class="mi">5</span><span class="err">.</span><span class="w"> </span><span class="err">(</span><span class="mi">4</span><span class="err">)번</span><span class="w"> </span><span class="err">과정이</span><span class="w"> </span><span class="err">끝나면</span><span class="w"> </span><span class="err">서버의</span><span class="w"> </span><span class="err">TCP</span><span class="w"> </span><span class="err">담당</span><span class="w"> </span><span class="err">소프트웨어는</span><span class="w"> </span><span class="err">응답을</span><span class="w"> </span><span class="err">돌려보내기</span><span class="w"> </span><span class="err">위해</span><span class="w"> </span><span class="err">IP</span><span class="w"> </span><span class="err">담당</span><span class="w"> </span><span class="err">소프트웨어에게</span><span class="w"> </span><span class="err">의뢰한다.</span><span class="w"> 

</span><span class="mi">6</span><span class="err">.</span><span class="w"> </span><span class="err">이때</span><span class="w"> </span><span class="err">ACK라는</span><span class="w"> </span><span class="err">컨트롤</span><span class="w"> </span><span class="err">비트도</span><span class="w"> </span><span class="mi">1</span><span class="err">로</span><span class="w"> </span><span class="err">설정하여</span><span class="w"> </span><span class="err">돌려보낸다.</span><span class="w"> 

</span><span class="mi">7</span><span class="err">.</span><span class="w"> </span><span class="err">패킷이</span><span class="w"> </span><span class="err">클라이언트에게</span><span class="w"> </span><span class="err">정상적으로</span><span class="w"> </span><span class="err">돌아왔으면</span><span class="w"> </span><span class="err">TCP</span><span class="w"> </span><span class="err">헤더를</span><span class="w"> </span><span class="err">조사하여</span><span class="w"> </span><span class="err">서버측의</span><span class="w"> </span><span class="err">접속</span><span class="w"> </span><span class="err">동작이</span><span class="w"> </span><span class="err">성공했는</span><span class="w"> </span><span class="err">지</span><span class="w"> </span><span class="err">확인한다.</span><span class="w"> 
   </span><span class="err">서버</span><span class="w"> </span><span class="err">측의</span><span class="w"> </span><span class="err">접속이</span><span class="w"> </span><span class="err">성공했으면</span><span class="w"> </span><span class="err">클라이언트</span><span class="w"> </span><span class="err">소켓에</span><span class="w"> </span><span class="err">서버</span><span class="w"> </span><span class="err">IP</span><span class="w"> </span><span class="err">주소나</span><span class="w"> </span><span class="err">포트</span><span class="w"> </span><span class="err">번호</span><span class="w"> </span><span class="err">등과</span><span class="w"> </span><span class="err">함께</span><span class="w"> </span><span class="err">접속</span><span class="w"> </span><span class="err">완료를</span><span class="w"> </span><span class="err">나타내는</span><span class="w"> </span><span class="err">제어</span><span class="w"> </span><span class="err">정보를</span><span class="w"> </span><span class="err">기록한다.</span><span class="w">
    
</span><span class="mi">8</span><span class="err">.</span><span class="w"> </span><span class="err">마지막으로</span><span class="w"> </span><span class="err">클라이언트에</span><span class="w"> </span><span class="err">패킷이</span><span class="w"> </span><span class="err">정상적으로</span><span class="w"> </span><span class="err">도착했다는</span><span class="w"> </span><span class="err">것을</span><span class="w"> </span><span class="err">알리기</span><span class="w"> </span><span class="err">위해</span><span class="w"> </span><span class="err">ACK</span><span class="w"> </span><span class="err">비트를</span><span class="w"> </span><span class="mi">1</span><span class="err">로</span><span class="w"> </span><span class="err">만든</span><span class="w"> </span><span class="err">TCP</span><span class="w"> </span><span class="err">헤더를</span><span class="w"> </span><span class="err">서버측에</span><span class="w"> </span><span class="err">반송한다.</span><span class="w">
</span></code></pre></div></div>
<p><strong>🌟 ACK는 패킷이 대상에게 잘 도착했는지 확인하는 용도로 사용된다.</strong></p>

<h2 id="3-데이터를-송수신-한다">3. 데이터를 송수신 한다.</h2>

<h3 id="1️⃣프로토콜-스택에--http-리퀘스트-메세지를-넘긴다"><strong>1️⃣ 프로토콜 스택에  HTTP 리퀘스트 메세지를 넘긴다.</strong></h3>

<blockquote>
  <p>connect에서 애플리케이션에 제어가 되돌아오면 데이터 송 수신 동작이 들어간다. 데이터 송 수신 동작은 애플리케이션이 <strong>✔️ write()</strong> 를 호출하여 송신 데이터를 프로토콜 스택에 건네주는 곳부터 시작된다.</p>

</blockquote>

<p>프로토콜 스택은 받은 데이터의 내용을 곧바로 송신하는 것이 아니라 일단 프로토콜 스택 내부의 송신용 버퍼 메모리 영역에 저장하고 애플리케이션이 다음 데이터를 건네주기를 기다린다.</p>

<p>송신용 버퍼에 저장하는 이유는 애플리케이션에서 프로토콜 스택에 건네주는 데이터의 길이는 애플리케이션마다 상이하기 때문이다.  이러한 상황에서 받은 데이터를 곧바로 보내는 방법은 작은 패킷을 많이 보낼 수 있지만 네트워크 이용 효율이 저하되므로 어느 정도 데이터를 저장하고 나서 송 수신 동작을 진행한다.</p>

<p>송신 버퍼에 어느 정도의 데이터가 담겼을 때 송신한다는 규칙은 OS의 종류나 버전마다 달라지지만 <strong>MTU</strong>나 <strong>타이밍</strong>을 바탕으로 어느정도 판단할 수 있다.</p>

<p><strong>✔️ MTU?</strong></p>

<ul>
  <li>한 패킷으로 운반할 수 있는 디지털 데이터의 최대 길이 이더넷에서는 보통 1500 바이트</li>
  <li>MTU에는 패킷의 맨 앞부분에 헤더가 포함되어 있음, 여기부터 헤더를 제외한 것이 하나의 패킷으로 운반할 수 있는 데이터의 최대 길이가 됨 이것을 <strong>MSS</strong> 라고 한다.</li>
</ul>

<p><strong>✔️ MSS?</strong></p>

<ul>
  <li>헤더를 제외하고 한 개의 패킷으로 운반할 수 있는 TCP의 데이터 최대 길이</li>
  <li>애플리케이션에서 받은 데이터가 MSS를 초과하거나 MSS에 가까운 길이에 이르기까지 데이터를 저장하고 송신동작을 진행하면 패킷이 잘게 나눠질 걱정을 하지 않아도 된다.</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/56028408/164371712-2c075fc2-7133-48aa-837b-c3bf552b4f15.png" alt="image" /></p>

<p>✔️ <strong>타이밍?</strong></p>

<p>애플리케이션의 송신 속도가 느려지는 경우 MSS에 가깝게 데이터를 저장하면 여기에서 시간이 걸려 송신 동작이 지연되므로 버퍼에 데이터가 모이지 않아도 적당한 곳에서 송신 동작을 실행해야 한다. 따라서 프로토콜 스택은 일정한 시간이 경과하면 패킷을 송신할 수 있게 내부에 타이머라는 소프트웨어를 둔다.</p>

<p>두 가지의 판단요소가 존재하지만 이 둘은 상반되는 면도 존재한다. <strong>MSS</strong> 바탕을 중시하면 패킷 길이가 길어져서 네트워크 이용 효율이 높아지지만 버퍼에 머무는 시간만큼 송신 동작이 지연될 우려가 존재한다. 반대로 타이밍을 중시하면 지연은 적어지지만 이용 효율이 떨어지므로 양자를 절충해서 적당히 시간을 가늠하여 송신 동작을 실행해야 한다. 그러나 TCP 프로토콜 사양에는 절충에 대한 규약은 없으므로 실제 판단은 프로토콜 스택을 만드는 개발자의 몫이다.</p>

<h3 id="2️⃣데이터가-클-때는-분할하여-보낸다">2️⃣ 데이터가 클 때는 분할하여 보낸다</h3>

<p>HTTP 리퀘스트 메세지는 보통 그다지 길지 않은 것이 대부분이다. 하지만 항상 예외는 존재하기에 HTTP 리퀘스트 메세지가 한 개의 패킷에 전부 들어가지 못할 경우, 송신 버퍼에 들어있는 데이터를 맨 앞부터 차례대로 MSS의 크기에 맞게 분할하고 분할한 조각을 한 개씩 패킷에 넣어 송신한다.</p>

<p><img src="https://user-images.githubusercontent.com/56028408/164371676-1c0fa15f-f6bb-4a7d-8df4-77c61fdae138.png" alt="image" /></p>

<h3 id="3️⃣-ack-번호를-사용하여-패킷이-도착했는지-확인한다">3️⃣  ACK 번호를 사용하여 패킷이 도착했는지 확인한다.</h3>

<p>데이터 송신동작은 앞서 설명한 것 만으로는 끝나지 않는다. TCP는 송신한 패킷이 상대에게 도착했는지 확인하고 도착하지 않았으면 다시 송신하는 기능이 있으므로 패킷을 송신한 후에는 확인 동작으로 넘어간다.</p>

<p>먼저 TCP 담당 소프트웨어는 데이터를 조각으로 분할할 때 조각이 통신 개시부터 따져서 몇 번째 바이트에 해당 하는지 세어둔다. 이 값을 시퀀스 번호라고 하며 TCP 헤더에 기록한다. 이렇게 시퀀스 번호를 기록할 경우 수신측에서 패킷의 누락여부를 확인할 수 있다. 수신측은 전달 받은 데이터의 바이트 크기를 확인하고 이를 ACK 번호에 기록하고 이 값에 1을 더하여 송신측에 전달한다.</p>

<p>✔️ <strong>예시</strong></p>

<p>총 4381바이트의 데이터를 전송한다고 가정한다.</p>

<p><strong>[누락되지 않은 경우]</strong></p>

<ol>
  <li>시퀀스 번호 1 , 데이터 크기 : 1460바이트
    <ol>
      <li>ACK 번호 1461</li>
    </ol>
  </li>
  <li>시퀀스 번호 1461, 데이터 크기 : 1460바이트
    <ol>
      <li>ACK 번호 2921</li>
    </ol>
  </li>
  <li>시퀀스 번호 2921, 데이터 크기 : 1460바이트
    <ol>
      <li>ACK 번호 4381</li>
    </ol>
  </li>
</ol>

<p><strong>[누락된 경우]</strong></p>

<ol>
  <li>시퀀스 번호 1 , 데이터 크기 : 1460바이트
    <ol>
      <li>ACK 번호 1461</li>
    </ol>
  </li>
  <li>시퀀스 번호 1461, 데이터 크기 : 1460바이트
    <ol>
      <li>ACK 번호 전송하지 않음</li>
    </ol>
  </li>
  <li>시퀀스 번호 1461, 데이터 크기 : 1460바이트 (재전송)
    <ol>
      <li>ACK 번호 2921</li>
    </ol>
  </li>
</ol>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">🌟 </span><span class="w"> </span><span class="err">시퀀스</span><span class="w"> </span><span class="err">번호와</span><span class="w"> </span><span class="err">ACK</span><span class="w"> </span><span class="err">번호로</span><span class="w"> </span><span class="err">패킷이</span><span class="w"> </span><span class="err">수신측에</span><span class="w"> </span><span class="err">도착한</span><span class="w"> </span><span class="err">것을</span><span class="w"> </span><span class="err">확인한다.</span><span class="w">

</span><span class="err">🌟 ACK</span><span class="w"> </span><span class="err">번호를</span><span class="w"> </span><span class="err">통지할</span><span class="w"> </span><span class="err">때는</span><span class="w"> </span><span class="err">단순히</span><span class="w"> </span><span class="err">ACK</span><span class="w"> </span><span class="err">번호에</span><span class="w"> </span><span class="err">값을</span><span class="w"> </span><span class="err">설정할</span><span class="w"> </span><span class="err">뿐만</span><span class="w"> </span><span class="err">아니라</span><span class="w"> </span><span class="err">제어</span><span class="w"> </span><span class="err">비트의</span><span class="w"> </span><span class="err">ACK</span><span class="w"> </span><span class="err">비트도</span><span class="w"> </span><span class="mi">1</span><span class="err">로</span><span class="w"> </span><span class="err">설정한다.</span><span class="w"> 
</span><span class="err">이렇게하면</span><span class="w"> </span><span class="err">ACK</span><span class="w"> </span><span class="err">번호</span><span class="w"> </span><span class="err">필드가</span><span class="w"> </span><span class="err">유효하다는</span><span class="w"> </span><span class="err">의미가</span><span class="w"> </span><span class="err">된다.</span><span class="w">
</span></code></pre></div></div>

<h3 id="4️⃣-패킷-평균-왕복-시간으로-ack-번호의-대기-시간을-조정한다"><strong>4️⃣  패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다.</strong></h3>

<p>ACK 번호가 돌아오는 것을 기다리는 시간을 <strong>타임아웃 값</strong> 이라고 한다.</p>

<p>네트워크가 혼잡하면 ACK 번호가 돌아오는 시간이 지연될 수 있다. 이때 ACK 번호가 돌아오기전에 패킷을 재전송하면 혼잡한 네트워크를 악화시키는 사태가 발생한다.</p>

<p>이러한 문제를 방지하기 위해 대기 시간을 적절하게 설정해야한다. 대기 시간이 너무 짧으면 패킷을 자주 보내게 되고 대기시간을 너무 길게 설정하면 패킷을 다시 보내는 동작이 지연되어 속도 저하의 원인이 되기 때문이다.</p>

<p>보통 TCP는 ACK 번호가 돌아오는 시간을 기준으로 대기 시간을 판단하여 동적으로 변경하는 방법을 취한다.</p>

<h3 id="5️⃣-윈도우-제어-방식으로-효율적으로-ack-번호를-관리한다"><strong>5️⃣  윈도우 제어 방식으로 효율적으로 ACK 번호를 관리한다.</strong></h3>

<p>ACK 번호가 돌아올 때까지의 시간동안 아무 일도 하지 않고 기다리는 것은 자원과 시간 낭비이다.</p>

<p>낭비를 줄이기 위해 TCP는 윈도우 제어 방식에 따라 송신과 ACK 번호 통지의 동작을 실행한다.</p>

<p>윈도우 제어 방식이란 한 개의 패킷을 보낸 후 ACK 번호를 기다리지 않고 차례대로 연속해서 복수의 패킷을 보내는 방법을 말한다. 이럴 경우 ACK 번호가 돌아올 때까지의 시간이 낭비되지 않는다.</p>

<p>주의할 점은 ACK 번호를 기다리지 않고 차례로 패킷을 보내면 수신측의 능력을 초과하여 패킷을 보내는 사태가 발생할 수 있다.</p>

<p>수신측은 패킷을 수신하면 수신측 버퍼 메모리에 일시 보관한다. 수신측에서는 ACK 번호를 계산하는 작업이나 조각을 연결하여 원래 데이터를 복원하고 애플리케이션에 넘겨주어야 수신 버퍼에 저장된 데이터가 사용되어 사라진다. 하지만 송신측이 수신측의 처리속도보다 빠른 속도로 패킷을 송신하면 수신 버퍼에 데이터가 쌓이지 않고 사라질 수 있다.</p>

<p>이러한 문제를 방지하기 위해 수신측은 송신측에 수신가능한 데이터의 양을 통지한다. 수신 가능한 양은 TCP 헤더의 윈도우 필드에 기록하여 송신측에 알린다.</p>

<h3 id="6️⃣ack-번호와-윈도우를-합승한다"><strong>6️⃣ ACK 번호와 윈도우를 합승한다.</strong></h3>

<p>수신측은 네트워크 효율성 저하를 방지하기 위해 ACK 번호나 윈도우를 통지할 때 소켓을 바로 보내지 않고 잠시 기다린다. 기다리는 사이에 통지 동작이 발생하면 양쪽을 상승시켜서 한 개의 패킷으로 묶어서 전송한다.</p>

<p>예를 들자면 ACK 번호의 송신을 대조할 때 윈도우 통지가 발생하면 ACK 번호와 윈도우를 한개의 패킷에 합승 시켜서 통지하여 패킷의 수를 줄이는 것이다.</p>

<p>연속으로 ACK 번호 통지가 발생할 때도 마찬가지다. ACK 번호는 수신한 데이터의 끝이 어디인지를 송신측에 알리는 것이므로 ACK 번호가 통지가 연속적으로 발생하면 마지막 ACK 번호만 송신하고 나머지의 것은 생략해도 상관없다. 윈도우 통지도 마찬가지이다. 윈도우 통지가 연속적으로 발생하면 수신버퍼에 빈 공간이 늘어난다는 의미이므로 마지막 통지만 전달해도 문제가 발생하지 않는다.</p>

<h3 id="7️⃣http-응답-메세지를-수신한다"><strong>7️⃣ HTTP 응답 메세지를 수신한다.</strong></h3>

<p>HTTP 리퀘스트 메세지를 보내면 웹 서버에서 응답 메세지가 돌아오기를 기다리고, 응답 메세지가 돌아오면 그것을 수신한다.</p>

<p>데이터를 수신하면 수신한 데이터 조각과 TCP 헤더의 내용을 조사하여 누락된 데이터가 있는 지 검사하고 문제가 없으면 송신측에 ACK 번호를 반송한다. 그리고 데이터의 조각을 수신 버퍼에 일시 보관하고 데이터 조각을 연결하여 애플리케이션에게 건네준다. 이를 정확하게 설명하자면 수신 버퍼에 저장된 데이터를 애플리케이션 메모리 영역에 옮기고 제어권을 애플리케이션에게 되돌려준다.</p>

<h2 id="4-서버에서-연결을-끊어-소켓을-말소한다">4. 서버에서 연결을 끊어 소켓을 말소한다.</h2>

<h3 id="1️⃣데이터-보내기를-완료했을-때-연결을-끊는다"><strong>1️⃣ 데이터 보내기를 완료했을 때 연결을 끊는다.</strong></h3>

<p>데이터의 송 수신 동작이 완료되면 대상과의 연결을 끊는다. 이때 연결 끊기를 시도하는 대상은 서버나 클라이언트의 구분이 없다. 만약 서버에서 먼저 연결을 끊는다고 가정하면 서버측의 프로토콜 스택이 TCP 헤더를 생성하고 컨트롤비트인 FIN의 값을 1로 설정하여 클라이언트에게 전송한다. 이때 서버측은 소켓이 연결 끊기 동작에 들어갔다는 것을 기록한다. 서버에서 FIN을 설정한 TCP 헤더가 클라이언트에게 도착하면 클라이언트는 자신의 소켓에 서버가 연결끊기 작업에 들어갔다는 것을 기록하고 서버측에 FIN 값을 수신했다는 의미로 ACK 값을 전송한다.</p>

<p>클라이언트측 소켓이 애플리케이션에 데이터를 전부 전달하면 클라이언트측의 애플리케이션도 close를 호출하여 데이터 송 수신 동작을 중지한다. 그러면 클라이언트의 프로토콜 스택도 서버와 마찬가지로 TCP 헤더에 FIN 값을 1로 설정하여 서버측에 전송한다. 서버측에서 ACK 값이 되돌아오면 서버와의 대화는 끝이난 것이다.</p>

<p><strong>[연결 끊기 동작]</strong></p>

<ol>
  <li>클라이언트가 FIN 송신</li>
  <li>서버가 ACK 번호 송신</li>
  <li>서버가 FIN 송신</li>
  <li>클라이언트가 ACK 번호 송신</li>
</ol>

<p><strong>🌟  이때 연결 종료의 순서는 클라이언트와 서버가 서로 바뀔수도 있다.</strong> </p>

<h3 id="2️⃣소켓을-말소한다">2️⃣ 소켓을 말소한다.</h3>

<p>서버와의 대화가 끝나면 더이상 소켓을 사용하여 서버와 대화할 수 없다. 하지만 이때 바로 소켓을 말소시키면 ACK 번호의 응답이 늦어 FIN을 재전송 할 때 기록 정보가 제거되어 어느 소켓이 수신 대상인지 알 수 없게 된다. 뿐만아니라 동일한 포트로 새롭게 생성된 소켓이 FIN을 수신하여 오동작이 발생할 수 있다. 이러한 문제 때문에 소켓을 바로 말소하지 않고 일정시간 기다린 후 말소한다.</p>

<p><br />
<br /></p>

<h1 id="reference">Reference</h1>

<p><a href="https://velog.io/@anhesu11/HTTP-%EA%B8%B0%EB%B3%B8-%EC%9D%B4%EB%A1%A0-%EC%A0%95%EB%A6%AC">https://velog.io/@anhesu11/HTTP-기본-이론-정리</a></p>

<p>성공과 실패를 결정하는 1%의 네트워크</p>]]></content><author><name>GitHub User</name></author><category term="networkStudy" /><category term="3 way handshake" /><category term="4 way handshake" /><category term="Socket" /><category term="DNS" /><category term="TCP" /><category term="성공과 실패를 위한 네트워크 1%의 원리" /><summary type="html"><![CDATA[📗 Chapter_02 TCP/IP의 데이터를 전기 신호로 만들어 보낸다 🌟 2장의 요점 짚고 넘어가기 🌟]]></summary></entry><entry><title type="html">[운영체제 스터디] 가상 메모리와 Page Fault</title><link href="http://localhost:4000/os/2022/04/16/os-study-11.html" rel="alternate" type="text/html" title="[운영체제 스터디] 가상 메모리와 Page Fault" /><published>2022-04-16T00:00:00+09:00</published><updated>2022-04-16T00:00:00+09:00</updated><id>http://localhost:4000/os/2022/04/16/os-study-11</id><content type="html" xml:base="http://localhost:4000/os/2022/04/16/os-study-11.html"><![CDATA[<p>🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟</p>

<h1 id="️virtual-memory">🗳️ Virtual Memory</h1>

<blockquote>
  <p>물리적 메모리의 주소변환은 운영체제가 관여하지 않지만 Virtual Memory 기법은 운영체제가 관여한다.</p>

</blockquote>

<h2 id="1-demand-paging">1. Demand Paging</h2>

<blockquote>
  <p>실제로 사용자 프로그램에선 자주 사용되지 않는 코드가 대부분이다.</p>

  <p>Demand Paging 기법은 실제로 사용될 경우 메모리에 올리기 때문에 많은 프로세스를 메모리에 동시에 올릴 수 있다.</p>

  <p>Demand Paging 기법에선 무조건 한번은 page fault가 발생한다. (참조될 경우에 메모리에 올리기 때문)</p>

  <ul>
    <li>실제로 필요할 때 page를 메모리에 올리는 것
      <ul>
        <li>I/O 양의 감소
          <ul>
            <li>한정된 메모리 공간을 조금 더 효율적으로 사용할 수 있기 때문에 Disk 에서 읽어오는 일이 적어짐</li>
          </ul>
        </li>
        <li>Memory 사용량 감소</li>
        <li>빠른 응답 시간</li>
        <li>더 많은 사용자 수용</li>
      </ul>
    </li>
    <li>Valid / Invalid bit의 사용
      <ul>
        <li>Invalid 의 의미
          <ul>
            <li>사용되지 않는 주소 영역인 경우</li>
            <li>페이지가 물리적 메모리에 없는 경우</li>
          </ul>
        </li>
        <li>처음에는 모든 page entry가 invalid로 초기화</li>
        <li>address translation 시에 Invalid bit이 set되어 있으면
          <ul>
            <li>“page fault”</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<h2 id="2-page-fault">2. Page Fault</h2>

<ul>
  <li>invalid page를 접근하면 MMU가 trap을 발생시킴 (page fault trap)</li>
  <li>Kernel mode로 들어가서 page fault handler가 invoke됨</li>
  <li>다음과 같은 순서로 page fault를 처리한다.
    <ul>
      <li>invalid reference? (eg. bad address, protection violation) → abort process</li>
      <li>Get an empty frame (없으면 뺏어온다: 다른 페이지가 할당된 frame에 replace)</li>
    </ul>
  </li>
  <li>메모리를 획득하면 해당 페이지를 disk에서 momory로 읽어온다
    <ul>
      <li>disk I/O가 끝나기까지 이 프로세스는 CPU를 preempt 당함 (block)</li>
      <li>Disk read가 끝나면 page tables entry 기록, valid/invalid bit = “vaild”</li>
      <li>ready queue에 process를 insert → dispatch later</li>
      <li>이 프로세스가 CPU를 잡고 다시 running</li>
      <li>아까 중단되었던 instruction을 재개</li>
    </ul>
  </li>
</ul>

<p>✔️ <strong>Steps in Handling a Page Fault</strong></p>

<ol>
  <li>페이지 테이블 엔트리에 접근한다.</li>
  <li>접근한 엔트리의 Invalid bit이 invalid이면 trap을 발생시킨다.</li>
  <li>커널모드로 변경되어 page가 저장된 하드디스크에 접근한다.</li>
  <li>page를 비어있는 page frame으로 이동시킨다. 이때 비어있는 page frame이 존재하지 않을경우 다른 페이지가 할당된 frame에 replace한다</li>
  <li>새로 할당된 page frame number를 입력하고 invalid bit을 수정한다.</li>
  <li>trap에 의해 중단되었던 명령어를 다시 수행한다.</li>
</ol>

<p><img src="https://user-images.githubusercontent.com/56028408/162662911-5e53ed58-7416-496d-8f00-797fe1f456cc.png" alt="image" /></p>

<p><strong>✔️ Performace of Demand Paging</strong></p>

<ul>
  <li>Page Fault Rate  0≤ p ≤ 1.0
    <ul>
      <li>if p = 0 no page fault</li>
      <li>if p = 1, every reference is a fault</li>
    </ul>
  </li>
  <li>Effective Access Time
    <ul>
      <li>
        <p>(1 - p) x memory access + P (OS &amp; HW page fault overhead</p>

        <ul>
          <li>
            <p>[swap page out if needed]</p>
          </li>
          <li>
            <p>swap page in</p>
          </li>
          <li>
            <p>OS &amp; HW restart overhead)</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><strong>🌟   실제로 시스템에서  Page Fault Rate를 조사해본 결과 0.09 값이 측정된다. 즉 대부분의 경우는 메모리에서 직접 주소변환이 이뤄진다는 것이다.</strong></p>

<h3 id="22-empty-frame이-없는-경우">2.2 Empty Frame이 없는 경우</h3>

<p><strong>✔️  Page replacement</strong></p>

<ul>
  <li>어떤 frame을 빼앗아올지 결정해야 함</li>
  <li>곧바로 사용되지 않을 page를 쫓아내는 것이 좋음</li>
  <li>동일한 페이지가 여러번 메모리에서 쫓겨났다가 다시 들어올 수 있음</li>
  <li>운영체제의 역할</li>
</ul>

<p><strong>✔️  Replacement Algorithm</strong></p>

<ul>
  <li>page-fault rate을 최소화하는 것이 목표</li>
  <li>알고리즘의 평가
    <ul>
      <li>주어진 page reference string에 대해 page fault를 얼마나 내는지 조사</li>
    </ul>
  </li>
  <li>reference string
    <ul>
      <li>시간순서에 따라 나열된 page frame (참조된 순서로 나열됨)</li>
      <li>reference string의 예
        <ul>
          <li>1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><strong>✔️ Page Replacement 흐름</strong></p>

<ol>
  <li>swap out할 victim page를 선점하여 backing store에 swap out시킨다. 이때 변경사항이 있으면 변경된 내용을 저장하고 swap out한다.</li>
  <li>victim page가 저장되어있던 page table 엔트리의 valid/invalid bit를 invalid 로 수정한다</li>
  <li>swap out이 완료되면 victim page가 존재하던 frame에 trap을 발생시킨 page를 할당한다.</li>
  <li>새롭게 할당된 page가 존재하는 page table 엔트리의 frame number를 수정한다.</li>
</ol>

<p><strong>💡 victim page</strong></p>

<ul>
  <li>page replacement에 의해 swap out 되는 페이지를 victim page 라고 한다</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/56028408/162663269-0ad00235-1654-44ad-aa55-bb1e862cd25e.png" alt="image" /></p>

<h3 id="23-optimal-algorithm">2.3 Optimal Algorithm</h3>

<blockquote>
  <p>MIN(OPT): 가장 먼 미래에 참조되는 page를 replace</p>

</blockquote>

<p><strong>✔️ Optimal Alogrithm?</strong></p>

<ul>
  <li>미래의 참조를 어떻게 아는가?
    <ul>
      <li>미래를 모두 짐작해야하기 때문에 Offline algorithm 실제로 사용되진 않음</li>
    </ul>
  </li>
  <li>다른 알고리즘 성능에 대한 upper bound 제공
    <ul>
      <li>Belady’s optimal algorithm, MIN, OPT 등으로 불림</li>
    </ul>
  </li>
</ul>

<p><strong>✔️ Optimal Alogrithm 예시</strong></p>

<p><img src="https://user-images.githubusercontent.com/56028408/162663068-66b5c86c-af59-4cf2-bd73-7451c519efa3.png" alt="image" /></p>

<p><strong>[ 가정 ]</strong></p>

<ul>
  <li>빨간색 숫자는 page fault가 발생한 page</li>
  <li>연보라색 숫자는 메모리로 바로 참조되는 page</li>
</ul>

<p><strong>[ 예시 ]</strong></p>

<ol>
  <li>1,2,3,4번 page의 참조가 발생하여 메모리에 할당한다.</li>
  <li>1번과 2번 page가 메모리에서 바로 참조된다.</li>
  <li>다음 순서로 5번 page가 참조되어 page fault가 발생한다.</li>
  <li>이때 page frame은 모두 꽉 차있는 상태이므로 swap out할 page를 선점한다.</li>
  <li>가장 먼 미래에 참조되는 4번 page를 swap out한다.</li>
</ol>

<h3 id="24-fifo-first-in-first-out-algorithm">2.4 FIFO (First In First Out) Algorithm</h3>

<blockquote>
  <p>가장 먼저들어온 page를 내쫓는 알고리즘</p>

</blockquote>

<p>✔️ <strong>FIFO Anomaly (Belady’s Anomaly)</strong></p>

<ul>
  <li>more frames ≠ less page fault</li>
  <li>frame이 많을수록 page fault가 더 자주 일어난다.</li>
</ul>

<p><strong>✔️ FIFO (First In First Out) Algorithm 예시</strong></p>

<p><img src="https://user-images.githubusercontent.com/56028408/162662867-f815886e-bb6b-4e4f-847a-5db4b5d26653.png" alt="image" /></p>

<p><strong>[가정]</strong></p>

<ul>
  <li>빨간색 숫자는 page fault가 발생한 page</li>
  <li>연보라색 숫자는 메모리로 바로 참조되는 page</li>
</ul>

<p><strong>[예시]</strong></p>

<ol>
  <li>1,2,3 번 page가 참조되어 page fault가 발생한다.</li>
  <li>그 이후 4번 page가 참조되어 가장 먼저 들어온 1번 page가 swap out되고 4번 page가 할당된다.</li>
  <li>1번 page가 재참조되어 1번 다음으로 빨리 들어왔던 2번 page를 swap out하고 1번 page를 할당한다.</li>
  <li>가장 먼저 할당되었던 page를 swap out하면서 반복</li>
</ol>

<h3 id="25-lru-least-recently-used-algorithm">2.5 LRU (Least Recently Used) Algorithm</h3>

<blockquote>
  <p>LRU : 가장 오래 전에 참조된 것을 swap out 시키는 알고리즘</p>

  <p>가장 오래전에 참조된 알고리즘을 swap out하기 때문에 swap out 되는 page의 인지도는 체크하지 않는다. (여러번 참조되었냐의 여부 확인 안함)</p>

</blockquote>

<p><strong>✔️  LRU (Least Recently Used) Algorithm 예시</strong></p>

<p><img src="https://user-images.githubusercontent.com/56028408/162662841-9832b9ff-10e3-4dd8-a32e-8c837bc550d2.png" alt="image" /></p>

<p><strong>[가정]</strong></p>

<ul>
  <li>빨간색 숫자는 page fault가 발생한 page</li>
  <li>연보라색 숫자는 메모리로 바로 참조되는 page</li>
</ul>

<p><strong>[예시]</strong></p>

<ol>
  <li>1,2,3,4 번 page가 참조되어 page fault가 발생한다.</li>
  <li>1번과 2번 page를 직접 메모리에서 참조한다.</li>
  <li>5번 page가 page fault가 발생하여 오래전에 참조되었던 3번 page가 swap out 된다.</li>
  <li>가장 오래전에 참조되었던 page를 swap out하면서 반복</li>
</ol>

<h3 id="26-lfu-least-frequently-used-algorithm">2.6 LFU (Least Frequently Used) Algorithm</h3>

<blockquote>
  <p>LFU: 참조 횟수(reference count)가 가장 적은 페이지를 지움</p>

</blockquote>

<p>✔️  최저 참조 횟수인 page가 여럿 있는 경우</p>

<ul>
  <li>LFU 알고리즘 자체에서는 여러 page 중 임의로 선정한다</li>
  <li>성능 향상을 위해 가장 오래 전에 참조된 page를 지우게 구현할 수도 있다</li>
</ul>

<p>✔️  장단점</p>

<ul>
  <li>LRU처럼 직전 참조 시점만 보는 것이 아니라 장기적인 시간 규모를 보기 때문에 page의 인기도를 좀 더 정확히 반영할 수 있음</li>
  <li>참조 시점의 최근성을 반영하지 못함</li>
  <li>LRU보다 구현이 복잡함</li>
</ul>

<p><strong>✔️ LRU와 LFU 알고리즘 예제</strong></p>

<p> 
<img src="https://user-images.githubusercontent.com/56028408/162662834-97cd9c40-0a3b-443e-8a78-c37091d0fc31.png" alt="image" /></p>

<p><strong>[가정]</strong></p>

<ol>
  <li>page frame은 4칸이 존재함</li>
  <li>5번 page를 page fault 발생시켜야 하는 상황</li>
</ol>

<p><strong>[예시]</strong></p>

<ol>
  <li>1번 페이지가 가장 먼저 할당되었고 1번 페이지는 총 4번 참조되었다.</li>
  <li>1번 페이지 이후 2번 페이지가 할당되었고 2번 페이지는 총 3번 참조되었다.</li>
  <li>2번 페이지 이후 3번 페이지가 할당되었고 3번 페이지는 총 2번 참조되었다.</li>
  <li>마지막으로 4번 페이지가 할당되고 4번 페이지는 총 1번 참조되었다.</li>
</ol>

<p><strong>[결과]</strong></p>

<ul>
  <li>LRU : 가장 오래전에 참조된 1번 page를 삭제함</li>
  <li>LFU : 가장 최근에 할당되었음에도 적게 참조된 4번 page를 삭제함</li>
</ul>

<h3 id="28-paging-system에서-lru-lfu-가능한가">2.8 Paging System에서 LRU, LFU 가능한가?</h3>

<p>운영체제가 Page fault가 발생한 page를 물리적 메모리에 replace 한다. 그런데 비어있는 frame이 없을 경우 해당하는 알고리즘에 맞게  frame을 쫓아내야 하는데 이미 메모리에 해당 page가 존재할 경우 OS의 지원이 아닌 하드웨어 지원으로 주소변환이 일어나기 때문에 page의 참조 시간이나 page의 참조 횟수를 알 수 있는 방법이 없다. 즉 가상메모리 환경의 Page Fault 기법에서는 LRU, LFU 알고리즘을 사용할 수가 없다.</p>

<h3 id="29-clock-algorithm">2.9 Clock Algorithm</h3>

<blockquote>
  <p>LRU의 근사(approximation) 알고리즘</p>

</blockquote>

<p><img src="https://user-images.githubusercontent.com/56028408/163078507-2723e003-3bbf-419c-b93a-9414b7b08f0f.png" alt="image" /></p>

<p>✔️ Clock Algorithm</p>

<ul>
  <li>여러 명칭으로 불림
    <ul>
      <li>Second cahnge alogorithm</li>
      <li>NUR (Not Used Recently) 또는 NRU ( Not Recently Used)</li>
    </ul>
  </li>
  <li>Reference bit을 사용해서 교체 대상 페이지 선정 (circular list)</li>
  <li>reference bit가 0인 것을 찾을 때까지 포인터를 하나씩 앞으로 이동</li>
  <li>포인터 이동하는 중에 참조되지 않은 reference bit 1은 모두 0으로 바꿈</li>
  <li>Reference bit이 0인 것을 찾으면 그 페이지를 교체</li>
  <li>한 바퀴 되돌아와서도(=second chance) 0이면 그때에는 replace 당함</li>
  <li>자주 사용되는 페이지라면 second change가 올 때 1</li>
  <li>Clock algorithm의 개선
    <ul>
      <li>reference bit과 modified bit (dirty bit)을 함께 사용</li>
      <li>reference bit → 1 최근에 참조된 페이지</li>
      <li>modified bit(=dirty bit) → 1 최근에 변경된 페이지 (I/O를 동반하는 페이지)
        <ul>
          <li>메모리에서 write가 발생할 때 1로 세팅</li>
          <li>page fault를 발생시킬 때 modified bit가 0인 page들을 먼저 쫓아내면 disk I/O 수행시간이 적어지는 장점이 있음</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>🌟  <strong>이미 메모리에 할당된 페이지를 참조할 때  reference bit을 변경하는 것은 OS가 아니라 하드웨어의 역할이다. 운영체제는 비트를 주기적으로 검사하여 reference bit이 0인 page를 replace 하는 역할을 한다.</strong></p>

<h2 id="3-page-frame의-allocation">3. Page Frame의 Allocation</h2>

<p>💡  Allocation problem: 각 process에 얼마만큼의 page frame을 할당할 것인가?</p>

<p><strong>✔️ Allocation의 필요성</strong></p>

<ul>
  <li>메모리 참조 명령어 수행시 명령어, 데이터 등 여러 페이지 동시 참조
    <ul>
      <li>명령어 수행을 위해 최소한 할당되어야 하는 frame의 수가 있음</li>
    </ul>
  </li>
  <li>Loop를 구성하는 page들은 한꺼번에 allocate 되는 것이 유리함
    <ul>
      <li>최소한의 allcation이 없으면 매 loop 마다 page fault</li>
    </ul>
  </li>
</ul>

<p><strong>✔️ Allocation Scheme</strong></p>

<ul>
  <li>Equal allocation: 모든 프로세스에 똑같은 갯수 할당</li>
  <li>Proportional allocation: 프로세스 크기에 비례하여 할당</li>
  <li>Priority allocation: 프로세스의 priority에 따라서 다르게 할당</li>
</ul>

<h2 id="4-global-vs-local-replacement">4. Global vs Local Replacement</h2>

<p><strong>✔️ Global replacement</strong></p>

<ul>
  <li>Replace 시 다른 process에 할당된 frame을 빼앗아 올 수 있다</li>
  <li>Process별 할당량을 조절하는 또 다른 방법</li>
  <li>FIFO, LRU, LFU 등의 알고리즘을 global repacement로 사용시에 해당한다</li>
  <li>Working set, PFF 알고리즘 사용</li>
</ul>

<p><strong>✔️  Local Replacement</strong></p>

<ul>
  <li>자신에게 할당된 frame 내에서만 replacement</li>
  <li>FIFO, LRU, LFU 등의 알고리즘을 process 별로 운영시</li>
</ul>

<h2 id="5-다양한-캐싱-환경">5. 다양한 캐싱 환경</h2>

<p><strong>✔️ 캐싱 기법</strong></p>

<ul>
  <li>한정된 빠른 공간(=캐쉬)에 요청된 데이터를 저장해 두었다가 후속 요청시 캐쉬로부터 직접 서비스하는 방식</li>
  <li>paging system 외에도 cache memory, buffer caching, Web caching 등 다양한 분야에서 사용됨</li>
</ul>

<p><strong>✔️ 캐쉬 운영의 시간 제약</strong></p>

<ul>
  <li>교체 알고리즘에서 삭제할 항목을 결정하는 일에 지나치게 많은 시간이 걸리는 경우 실제 시스템에서 사용할 수 없음</li>
  <li>Buffer caching이나 Web caching의 경우
    <ul>
      <li>O(1)에서 O(log n) 정도까지 허용</li>
    </ul>
  </li>
  <li>Paging system인 경우
    <ul>
      <li>page fault인 경우에만 OS가 관여함</li>
      <li>페이지가 이미 메모리에 존재하는 경우 참조시각 등의 정보를 OS가 알 수 없음</li>
      <li>O(1)인 LRU의 list 조작조차 불가능</li>
    </ul>
  </li>
</ul>

<h2 id="6-thrashing">6. Thrashing</h2>

<blockquote>
  <p>프로세스의 원활한 수행에 필요한 최소한의 page frame 수를 할당 받지 못한 경우 발생하는 현상</p>

</blockquote>

<p><img src="https://user-images.githubusercontent.com/56028408/163078491-4d5715f3-ec1f-47a4-839d-f4f94ac0764a.png" alt="image" /></p>

<ol>
  <li>Page fault rate이 매우 높아짐</li>
  <li>CPU utillization이 매우 낮아짐</li>
  <li>OS는 MPD(Multiprogramming degree)를 높여아 한다고 판단</li>
  <li>또 다른 프로세스가 시스템에 추가됨 (higher MPD)</li>
  <li>프로세스당 할당된 frame의 수가 더욱 감소</li>
  <li>프로세스는 page의 swap in / swap out으로 매우 바쁨</li>
  <li>대부분의 시간에는 CPU가 한가함</li>
  <li>low throughput</li>
</ol>

<p><strong>✔️  대충 살펴봐도 프로세스 성능이 상당히 저하될 수 있는 현상이다. 이를 예방하기 위한 방법이 없을까?</strong></p>

<p> 있다 ! 앞서 설명한 Working set, PFF(Page-Fault Frequency) Scheme가 Thrashing 문제를 해결하기 위한 알고리즘이다.</p>

<h3 id="61-working-set-model">6.1 Working-Set Model</h3>

<p>✔️ Locality of reference</p>

<ul>
  <li>프로세스는 특정 시간 동안 일정 장소만을 집중적으로 참조한다.</li>
  <li>집중적으로 참조되는 해당 page들의 집합을 locality set이라 한다.</li>
</ul>

<p>✔️ Working-set Model</p>

<ul>
  <li>Locality에 기반하여 프로세스가 일정 시간 동안 원활하게 수행되기 위해 한꺼번에 메모리에 올라와 있어야하는 page들의 집합을 Working Set 이라고 정의한다.</li>
  <li>Working Set 모델에서는 process의 working set 전체가 메모리에 올라와 있어야 수행되고 그렇지 않을 경우 모든 frame을 반납한 후 swap out (suspend)</li>
  <li>Thrashing을 방지함</li>
  <li>Multiprogramming degree를 결정함</li>
</ul>

<h3 id="62-working-set-alogorithm">6.2 Working-Set Alogorithm</h3>

<p>✔️ <strong>Working set 결정 방법</strong></p>

<ul>
  <li>Working set window를 통해 알아낸다</li>
  <li>window size가 델타 인 경우
    <ul>
      <li>시각 t 에서의 working set WS (t)
        <ul>
          <li>Time interval [델타] 사이에 참조된 서로 다른 페이지들의 집합</li>
        </ul>
      </li>
      <li>Working set에 속한 page는 메모리에 유지, 속하지 않은 것은 버림 (즉, 참조된 후 델타 시간 동안 해당 page를 메모리에 유지한 후 버림)</li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/56028408/163078480-dbd22313-a45b-41cb-a30d-32a63203984e.png" alt="image" /></p>

<h3 id="63-pff-page-fault-frequency-scheme">6.3 PFF (Page-Fault Frequency) Scheme</h3>

<ul>
  <li>Page-fault rate의 상한값과 하한값을 둔다
    <ul>
      <li>Page fault rate이 상한값을 넘으면 frame을 더 할당한다</li>
      <li>Page fault rate이 하한값 이하이면 할당 frame 수를 줄인다.</li>
    </ul>
  </li>
  <li>빈 frame이 없으면 일부 프로세스를 swap out 한다</li>
</ul>

<h2 id="7-page-size의-결정">7. Page Size의 결정</h2>

<ul>
  <li>Page size를 감소시키면
    <ul>
      <li>페이지 수 증가</li>
      <li>페이지 테이블 크기 증가</li>
      <li>Internal fregmentation 감소</li>
      <li>Disk transfer의 효율성 감소
        <ul>
          <li>Seek/rotation vs transfer</li>
        </ul>
      </li>
      <li>필요한 정보만 메모리에 올라와 메모리 이용이 효율적
        <ul>
          <li>Locality의 활용 측면에서는 좋지 않음</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>✔️  현재 Trend</p>

<ul>
  <li>Larger page size</li>
</ul>

<h3 id="reference"><strong>Reference</strong></h3>

<hr />

<p>이화여자대학교 반효경 교수님 운영체제 강의</p>]]></content><author><name>GitHub User</name></author><category term="OS" /><category term="반효경" /><category term="가상 메모리" /><category term="요구 페이징" /><category term="page fault" /><summary type="html"><![CDATA[🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟]]></summary></entry><entry><title type="html">[운영체제 스터디] 불연속할당</title><link href="http://localhost:4000/os/2022/04/15/os-study-10.html" rel="alternate" type="text/html" title="[운영체제 스터디] 불연속할당" /><published>2022-04-15T00:00:00+09:00</published><updated>2022-04-15T00:00:00+09:00</updated><id>http://localhost:4000/os/2022/04/15/os-study-10</id><content type="html" xml:base="http://localhost:4000/os/2022/04/15/os-study-10.html"><![CDATA[<p>🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟</p>

<h1 id="️memory-management-2">🗳️ Memory Management 2</h1>

<h2 id="1-noncontiguous-allocation불연속할당">1. Noncontiguous allocation(불연속할당)</h2>

<blockquote>
  <p>불연속할당(noncontiguous allocation) 기법이란 하나의 프로세스가 물리적 메모리의 여러 위치에 분산되어 올라갈 수 있는 메모리 할당 기법을 말한다. 불연속할당 방식에는 하나의 프로그램을 분할하는 기준에 따라 동일한 크기로 나누어 메모리에 올리는 페이징 기법과, 크기는 일정하지 않지만 의미 단위(코드, 데이터, 스택 영역)로 나누어 메모리에 올리는 세그멘테이션 기법, 그리고 세그먼테이션을 기본으로 하되 이를 다시 동일 크기의 페이지로 나누어 메모리에 올리는 페이지드 세그먼테이션 기법 등이 있다.</p>

</blockquote>

<h3 id="11-paging">1.1 Paging</h3>

<blockquote>
  <p>페이징 기법은 프로세스의 가상 메모리를 동일한 크기의 Page로 잘라서 각 Page 별로 비어있는 물리적 메모리에 저장하는 방식을 말한다. 페이징 기법에서는 각 프로세스의 주소 공간 전체를 물리적 메모리에 한번에 올릴 필요없이 일부는 백킹스토어, 일부는 물리적 메모리에 혼재 시키는 것이 가능하다.</p>

  <p>페이징 기법에서는 물리적 메모리를 페이지 크기와 동일한 프레임으로 나누어두기 때문에 앞서 설명한 동적 메모리 할당 문제가 발생하지 않는다. 비어있는 공간이 모두 동일한 크기여서 어떠한 위치에도 저장할 수 있기 때문이다. 하지만 이러한 특징은 복잡한 주소변환 절차를 필요로 한다.</p>

</blockquote>

<p>✔️ <strong>하나의 Page의 크기는 4KB</strong></p>

<p>✔️  <strong>Paging 기법을 사용할 경우 해당 page의 **page table 주소와 논리적 주소를 물리적 메모리의 주소로 변환한다.</strong></p>

<p>1️⃣  <strong>Paging 기법의 주소변환 절차는 어떻게 이뤄지나?</strong></p>

<p>페이징 기법은 주소 변환이 페이지 단위로 이뤄져야 하기 때문에 조금 더 복잡한 주소변환 절차가 필요하다. 따라서 페이징 기법에서는 각각의 주소 변환을 위한 페이지 테이블을 가진다. 페이지 테이블은 프로세스가 가질 수 있는 페이지의 개수만큼 주소 변환 엔트리를 가지고 있으며, 엔트리는 페이지 번호와 페이지 오프셋으로 이루어져 있다. 추가로 페이지 테이블은 프로세스의 페이지 수 만큼 엔트리가 생성되기 때문에 큰 용량이 필요하여 메인 메모리에 저장된다.</p>

<h3 id="12-page-table">1.2 <strong>Page Table</strong></h3>

<blockquote>
  <p>페이지 테이블이란 Page의 물리적 메모리 주소 변환을 하기 위한 자료구조이다. 페이지 갯수만큼 엔트리가 생성되기 때문에 많은 용량을 필요로 하여 메인 메모리에 저장된다. CPU가 물리적 주소에 접근하려면 Page table을 거쳐서 Page Frame 까지 도달해야 하는데, 둘 다 메인 메모리에 저장되어 있기 때문에 메모리에 두 번 접근하게 되는 오버헤드가 발생한다. Page table의 문제점을 해결하기 위한 방법을 알아보자</p>

</blockquote>

<p>✔️ <strong>Page Table의 구성</strong></p>

<ul>
  <li><strong>Page-table base register (PTBR)</strong></li>
</ul>

<p>✔️  <strong>페이지 테이블만 있었을 때, 물리적 메모리 주소에 닿기까지 2번의 메모리 접근이 필요하다. 첫번째 접근은 CPU → Page Table 접근 두번째 접근은 Page Table → Page frame 접근이다.</strong></p>

<ul>
  <li>Page-table base register (PTBR)가 page table을 가리킴
    <ul>
      <li>메모리에 상주하고있는 page table의 시작위치</li>
    </ul>
  </li>
  <li>Page-table length register (PTLR)가 테이블 크기를 보관</li>
  <li>모든 메모리 접근 연산에는 2번의 memory acess 필요
    <ul>
      <li>page table 접근 1번, 실제 data/instruction 접근 1번</li>
    </ul>
  </li>
  <li>translation look-aside buffer (associative register or TLB)
    <ul>
      <li>속도 향상을 위해 사용되는 고속 lookup hardwore cache</li>
      <li>메모리 접근 연산이 2번 이뤄지는 비효율적인 접근방식을 보완함</li>
      <li>page table에서 접근이 자주 이뤄지는 엔트리를 캐싱하고 있음</li>
      <li>CPU가 캐싱되어있는 페이지 주소를 찾을 경우 CPU → TLB → Physical Memory</li>
      <li>TLB에 존재하지 않을 경우 CPU →  Page table(Physical Memory) → Physical Memory</li>
      <li>물리적 페이지와 논리적 페이지 주소의 쌍으로 이뤄져있음</li>
    </ul>
  </li>
</ul>

<p>Associative registers(TLB) : 병렬 검색이 가능</p>

<ul>
  <li>TLB에는 page table 중 일부만 존재</li>
</ul>

<p>Address translaction</p>

<ul>
  <li>page table 중 일부가 associative register에 보관되어 있음</li>
  <li>만약 해당 page가 associative register에 있는 경우 곧바로 frame #을 얻음</li>
  <li>그렇지 않은 경우 main memory에 있는 page table로 부터 frame #을 얻음</li>
  <li>TLB는 context switch 때 flush (remove old entries)</li>
</ul>

<h3 id="13-two-level-page-table">1.3 Two-Level Page Table</h3>

<ul>
  <li>속도는 느려지더라도 페이지 테이블의 크기를 줄이기 위한 방법이다.</li>
  <li>이단계 테이블에서는 page table 자체를 page로 구성한다.</li>
  <li>page table 자체를 page로 구성</li>
  <li>사용되지 않는 주소 공간에 대한 outer page table의 엔트리 값은 null (대응하는 inner page table이 없음)
    <ul>
      <li>현대의 컴퓨터는 address space가 매우 큰 프로그램 지원 (최근에는 64bit 구성도 많음)
        <ul>
          <li>32 bit address 사용 시: 2의 32승의 주소 공간이 필요하다 (4GB)
            <ul>
              <li>page size가 4K 시 1M개의 page table entry 필요</li>
              <li>각 page entry가 4B시 프로세스당 4M의 page table 필요</li>
              <li>그러나, 대부분의 프로그램은 4G의 주소 공간 중 지극히 일부분만 사용하므로 page table 공간이 심하게 낭비된다</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>🌟  이단계 페이지 테이블 예시 </p>

<p>✔️ Logical Address (on 32-bit machine with $K page size)의 구성</p>

<ul>
  <li>20 bit의 page number</li>
  <li>12 bit의 page offset</li>
</ul>

<p>✔️ Page table 자체가 page로 구성되기 때문에 page Number는 다음과 같이 나뉜다</p>

<p>(각 page table entry가 4B)</p>

<p>10 - bit의 page number</p>

<p>10 - bit의 page offset</p>

<p>따라서, logical address는 다음과 같다</p>

<p><img src="https://user-images.githubusercontent.com/56028408/162226691-ddf3845a-3807-44b6-bc68-92f05e7efb7b.png" alt="스크린샷 2022-04-07 오후 9 55 33" /></p>

<p>P1은 outer page table의 index이고</p>

<p>P2는 outer page table의 page에서의 변의(displacement)</p>

<p>✔️ 2단계 페이징에서의 Address-translation scheme</p>

<p><img src="https://user-images.githubusercontent.com/56028408/162226209-7f026927-267b-4194-8b4e-cb4721f16f8a.png" alt="image" /></p>

<ol>
  <li>논리적 주소에서 outer table 의 index 번호를 찾는다.</li>
  <li>outer table에서 P1값에 위치로 이동한 후 inner page table 엔트리의 위치 값을 가져온다.</li>
  <li>outertable에서 inner page table로 이동한다.</li>
  <li>inner table에서 P2값에 해당하는 엔트리로 이동한 후 저장된 물리적 페이지 프레임 주소를 얻게된다.</li>
</ol>

<p>inner table의 크기는 4KB로 페이지의 크기와 동일하다.</p>

<p>이단계 테이블은 속도는 느리더라도 페이지 테이블의 공간을 줄이는 것이 목적인 반면에</p>

<p>여전히 inner table의 엔트리는 100만개 이상이 필요하다. 추가적으로 outer table 과 inner table로 구성되어 있어서 공간과 시간이 기존 page table에 비해서 더 손해이다.</p>

<p>하지만 그럼에도 이단계 테이블을 사용하는 이유는 ?!</p>

<p>프로그램을 구성하는 공간에서 사용되는 페이지의 수는 얼마 안되지만 페이지 테이블은 실제 사용하는 페이지의 수가 적더라도 논리적 메모리의 최대 크기만큼 엔트리를 생성한다. 그런데 이단계 페이지 테이블은 outer page table은 논리적 메모리 크기만큼 생성하지만 실제 사용이 되지않는 엔트리는 Null로 할당하고 inner table의 엔트리를 생성하지 않는다.</p>

<p>실제 프로그램은 프로그램이 사용되지 않더라도 4KB의 메모리 공간을 전부 채운다.</p>

<h3 id="14-multilevel-paging-and-performance">1.4 Multilevel Paging and Performance</h3>

<blockquote>
  <p>주소공간이 더 커지면 다단계 페이지 테이블이 필요하다 다단계 테이블은 단계별로 페이지 테이블이 메모리에 존재하므로 logical address의 physical address 변환에 더 많은 메모리 접근이 필요하다 하지만 이러한 문제점은 TLB를 통하여 접근시간을 줄일 수 있다.</p>

</blockquote>

<p>✔️ 4단계 페이지 테이블을 사용하는 경우</p>

<ul>
  <li>메모리 접근 시간이 100ns, TLB 접근 시간이 20ns이고</li>
  <li>TLB hit ratio가 98%인 경우
    <ul>
      <li>effective memory access time = 0.98 x 120 + 0.02 x 520 = 128 nanoseconds
        <ul>
          <li>결과적으로 주소변환을 위해 28ns만 소요한다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="1️⃣-memory-protection">1️⃣  Memory Protection</h3>

<blockquote>
  <p>Page table의 각 entry 마다 아래의 bit를 둔다.</p>

</blockquote>

<p><strong>✔️ Protection bit</strong></p>

<ol>
  <li>Page에 대한 접근 권한 (read/write/read-only)
    <ol>
      <li>페이지 테이블은 프로세스 마다 각각 생성되므로 다른 프로세스가 Page에 접근하는 것을 막기위한 것이 아니라 연산에 대한 접근 권한을 의미한다</li>
      <li>예를 들면 코드영역은 실행도중 변경되면 안되므로  read-only 권한을 부여하고 데이터나 스택영역에는 read, write 권한을 부여한다.</li>
    </ol>
  </li>
</ol>

<p>✔️ <strong>Valid (v) / Invalid (i) Bit in a Page Table</strong></p>

<ol>
  <li>valid-invalid bit
    <ul>
      <li>Valid (v)
        <ul>
          <li>Page 0을 예로 들면 Page 0이 실제로 2의 주소를 가진 Page frame에 할당된 것을 의미함 (실제로 페이지가 물리적 메모리에 존재한다)</li>
        </ul>
      </li>
      <li>Invalid (i)
        <ul>
          <li>해당 주소의 frame에 유효한 내용이 없을을 의미한다 (접근 불허)
            <ol>
              <li>프로세스가 그 주소 부분을 사용하지 않는 경우</li>
              <li>해당 페이지가 메모리에 올라와 있지 않고 swap area에 있는 경우</li>
            </ol>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<p><img src="https://user-images.githubusercontent.com/56028408/162225826-33165124-98fc-409b-8174-0d0c05b8b653.jpeg" alt="257F2E3C5757C75D31 (1)" /></p>

<h3 id="14-inverted-page-table-역방향-페이지-테이블">1.4 Inverted Page Table (역방향 페이지 테이블)</h3>

<blockquote>
  <p>Page table은 실행되는 프로세스마다 독립적으로 생성되기 때문에 메모리를 많이 차지한다. 하지만 <strong>Inverted Page Table</strong>은 기존 Page table과 다르게 모든 프로세스가 <strong>Inverted Page Table</strong>을 참조하게 하는 방식이다. <strong>Inverted Page Table은</strong> Page Frame 기준으로 엔트리를 생성한다.</p>

</blockquote>

<p>💡 Page table이 매우 큰 이유</p>

<ul>
  <li>모든 process 별로 그 logical address에 대응하는 모든 page에 대해 page table entry가 존재</li>
  <li>대응하는 page가 메모리에 있든 아니든 간에 page table에는 entry로 존재</li>
</ul>

<p>✔️ <strong>Inverted page table (역방향 페이지 테이블)</strong></p>

<ul>
  <li>Page frame 하나당 page table에 하나의 entry를 둔 것 (system-wide)</li>
  <li>메모리 공간을 확보하기 위해 사용 됨</li>
  <li>역방향 페이지 테이블의 엔트리는 논리적인 페이지 번호와 Pid를 저장하고 있음</li>
  <li>단점
    <ul>
      <li>테이블 전체를 탐색해야 함</li>
    </ul>
  </li>
  <li>조치
    <ul>
      <li>associative register 사용 (expensive)</li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/56028408/162448838-96f5d704-d018-488d-922f-d1fc7a285b12.png" alt="image" /></p>

<p>✔️  <strong>주소변환과정</strong></p>
<ul>
  <li>Page Table에서 pid와 page number로 해당 정보가 저장된 엔트리의 위치를 찾는다</li>
  <li>찾아진 엔트리가 몇번째 위치에 존재하는지 확인하고 해당 주소의 페이지 프레임을 찾는다.</li>
  <li>각 page tavle entry는 각각의 물리적 메모리의 page frame이 담고 있는 내용 표시 (process-id, process의 logical address)</li>
</ul>

<h3 id="15-shard-page">1.5 Shard Page</h3>

<p>✔️ <strong>Shared code</strong></p>

<ul>
  <li>Re-entrant Code (=Pure code)
    <ul>
      <li>read-only로 하여 프로세스 간에 하나의 code만 메모리에 올림 (eg, text, editors, compliers, winodw, systems)</li>
    </ul>
  </li>
  <li>Shared code는 모든 프로세스의 logical address space에서 동일한 위치에 있어야 함 (동일한 page number를 가져야함)</li>
  <li>Private code and data
    <ul>
      <li>각 프로세스들은 독자적으로 메모리에 올림</li>
      <li>Private data는 logical address space의 아무 위치에 할당되어도 무방</li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/56028408/162453156-7a30193b-5690-4a92-a534-37d952e26fd0.png" alt="image" /></p>

<p><strong>✔️ 예를 들면?</strong></p>

<p>서로 다른 프로세스 P1, P2, P3가 동일한 코드를 사용하다면 코드를 프로세스마다 각각 올리는 것은 비효율 적이다.  즉 공유할 수 있는 코드는 별도로 올리는 것이 아니라 같은 Frame으로 매핑하여 한칸의 Page Frame 만을 할당하는 것이 효율적이라고 할 수 있다. 하지만 모든 프로세스가 같은 코드영역을 참조하고 있기 때문에 공유하는 코드영역은 read-only로 설정해야한다. 그리고 공유코드는 프로세스가 다르더라도 동일한 logical address를 가져야한다.</p>

<h2 id="2-segmentation">2. Segmentation</h2>

<blockquote>
  <p>프로그램은 의미 단위인 여러 개의 segment로 구성</p>

  <ul>
    <li>작게는 프로그램을 구성하는 함수 하나하나를 세그먼트로 정의</li>
    <li>크게는 프로그램 전체를 하나의 세그먼트로 정의 가능</li>
    <li>일반적으로는 code,data,stack 부분이 하나씩의 세그먼트로 정의됨</li>
  </ul>

  <p>Paging 방식처럼 동일한 크기로 분할하는 것이 아니라 동적 메모리 할당 문제가 발생할 수 있다.</p>

</blockquote>

<p>✔️ <strong>Segment는 다음과 같은 logical unit 들</strong></p>

<ul>
  <li>main()</li>
  <li>function</li>
  <li>global variables</li>
  <li>stack</li>
  <li>symbol table, arrays</li>
</ul>

<h3 id="21-segmentation-architecture">2.1 Segmentation Architecture</h3>

<p>✔️  Logical address 구성</p>

<ul>
  <li>segment-number, offset</li>
</ul>

<p>✔️ Segment table</p>

<ul>
  <li>each table entry has:
    <ul>
      <li>base - starting physical address of the segment</li>
      <li>limit - length of ther segment</li>
    </ul>
  </li>
</ul>

<p>✔️ Segment-table base register (STBR)</p>

<ul>
  <li>물리적 메모리에서의 segment table의 위치</li>
</ul>

<p>✔️ Segment-table length register (STLR)</p>

<ul>
  <li>프로그램이 사용하는 segment의 수
    <ul>
      <li>segment number의 크기는 STLR의 범위를 넘어서면 안됨</li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/56028408/162457379-518ac837-ad86-4c43-81e5-5d4980bfc828.png" alt="image" /></p>

<p><strong>✔️ Segmentation의 주소변환</strong></p>

<ol>
  <li>논리주소의 SegmentNumber가 STLR보다 작은 값인지 확인하고 만약 더 큰 값을 요청했다면 trap을 발생시킨다.</li>
  <li>값이 STLR 범위에 포함될 경우 offset의 값이 segment의 메모리 범위안에 포함되는 지 확인한다</li>
  <li>포함되는 값이면 Segment 시작위치와 Offset을 더해, 물리적 메모리 주소의 위치를 찾는다.</li>
</ol>

<h3 id="22-sharing-of-segments">2.2 Sharing of Segments</h3>

<p><img src="https://user-images.githubusercontent.com/56028408/162607258-d2d5e09d-aef6-45ed-8a06-5aebb18dff41.png" alt="image" /></p>

<p><strong>✔️ Sharing of Segments</strong></p>

<p>첨부된 이미지를 보면 segment0은 프로세스 P1, P2가 서로 공유하여 사용하고 있다. 
하나의 세그먼트를 여러개의 프로세스가 사용할 경우 각 프로세스들은 segment0에 대해 동일한 논리적메모리 주소를 가져야한다.
반면 각 프로세스마다 따로 사용하는 private segment의 경우 각자 다른 물리적 메모리 주소에 위치해있기 때문에 프로세스마다 논리적 메모리 주소도 동일하지 않아도 된다.</p>

<h3 id="23-paged-segmentation">2.3 Paged Segmentation</h3>

<blockquote>
  <p>Paged Segmentation은 Segmentation과 Paging 기법의 장점만을 가져와서 각 기법의 단점들을 보완한 방식이다.</p>

  <p>무슨 말이냐 하면, Segmentation의 의미있는 단위로 프로그램을 나누는 방식과 Paging 기법의 동일한 크기로 프로그램을 나눈다는 장점이 합쳐진 것이다.</p>

  <p>Paged Segmentation기법에서는 segment가 임의의 길이를 가진 것이 아닌 동일한 크기의 page들의 집합으로 구성되어 있다. 물리적 메모리에 적재하는 단위도 page 단위이기 때문에 외부조각 문제가 발생하지 않는다. 기존 Segmentation 방식과의 차이점은 segment table entry가 segment의 base address를 가지고 있는 것이 아니라 segment를 구성하는 page table의 base address를 가지고 있다는 것이다.</p>

</blockquote>

<p><img src="https://user-images.githubusercontent.com/56028408/162607255-5f3ac626-a6cc-448c-bf26-1fae59baf8da.png" alt="image" /></p>

<p>✔️  <strong>Paged Segmentation</strong></p>

<ul>
  <li>Paged Segmentation 기법에선 주소 변환을 위해 외부의 세그먼트 테이블과 내부의 세그먼트 테이블을 이용한다.</li>
  <li>하나의 세그먼트가 여러개의 페이지 테이블로 구성되기 때문에 각 세그먼트마다 페이지 테이블을 가진다.</li>
</ul>

<p>✔️  <strong>Paged Segmentation의 주소변환 과정</strong></p>

<ol>
  <li>논리적 주소의 상위 비트인 세그먼트 번호를 통해 세그먼트 테이블의 해당 항목으로 접근한다. (논리적 주소에서는 세그먼트 번호와 offset이 존재)
    <ol>
      <li>접근한 세그먼트 항목에는 세그먼트 길이와 그 세그먼트의 페이지 테이블 시작 주소가 들어 있다.</li>
    </ol>
  </li>
  <li>세그먼트 길이값과 논리적 주소 하위 비트인 offset 값을 비교하고 offset값이 더 크다면 유효하지 않은 접근이므로 트랩을 발생시킨다.</li>
  <li>그렇지 않은 경우 offset 값을 다시 상위 비트와 하위비트로 나눈다. (상위 비트는 세그먼트 내의 페이지 번호로 사용하고 하위 비트는 페이지 내의 변위로 사용한다)</li>
  <li>세그먼트 테이블에 저장된 해당 세그먼트를 위한 페이지 테이블의 시작 위치를 확인했으므로 그 위치에서 페이지 번호만큼 떨어진 페이지 테이블 항목으로부터 물리적 메모리의 페이지 프레임 위치를 얻게 된다.</li>
  <li>해당 페이지 프레임 위치에서 offset의 하위 비트값인 페이지 내 변위만큼 떨어진 곳이 물리적 메모리 주소이다.</li>
</ol>

<h2 id="memory-management에서-운영체제의-역할은">💡 Memory Management에서 운영체제의 역할은?</h2>

<p>없다. 앞서 설명한 내용들은 운영체제가 아닌 하드웨어들의 역할이다. 왜냐하면 프로세스가 CPU를 할방받으면서 메모리에 접근하는 것은 운영체제가 도움을 주는 것이 아니기 때문이다. 만약 메모리에 접근할 때 사용자 프로그램이 운영체제를 필요로하게 된다면, 사용자 프로그램이 메모리에 접근을 시도할 때마다 사용자 모드에서 커널모드로 변경되는 매우 비효율적인 작업이 진행될 것이다. 사용자 프로그램이 운영체제의 도움이 필요할 때는 메모리 접근이 아닌 I/O device 접근이다.</p>

<h3 id="reference"><strong>Reference</strong></h3>

<hr />

<p>이화여자대학교 반효경 교수님 운영체제 강의</p>]]></content><author><name>GitHub User</name></author><category term="OS" /><category term="반효경" /><category term="불연속할당" /><category term="페이징" /><category term="세그멘테이션" /><category term="Invalid Bit / Protection Bit" /><summary type="html"><![CDATA[🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟]]></summary></entry><entry><title type="html">[운영체제 스터디] 메모리 관리 - 논리적 주소와 물리적 주소</title><link href="http://localhost:4000/os/2022/04/15/os-study-09.html" rel="alternate" type="text/html" title="[운영체제 스터디] 메모리 관리 - 논리적 주소와 물리적 주소" /><published>2022-04-15T00:00:00+09:00</published><updated>2022-04-15T00:00:00+09:00</updated><id>http://localhost:4000/os/2022/04/15/os-study-09</id><content type="html" xml:base="http://localhost:4000/os/2022/04/15/os-study-09.html"><![CDATA[<p>🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟</p>

<h1 id="️memory-management-1">🗳️ Memory Management 1</h1>

<h2 id="1-논리적-주소와-물리적-주소">1. 논리적 주소와 물리적 주소</h2>

<p><strong>✔️  논리적 주소란(Logical address)?</strong></p>

<ul>
  <li>프로세스마다 독립적으로 가지는 주소 공간</li>
  <li>각 프로세스마다 0번지부터 시작</li>
  <li>CPU가 보는 주소는 <strong>logical address</strong>이다.</li>
</ul>

<p><strong>✔️  물리적 주소란(Logical address)?</strong></p>

<ul>
  <li>실제 메모리에 올라가는 위치</li>
</ul>

<h3 id="12-주소-바인딩address-binding">1.2 주소 바인딩(Address Binding)</h3>

<blockquote>
  <p>프로세스의 물리적 메모리 주소를 결정하는 것</p>

  <p>Symbolic Address → Logical Address → Physical Address</p>

  <p>🌟 <strong>Symbolic Address?</strong> 프로그래머가 사용하는 심볼릭한 주소</p>

</blockquote>

<p>✔️ <strong>사용자 프로그램</strong></p>

<ul>
  <li>logical address만을 다룬다</li>
  <li>실제 physical address를 볼 수 없으며 알 필요가 없다</li>
</ul>

<p>✔️ <strong>Compile time binding</strong></p>

<ul>
  <li>물리적 메모리 주소(physical address)가 컴파일 시 알려짐</li>
  <li>시작 위치 변경시 재컴파일</li>
  <li>컴파일러는 절대 코드(absolute code) 생성</li>
</ul>

<p>❗ <strong>논리적 메모리 주소가 물리적 메모리의 주소가 되므로 여유있는 메모리 공간이 있어도 고정적인 메모리 주소를 갖기 때문에 비효율적</strong></p>

<p>✔️  <strong>Load time binding</strong></p>

<ul>
  <li>프로그램 실행 시 물리적 주소가 결정되는 방식</li>
  <li>컴파일러가 재배치 가능한 코드를 생성한 경우 발생 가능</li>
</ul>

<p>✔️  <strong>Run time binding</strong></p>

<ul>
  <li>프로그램 실행 도중 물리적 메모리 주소가 변경될 수 있는 방식</li>
  <li>CPU가 주소를 참조할 때마다 binding을 점검해야 함 (address mapping table)</li>
  <li>하드웨어적인 지원이 필요함
    <ul>
      <li>(base and limit registers, <strong>MMU</strong>)</li>
    </ul>
  </li>
  <li>현대에서 주로 사용되는 방식</li>
</ul>

<p>✔️ <strong>Memory-Management Unit (MMU)?</strong></p>

<ul>
  <li>MMU
    <ul>
      <li>logical address를 physical address로 매핑해 주는 Hardware device</li>
    </ul>
  </li>
  <li>MMU scheme
    <ul>
      <li>사용자 프로세스가 CPU에서 수행되며 생성해내는 모든 주소값에 대해 base register (=relocation register)의 값을 더한다</li>
    </ul>
  </li>
</ul>

<p>💡 <strong>운영체제 및 사용자 프로세스 간의 메모리 보호를 위해 사용하는 레지스터</strong></p>

<ul>
  <li>relocation register
    <ul>
      <li>프로세스의 물리적 메모리 시작위치를 저장한다 (접근할 수 있는 물리적 메모리 주소의 최소값)</li>
    </ul>
  </li>
  <li>limit register
    <ul>
      <li>물리적 메모리 주소의 한계영역을 지정하기 위해 프로그램의 최대 크기를 저장한다.</li>
      <li>논리적 주소의 범위 (프로그램의 최대 크기)
        <ul>
          <li>예를 들어 P1의 시작 주소가 14000이고 프로그램의 크기가 3000일 때 P1은 14000~17000 사이만 접근할 수 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="2-some-terminologies">2. Some Terminologies</h2>

<h3 id="1-dynamic-loading">1. Dynamic Loading</h3>

<ul>
  <li>프로세스 전체를 메모리에 미리 다 올리는 것이 아니라 해당 루틴이 불려질  때 메모리에 load하는 것</li>
  <li>memory utilization의 향상</li>
  <li>가끔식 사용되는 많은 양의 코드의 경우 유용
    <ul>
      <li>ex) 오류 처리 루틴</li>
    </ul>
  </li>
  <li>운영체제의 특별한 지원 없이 프로그램 자체에서 구현 가능(OS는 라이브러리를 통해 프로그래머를 지원함)</li>
</ul>

<h3 id="2-overlays">2. Overlays</h3>

<ul>
  <li>메모리에 프로세스의 부분 중 실제 필요한 정보만을 올림</li>
  <li>프로세스의 크기가 메모리보다 클 때 유용</li>
  <li>운영체제의 지원없이 사용자에 의해 구현</li>
  <li>작은 공간의 메모리를 사용하던 초창기 시스템에서 수작업으로 프로그래머가 구현
    <ul>
      <li>Manual Overlay</li>
      <li>프로그래밍이 매우 복잡함</li>
      <li>Dynamic Loading과 비슷한 역할을 하지만 OS의 지원이 하나도 없다는 점에서 차이가 있음</li>
    </ul>
  </li>
</ul>

<h3 id="3-dynamic-linking">3. Dynamic Linking</h3>

<p>Linking을 실행 시간(execution time)까지 미루는 기법</p>

<p>✔️ <strong>Static Linking</strong></p>

<ul>
  <li>라이브러리가 프로그램의 실행 파일 코드에 포함됨</li>
  <li>실행 파일의 크기가 커짐</li>
  <li>동일한 라이브러리를 각각의 프로세스가 메모리에 올리므로 메모리 낭비
    <ul>
      <li>ex) printf를 호출하는 n개의 프로세스가 있으면 동일한 라이브러리여도 각각 printf 함수의 라이브러리를 메모리에 올리게 됨</li>
    </ul>
  </li>
</ul>

<p>✔️ <strong>Dynamic linking</strong></p>

<ul>
  <li>라이브러리가 실행시 연결(link)됨</li>
  <li>라이브러리 호출 부분에 라이브러리 루틴의 위치를 찾기 위한 stub이라는 작은 코드를 둠</li>
  <li>라이브러리가 이미 메모리에 있으면 그 루틴의 주소로 가고 없으면 디스크에서 읽어옴</li>
  <li>운영체제의 도움이 필요함</li>
  <li>Dynamic linking을 지원하는 라이브러리를 shared library 라고 함
    <ul>
      <li>window → DLL</li>
      <li>linux → shared object</li>
    </ul>
  </li>
</ul>

<h3 id="4-swapping">4. Swapping</h3>

<blockquote>
  <p>프로세스를 일시적으로 메모리에서 backing store로 쫓아내는 것</p>

  <ul>
    <li><strong>Backing store(=swap area)?</strong>
      <ul>
        <li>디스크
          <ul>
            <li>많은 사용자의 프로세스 이미지를 담을 만큼 충분히 빠르고 큰 저장 공간</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>✔️ <strong>Swap in / Swap out</strong></p>

<ul>
  <li>일반적으로 중기 스케줄러(swapper)에 의해 swap out 시킬 프로세스 선정</li>
  <li>priority-based CPU scheduling algorithm
    <ul>
      <li>CPU 우선순위가 낮은 프로세스를 swapped out 시킴</li>
      <li>CPU 우선순위가 높은 프로세스를 메모리에 올려놓음</li>
    </ul>
  </li>
  <li>Complie time 혹은 load time binding에서는 다른 메모리 공간이 비어있더라도 원래 메모리 위치로 swap in 해야 함</li>
  <li>Execution time binding에서는 추후 빈 메모리 영역 아무 곳에나 올릴 수 있음</li>
  <li>swap time은 대부분 transfer time(swap되는 양에 비례하는 시간)임</li>
  <li>원칙적으로 프로세스 전체가 메모리에서 쫓겨나는 것을 Swap out 이라고 하지만 프로세스 일부분이 쫓겨나는 것도 swap out 이라고 부르기도 한다.</li>
</ul>

<h2 id="3-물리적-메모리-관리">3. 물리적 메모리 관리</h2>

<p>✔️ <strong>메모리는 일반적으로 두 영역으로 나눠어서 사용 됨</strong></p>

<ul>
  <li>OS 상주 영역(커널)
    <ul>
      <li>interrupt vector와 함께 낮은 주소 영역 사용</li>
    </ul>
  </li>
  <li>사용자 프로세스 영역</li>
</ul>

<p>✔️ <strong>사용자 프로세스 영역의 할당 방법</strong></p>

<ul>
  <li><strong>Contiguous allocation(연속할당)</strong>
    <ul>
      <li>각각의 프로세스가 메모리의 연속적인 공간에 적재되도록 하는 것
        <ul>
          <li>Fixed partition allocation</li>
          <li>Variable partition allocation</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Noncontiguous allocation(불연속할당)</strong>
    <ul>
      <li>현대 시스템의 사용 방법</li>
      <li>하나의 프로세스가 메모리의 여러 영역에 분산되어 올라갈 수 있음
        <ul>
          <li>Paging</li>
          <li>Segmentation</li>
          <li>Paged Segmentation</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>✔️ <strong>외부조각과 내부조각</strong> </p>

<ul>
  <li>External fragmentation(외부 조각)
    <ul>
      <li>프로그램 크기보다 분할의 크기가 작은 경우</li>
      <li>아무 프로그램에도 배정되지 않은 빈 곳인데도 프로그램이 올라갈 수 없는 작은 분할</li>
    </ul>
  </li>
  <li>Internal Fragmentation(내부 조각)
    <ul>
      <li>프로그램 크기보다 분할의 크기가 큰 경우</li>
      <li>하나의 분할 내부에서 발생하는 사용되지 않는 메모리 조각</li>
      <li>분할에 배정된 프로그램보다 분할의 크기가 더 커서 생기는 사용되지 않는 메모리 공간</li>
    </ul>
  </li>
</ul>

<h2 id="4-contiguous-allocation연속할당">4. Contiguous allocation(연속할당)</h2>

<h3 id="41-fixed-partition고정분할">4.1 <strong>Fixed partition(고정분할)</strong></h3>

<ul>
  <li>물리적 메모리를 몇 개의 영구적 분할(partition)으로 나눔</li>
  <li>분할의 크기가 모두 동일한 방식과  서로 다른 방식이 존재</li>
  <li>분할당 하나의 프로그램 적재</li>
  <li>융통성이 없음
    <ul>
      <li>동시에 메모리에 load되는 프로그램의 수가 고정됨</li>
      <li>최대 수행 가능 프로그램 크기 제한</li>
    </ul>
  </li>
  <li>internal fragmentation(=내부조각) 과  external fragmentation(=외부조각) 발생</li>
</ul>

<h3 id="42-variable-partition가변분할">4.2 <strong>Variable partition(가변분할)</strong></h3>

<ul>
  <li>프로그램의 크기를 고려해서 할당</li>
  <li>분할의 크기, 개수가 동적으로 변함</li>
  <li>기술적 관리 기법 필요</li>
  <li>external fragmentation(=외부조각) 발생</li>
</ul>

<p>1️⃣  <strong>Hole</strong></p>

<ul>
  <li>가용 메모리 공간</li>
  <li>다양한 크기의 hole들이 메모리 여러 곳에 흩어져 있음</li>
  <li>프로세스가 도착하면 수용가능한 hole을 할당</li>
  <li>운영체제는 다음의 정보를 유지
    <ul>
      <li>a) 할당 공간 b) 가용 공간(hole)</li>
    </ul>
  </li>
</ul>

<p>2️⃣  <strong>Dynamic Storage-Allocation Problem</strong></p>

<ul>
  <li>가변 분할 방식에서 size n인 요청을 만족하는 가능 적절한 hole을 찾는 문제</li>
  <li><strong>First-fit</strong>
    <ul>
      <li>Size가 n 이상인 것 중 최초로 찾아지는 hole에 할당</li>
      <li>셋 중 오버헤드가 가장 적음</li>
    </ul>
  </li>
  <li><strong>Best-fit</strong>
    <ul>
      <li>Size가 n 이상인 가장 작은 hole을 찾아서 할당</li>
      <li>Hole들의 리스트가 크기순으로 정렬되지 않은 경우 모든 hole의 리스트를 탐색해야함</li>
      <li>많은 수의 아주 작은 hole들이 생성됨</li>
    </ul>
  </li>
  <li><strong>Worst-fit</strong>
    <ul>
      <li>가장 큰 hole에 할당</li>
      <li>역시 모든 리스트를 탐색해야 함</li>
      <li>상대적으로 아주 큰 hole들이 생성됨</li>
    </ul>
  </li>
</ul>

<p><strong>🌟 First-fit과 Best-fit이 Worst-fit보다 속도와 공간 이용률 측면에서 횩하적인 것으로 알려짐 (실험적 결과)</strong></p>

<p>3️⃣  <strong>Compaction</strong></p>

<ul>
  <li>external fragmentation 문제를 해결하는 한 가지 방법</li>
  <li>사용 중인 메모리 영역을 한군데로 몰고 hole들을 다른 한 곳으로 몰아 큰 block을 만드는 것</li>
  <li>전체 프로그램 바인딩과 관련되어 있기 때문에 비용이 많이 듬</li>
  <li>최소한의 메모리 이동으로 compaction하는 방법 (매우 복잡한 문제)</li>
  <li>Compcation은 프로세스의 주소가 실행 시간에 동적으로 재배치 가능한 경우에만 수행될 수 있다.
    <ul>
      <li>Runtime binding이 지원되어야 사용 가능함</li>
    </ul>
  </li>
</ul>

<h3 id="reference"><strong>Reference</strong></h3>

<hr />

<p>이화여자대학교 반효경 교수님 운영체제 강의</p>]]></content><author><name>GitHub User</name></author><category term="OS" /><category term="반효경" /><category term="메모리관리" /><category term="운영체제" /><category term="가변분할" /><category term="외부조각과 내부조각" /><summary type="html"><![CDATA[🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟]]></summary></entry></feed>