<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-04-14T22:58:31+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">나비랑 나리 주인님의 블로그</title><subtitle>Spring back-end</subtitle><author><name>ramram</name></author><entry><title type="html">[네트워크 스터디] Chapter_01 웹 브라우저가 메세지를 만든다</title><link href="http://localhost:4000/networkstudy/network-study-01/" rel="alternate" type="text/html" title="[네트워크 스터디] Chapter_01 웹 브라우저가 메세지를 만든다" /><published>2022-04-14T00:00:00+09:00</published><updated>2022-04-14T00:00:00+09:00</updated><id>http://localhost:4000/networkstudy/network-study-01</id><content type="html" xml:base="http://localhost:4000/networkstudy/network-study-01/"><![CDATA[<h1 id="-chapter_01-웹-브라우저가-메세지를-만든다">📗 Chapter_01 웹 브라우저가 메세지를 만든다</h1>
<h2 id="1-http-리퀘스트-메세지를-작성한다"><strong>1. HTTP 리퀘스트 메세지를 작성한다</strong></h2>

<h3 id="1️⃣-url"><strong>1️⃣  URL</strong></h3>

<p><strong>✔️ HTTP URL 의 구성</strong></p>

<p>ex ) <a href="http://user:passwork@www.cyber.co.kr">http://user:password@www.example.co.kr</a>:80/dir/file1.html</p>

<ul>
  <li>프로토콜 →  http</li>
  <li>사용자명 (생략 가능) → user</li>
  <li>패스워드 (생략 가능) → password</li>
  <li>웹 서버의 도메인명 → <a href="http://www.example.co.kr">www.example.co.kr</a></li>
  <li>포트번호 (생략 가능) → 80</li>
  <li>파일의 경로명 → /dir/file1.html</li>
</ul>

<p><strong>💡 HTTP 의 경우 기본 포트는 80이고 HTTPS의 기본 포트는 443이다.</strong></p>

<p><br /></p>

<p>✔️ <strong>URL 은 여러 종류가 있다.</strong></p>

<p>URL은 http로 구성되어있는 것 말고도 ftp: 나 mailto: 같은 다양한 프로토콜의 URL이 존재한다. 이유는, 브라우저는 웹 서버에 엑세스하는 클라이언트로만 사용하는 것이 아니라 파일을 다운로드/업로드하는 FTP의 기능이나</p>

<p>메일클라이언트의 기능도 가지고 있기 때문이다. 브라우저는 URL을 토대로 여러개의 기능 중 어느것을 사용하여 데이터에 엑세스하면 될지를 판단한다.</p>

<p><br /></p>

<p><strong>✔️ 다양한 URL의 구성</strong></p>

<p><img src="https://user-images.githubusercontent.com/56028408/163106926-34b4cb16-6547-41bb-b016-0b2c4e6b081a.png" alt="image" /></p>

<p>이와같이 쓰는 방법은 다양하지만 모든 URL에는 하나의 공통점이 있다. URL 맨 앞에 있는 프로토콜에 따라서 액세스 하는 대상이 달라진다는 것이다.</p>

<p>예를 들어 액세스 대상이 웹 서버라면 HTTP 프로토콜을 사용하고, FTP 서버라면 FTP, 메일을 송신할 때는 mailto 프로토콜을 사용하면 된다.</p>

<p><br /></p>

<h3 id="2️⃣--브라우저의-url-해독-방식">2️⃣  <strong>브라우저의 URL 해독 방식</strong></h3>

<p>웹 서버에 보내는 리퀘스트 메세지를 작성하기 전에 URL을 해독한다. 아래 내용은 브라우저가 웹 서버에 엑세스하는 경우를 예로들어 설명한다.</p>

<p><strong>URL을 요소별로 분리하여 나열한 것은 아래와 같다.</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">http</span><span class="o">:</span><span class="c1">//www.example.co.kr](http://user:passwork@www.cyber.co.kr):80/dir/file1.html</span>
<span class="p">[</span> <span class="n">http</span> <span class="p">]</span><span class="o">:</span> <span class="o">+</span> <span class="p">[</span> <span class="c1">// ] + [ 웹 서버명 ] + [ / ] + [ 디렉토리명 ] +[ / ] + .... + [ 파일명 ]   </span>
</code></pre></div></div>

<p>http는 앞서 설명한 프로토콜이 되는 것이고 //는 나중에 이어지는 문자열이 서버의 이름임을 나타낸다.</p>

<p>웹 서버명 다음에 이어지는 것은 서버에 파일이 저장된 위치인데 이는 생략이 가능하다.</p>

<hr />

<p><strong>✔️  파일명을 생략한 경우</strong></p>

<p>ex) <a href="http://user:passwork@www.cyber.co.kr">http://www.example.co.kr</a></p>

<p>예시 url은 파일명을 생략했을 때의 url이다. 파일명을 생략하면 서버가 어느 파일에 액세스해야 하는 지 알 수 없다.</p>

<p>그래서 이와같은 문제를 대비하여 서버에서 파일명이 생략되었을 때 액세스할 default 파일을 설정해둔다. 대부분의 서버는 index.html 이나 default.html 이라는 파일명으로 설정해둔다.</p>

<p><strong>💡  브라우저가 가장 먼저 하는 일은 URL 해독이다.</strong></p>

<h3 id="3️⃣http의-기본-개념">3️⃣ HTTP의 기본 개념</h3>

<blockquote>
  <p>Hyper-Text Transfer Protocol(HTTP)란 지정된 규약을 지켜 웹 서버와 데이터를 주고받는 서버/클라이언트 모델을 따르는 비연결성 &amp; 무상태 프로토콜이다.</p>

  <p>애플리케이션 레벨의 프로토콜로 TCP/IP 위에서 작동한다. HTTP 패킷에는 여러 메타데이터와 성공 실패 정보가 담겨있으므로 서버와 클라이언트가 원활하게 대화할 수 있다.</p>

</blockquote>

<p><strong>💡  비연결성</strong></p>

<p>연결을 유지하지 않는 것  특정한 옵션을 주면 일정시간동안 연결을 유지할 수는 있다.</p>

<p><strong>💡  무상태</strong></p>

<p>서버가 클라이언트의 상태를 보존하지 않는 것 매번 요청에 모든 상태값들을 전달해줘야 함 상태를 유지해줘야 할 경우 쿠키나 세션을 사용 함</p>

<p><br /></p>

<p><strong>✔️ HTTP Reuqest 패킷 구성</strong></p>

<p><img src="https://user-images.githubusercontent.com/56028408/163209206-2d7e3008-230e-4da7-9041-453bcfa2d23d.png" alt="image" /></p>

<p>HTTP 요청 패킷은 크게 요청라인, 메세지 정보, 본문으로 나눌 수 있다.</p>

<ul>
  <li>요청라인 → HTTP Method, URL, HTTP 버전</li>
  <li>메세지 정보 → 해당 요청에 대한 메타데이터를 담고있는 공간</li>
  <li>본문(body) → 해당 요청의 실제 내용. POST가 아니여도 body를 사용할 수 있지만, 주로 Body를 사용하는 메소드는 POST이다.</li>
</ul>

<p><br /></p>

<p><strong>✔️ HTTP Response 패킷 구성</strong></p>

<p><img src="https://user-images.githubusercontent.com/56028408/163209182-d49ace5d-d8c1-4e7b-aa31-976c9cdbafb5.png" alt="image" /></p>

<p>HTTP 응답 패킷은 크게 상태라인, 메세지 정보, 본문으로 나눌 수 있다.</p>

<ul>
  <li>상태라인 → HTTP Method, 버전, 응답코드
    <ul>
      <li>응답코드는 주로 권한과 서버에러, 클라이언트에러 등으로 나눠서 성공과 실패 여부를 판단하는데에 사용된다,</li>
    </ul>
  </li>
  <li>메세지 정보 → 해당 응답에 대한 메타데이터를 담고있는 공간</li>
  <li>본문(body) → 요청의 Body와 일반적으로 동일하다. body 존재할 수도 있고 존재하지 않을수도 있다. 가장 많이 사용되는 Body의 데이터 타입은 JSON(JavaScript Object Notation)이다.</li>
</ul>

<p><br /></p>

<p><strong>✔️ HTTP Method</strong></p>

<p>HTTP 메소드를 정리한 표이다. 버전마다 지원되는 메소드가 다르다.</p>

<table>
  <thead>
    <tr>
      <th>메소드</th>
      <th>의미</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>GET</td>
      <td>지정한 정보를 도출할 때 사용된다. 파일의 경우 해당 파일의 내용을 되돌려보낸다.</td>
    </tr>
    <tr>
      <td>POST</td>
      <td>클라이언트에서 데이터를 body에 담아 송신할 때 사용된다.</td>
    </tr>
    <tr>
      <td>PUT</td>
      <td>URI로 지정한 서버의 파일을 치환한다. 파일이 없는 경우 새로 등록한다.</td>
    </tr>
    <tr>
      <td>DELETE</td>
      <td>URL로 지정한 서버의 파일을 삭제한다.</td>
    </tr>
    <tr>
      <td>PATCH</td>
      <td>리소스의 일부분만을 수정하는데에 쓰인다.</td>
    </tr>
    <tr>
      <td>OPTION</td>
      <td>통신 옵션을 통지하거나 조사할 때 사용된다.</td>
    </tr>
    <tr>
      <td>HEAD</td>
      <td>GET과 거의 같지만 데이터의 내용을 돌려보내지 않고 HTTP 메세지 헤더만을 반송한다. 속성 정보를 조사할 때 사용된다.</td>
    </tr>
    <tr>
      <td>TRACE</td>
      <td>서버측에서 받은 리퀘스트 라인과 헤더를 그대로 클라이언트에 반송한다. 프록시 서버 등을 사용하는 환경에서 리퀘스트가 치환되는 상태를 조사할 떄 사용된다.</td>
    </tr>
    <tr>
      <td>CONNECT</td>
      <td>암호화한 메세지를 프록시로 전송할 때 이용된다.</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p><strong>✔️ HTTP 간단한 통신과정 예시</strong></p>

<p><img src="https://user-images.githubusercontent.com/56028408/163209168-f37b8432-03fc-4dbf-883e-001f24d63871.png" alt="image" /></p>

<ol>
  <li>웹서버에 특정 리소스를 얻기 위해 URI와 헤더에 요청에 필요한 정보를 담아 서버에 전송한다.</li>
  <li>해당 리소스가 존재하면 응답 헤더에 필요한 정보를 담아서 보내거나 바디에 해당 요청 데이터를 전송한다.</li>
</ol>

<p>🌟 <strong>실제로 요청과 응답 사이에 검증절차나 여러가지 일들이 일어나지만 자세한 내용은 생략하겠다.</strong></p>

<h2 id="2-웹-서버의-ip-주소를-dns-서버에-조회한다">2. 웹 서버의 IP 주소를 DNS 서버에 조회한다</h2>

<blockquote>
  <p>HTTP 메세지를 만드는 것에 성공하면 이것을 OS에 의뢰하여 액세스 대상의 웹 서버에게 송신한다.</p>

  <p>브라우저는 URL을 해독하거나 HTTP 메세지를 만들 수는 있지만 메세지를 네트워크에 송출하는 기능은 없으므로 OS에 의뢰하는 것이다.</p>

  <p>이때 URL 안에 쓰여있는 서버의 도메인 명에서 IP 주소를 조사해야하는데, 이는 OS에서 송신을 의뢰할때는 도메인명이 아니라 IP 주소로 메세지를 받을 상대를 지정해야하기 때문이다.</p>

</blockquote>

<p><strong>✔️  도메인명과 IP 주소를  구분하여 사용하는 이유</strong></p>

<p>TCP/IP 네트워크는 IP 주소로 통신 상대를 지정하므로 IP주소를 모르는 상대에게 메세지를 전달할 수 없다. 이러한 이유 때문에 도메인 명과 IP 주소를 구분하는 것이다. 웹 브라우저는 Socket 라이브러리를 사용하여 도메인 명으로 IP 주소를 조회한다. 
그렇다면 URL 안에서는 서버명이 아니라 IP 주소를 사용하는 것이 더 효율적이라는 생각이 들 수 있다. 실제로 서버명 대신에 IP 주소를 사용해도 올바르게 작동한다.그렇지만 기억하기 어렵다는 단점이 있다. 실행 효율 관점에서 바라보면 IP 주소대신 도메인명으로 사용하는 것이 좋은 방법이라고 할 수 없다. IP 주소는 32비트로 4바이트에 해당하는 개수밖에 없지만, 도메인 명은 수십 바이트 부터 최대 255 바이트 까지 존재한다. 그러면 그만큼 라우터가 부하되어 데이터를 운반하는 동작에 더 많은 시간이 걸릴 것이다. 하지만 이름을 알면 IP 주소를 알 수 있다거나 IP 주소를 사용하면 이름을 알 수있다는 원리를 이용하여 양쪽의 차이를 해소한 DNS가 라우터 부하의 문제점을 해결해준다.</p>

<p><br /></p>

<p><strong>✔️ Socket 라이브러리의 IP 주소 조회</strong></p>

<p>웹 브라우저는 Socket 라이브러리의 도움을 받아 DNS서버에서 도메인명의 IP 주소를 조회할 수 있다.</p>

<p>DNS 서버에서 조회한다는 것은 DNS 서버에 메세지를 보내고 반송되는 응답 메세지를 받는 것이다. 이것은 DNS 클라이언트로 동작한다고 말할 수 있다. DNS 클라이언트에 해당되는 것을 DNS 리졸버(=리졸버)라고 한다.</p>

<p>DNS 원리를 이용하여 IP 주소를 조사하는 것을 네임 리졸루션 (name resolution) 이라고 하는데 리졸루션을 수행하는 것이 리졸버이다.</p>

<p><br /></p>

<p><strong>💡 Socket 라이브러리</strong></p>

<ul>
  <li>OS를 이용하여 네트워크의 기능을 호출하기 위한 프로그램의 부품집</li>
</ul>

<p><br /></p>

<h3 id="️리졸버-내부의-작동">✔️ 리졸버 내부의 작동</h3>

<p><img src="https://user-images.githubusercontent.com/56028408/163209513-02792b34-4c07-4427-9ed5-0f0a68b403ce.png" alt="image" /></p>

<p>✔️  <strong>리졸버를 이용하여 DNS 서버를 조회한다.</strong></p>

<p>리졸버의 프로그램명(gethostbyname)과 웹 서버의 이름을 쓰기만 하면 리졸버를 호출할 수 있다. </p>

<ol>
  <li>브라우저 애플리케이션이 Socket 라이브러리의 리졸버를 호출한다. 이때 gethostbyname에 웹서버 이름을 전달한다.</li>
  <li>리졸버가 DNS 서버에 조회 메세지를 보낸다. 메세지 송신 동작은 OS 내부의 프로토콜 스택을 호출하여 수행한다.</li>
  <li>DNS 서버에서 돌아온 응답 메세지를 수신한다.</li>
  <li>응답 메세지에서 IP 주소를 추출하고 메모리 영역에 저장한 뒤 애플리케이션으로 돌아간다.</li>
</ol>

<p><br /></p>

<p>🌟  DNS 서버에 메세지를 송신할 때도 DNS 서버의 IP 주소가 필요한데, 이는 컴퓨터의 TCP/IP 설정 항목의 하나로 컴퓨터에 미리 설정되어 있다. </p>

<h2 id="3-전-세계의-dns-서버가-연대한다">3. 전 세계의 DNS 서버가 연대한다</h2>

<h3 id="1️⃣-dns-서버의-기본동작">1️⃣ <strong>DNS 서버의 기본동작</strong></h3>

<p>DNS 서버의 기본 동작은 클라이언트에서 조회 메세지를 받고 조회의 내용에 응답하는 형태로 정보를 회답하는 일이다.</p>

<p><br /></p>

<p><strong>✔️  조회 메세지 구성</strong></p>

<ul>
  <li>이름
    <ul>
      <li>서버의 메일 배송 목적지와 같은 이름, 도메인 명</li>
    </ul>
  </li>
  <li>클래스
    <ul>
      <li>네트워크 종류를 검토하기위해 사용되는 것 현재는 인터넷 외의 네트워크는 소멸되었기 때문에 항상 인터넷을 나타내는 IN 값이 전달된다</li>
    </ul>
  </li>
  <li>타입
    <ul>
      <li>이름에 어떤 타입의 정보가 지원되는지를 나타낸다. 타입이 A이면 이름에 IP 주소가 지원되는 것을 나타내고 MX이면 이름에 메일 배송 목적지가 지원된다는 것을 나타낸다. 타입에 따라 클라리언트에 회답하는 정보의 내용이 달라진다.</li>
    </ul>
  </li>
</ul>

<p>이름이 <a href="http://www.example.com">www.example.com</a> 인 서버의 IP 주소를 조사할 때 클라이언트는 다음과 같은 메세지를 보낸다.</p>

<p>해당 메세지를 수신했을 때 DNS가 어떠한 동작을 하는지 알아보자</p>

<p><br /></p>

<p><strong>[요청 메세지 예시 ]</strong></p>

<ul>
  <li>이름 = www.example.com</li>
  <li>클래스 = IN</li>
  <li>타입 = A</li>
</ul>

<p><br /></p>

<p><strong>[DNS 서버 내부 등록 정보 예시]</strong></p>

<table>
  <thead>
    <tr>
      <th>이름</th>
      <th>클래스</th>
      <th>타입</th>
      <th>클라이언트에 회답하는 항목</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>www.example.com</td>
      <td>IN</td>
      <td>A</td>
      <td>192.168.2.5</td>
    </tr>
    <tr>
      <td>example.com</td>
      <td>IN</td>
      <td>MX</td>
      <td>192.168.2.6</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p><strong>[DNS 서버의 동작]</strong></p>

<ol>
  <li>DNS가 메세지를 수신하면 DNS 서버는 이름, 클래스, 타입의 값이 일치하는 데이터를 찾는다.</li>
  <li>일치하는 데이터가 있으면 요청 값에 맞는 데이터를 클라이언트에게 전송한다. (예제를 기준으로 하면 192.168.2.5)</li>
</ol>

<p> <strong>💡  DNS 서버는 서버에 등록된 도메인명과 IP 주소의 대응표를 조사하여 IP 주소를 회답한다.</strong></p>

<p><br /></p>

<h3 id="2️⃣-도메인의-계층">2️⃣  도메인의 계층</h3>

<blockquote>
  <p>인터넷에선 막대한 수의 서버가 존재하기 때문에 모든 도메인 명을 하나의 DNS 서버에 등록하는 것은 불가능하다.</p>

  <p>이러한 문제점은 정보를 분산시켜 다수의 DNS 서버에 등록하는 방식으로 해결할 수 있다. 다수의 DNS 서버는 계층적으로 구성되어있는데, 이는 조회 메세지를 수신한 DNS 서버에 해당 정보가 등록되어 있지 않아도 계층적으로 연대하고 있는 다른 DNS 서버에서 찾을 수 있다.</p>

</blockquote>

<p>DNS 서버에 등록된 모든 정보는 모든 도메인명이라는 계층적 구조를 가진 이름이 붙여져 있다. DNS에서 취급하는 이름은 <a href="http://www.example.com">www.example.com</a> 처럼 점으로 구분되어 있는데, 점으로 게층을 구분한다. 오른쪽에 위치한 것이 상위 계층이다. 계층구조와 같은 형태로 DNS 서버가 배치되며,  각 계층은 각자의 DNS 서버에 저장된다.</p>

<p><br /></p>

<p><strong>[계층 구조 예시]</strong></p>

<p>URL → <a href="http://www.example.com">www.example.com</a></p>

<p>오른쪽에 위치한 것이 상위 계층이다.</p>

<ul>
  <li>com
    <ul>
      <li>example
        <ul>
          <li>www</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>✔️  담당 DNS 서버를 찾아 IP 주소를 가져온다</strong></p>

<blockquote>
  <p>인터넷에는 DNS 서버가 수만 대가 있으므로 닥치는 대로 이를 뒤지면서 해당 도메인의 IP를 찾을 수는 없다.</p>

  <p>그래서 다음과 같은 방법으로 이를 해결한다.</p>

</blockquote>

<h4 id="예시"><strong>[예시]</strong></h4>

<p>URL → <a href="http://www.example.com">www.example.com</a></p>

<p>예시 URL 기준으로 최상위 도메인은 com이다. 하지만 실제로 URL은 com이나 kr 위에 루트 도메인이 존재한다. 루트 도메인은 com이나 kr같은 도메인 명이 존재하지 않기 때문에 보통 도메인을 쓸 때는 이것을 생략한다. 명시적으로   <a href="http://www.example.com">www.example.com</a>. 처럼 URL 끝에 마침표를 찍기도 하지만 보통은 그렇게 사용하지 않는다.</p>

<ol>
  <li>하위의 도메인을 담당하는 DNS 서버의 IP 주소를 상위의 DNS 서버에 등록한다. </li>
  <li>상위의 DNS 서버를 또 그 상위의 DNS 서버에 등록한다.</li>
  <li>상위의 DNS 서버가 존재하면 이를 반복한다.</li>
</ol>

<p>💡 <strong>이러한 방식은 상위 DNS 서버에서 하위의 DNS 서버의 IP 주소를 알 수 있다. (루트 도메인을 모든 DNS 서버에 등록하면 루트 도메인의 모든 하위 DNS 서버를 조회할 수 있음)</strong></p>

<p><br /></p>

<h4 id="ip-조회"><strong>[IP 조회]</strong></h4>

<p><img src="https://user-images.githubusercontent.com/56028408/163209731-4d525bc3-91f4-4d27-8a0e-e297b3456a1a.png" alt="image" /></p>

<ol>
  <li>가장 가까운 DNS 서버에게 해당 도메인 명의 IP를 요청한다.</li>
  <li>IP가 등록되어있지 않을 경우 루트 도메인 서버에게 해당 IP를 요청한다.</li>
  <li>루트 도메인에도 해당 IP가 등록되지 않았을 경우 하향식으로 접근하여 IP를 찾을 때까지 하위 도메인 서버에 해당 IP 정보를 요청한다.</li>
</ol>

<p><br /></p>

<p>💡  <strong>앞서 설명한 내용은 기본이 되는 동작을 설명한 것으로 현실의 인터넷과 모든 동작이 일치하진 않는다. 현실의 인터넷은 한 대의 DNS 서버에 복수의 DNS 서버를 등록할 수 있으므로 한 도메인에 한대씩 DNS 서버가 존재한다고 단정할 수 없다.</strong></p>

<h3 id="3️⃣dns-서버는-캐시-기능으로-빠르게-회답할-수-있다">3️⃣  DNS 서버는 캐시 기능으로 빠르게 회답할 수 있다.</h3>

<p>DNS 서버는 한번 조사한 도메인 명을 캐싱할 수 있다. 요청받은 도메인 명이 캐싱되어 있으면 캐싱되어 있는 정보를 전달한다. 정보가 없을 경우에도 캐싱하기 때문에 정보가 존재하지 않는 다는 것도 빠르게 회답할 수 있다. 하지만 캐시된 정보가 변경될 수도 있으므로 캐시안에 저장된 정보를 올바르다고 단언할 수는 없다.</p>

<h2 id="4-프로토콜-스택에-메시지-송신을-의뢰한다">4. <strong>프로토콜 스택에 메시지 송신을 의뢰한다</strong></h2>

<p>IP 주소를 조사를 마치면 액세스 대상 웹 서버에 메세지를 송신하도록 OS 내부 프로토콜 스택에 의뢰한다.</p>

<p>이 동작에서도 Socket 라이브러리를 사용하는데, 복수의 부품을 결정된 순서대로 호출해야하므로 복잡하다.</p>

<p><br /></p>

<p>🌟 <strong>Socket 라이브러리를 이용한 데이터 송 수신 동작</strong></p>

<p><img src="https://user-images.githubusercontent.com/56028408/163209131-ddef6b53-6743-413a-abae-c4b862dcfde6.png" alt="image" /></p>

<ol>
  <li>서버측에서 소켓을 생성하고 클라이언트가 파이프를 연결하기를 기다린다. (소켓 생성 단계)</li>
  <li>클라이언트가 서버측 소켓에 파이프를 연결한다 (소켓 접속 단계)</li>
  <li>연결이 성공하면 데이터를 송 수신 한다 (송 수신 단계)</li>
  <li>송 수신 동작이 끝나면 파이프 연결을 해제한다. (연결은 클라이언트, 서버 둘 중 어느 쪽에서 분리해도 상관없다.)</li>
</ol>

<p><br /></p>

<p><strong>🌟  결정된 순서대로 Socket 라이브러리를 호출하는 애플리케이션 예시</strong></p>

<p><img src="https://user-images.githubusercontent.com/56028408/163209107-a08c09a6-c0f1-4509-b64c-adae70159364.png" alt="image" /></p>

<ul>
  <li>socket()
    <ul>
      <li>소켓을 생성하고 완료되면 제어권을 애플리케이션에게 넘긴다. 소켓이 생성되면 <strong>디스크립터</strong>가 반환되는데, 이는 소켓을 식별하기 위한 식별자의 용도로 사용된다.</li>
    </ul>
  </li>
  <li>connect()
    <ul>
      <li>디스크립터, 서버의 IP 주소, 포트번호 세 가지 값을 입력하여 특정 소켓에 연결을 요청한다.</li>
    </ul>
  </li>
  <li>wirte()
    <ul>
      <li>송신 데이터를 메모리에 할당하고 wirte() 함수를 호출할 때 디스크립터와 송신데이터를 지정한다. 소켓에는 연결된 상대가 기록되어 있으므로 디스크립터로 소켓을 지정하면 연결된 상대가 판명된다.</li>
    </ul>
  </li>
  <li>read()
    <ul>
      <li>메세지를 수신할 때 사용된다. 수신한 응답메세지는 수신 버퍼에 저장된다. 수신버퍼는 애플리케이션 내부에 마련된 메모리 영역이므로 수신 버퍼에 메세지를 저장한 시점에 애플리케이션에게 메세지를 넘겨준다.</li>
    </ul>
  </li>
  <li>close()
    <ul>
      <li>메세지 송 수신이 완료되면 연결을 종료하는 함수 만약 read 동작을 수행하고 있는 도중에 연결이 종료되면 수신한 데이터를 건네주고 연결을 종료한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>🌟  디스크립터  =  애플리케이션이 소켓을 식별하는 용도</strong></p>

<p><strong>🌟  IP와 포트번호  = 클라이언트와 서버 간에 상대의 소켓을 식별하는 용도</strong></p>

<p><strong>🌟  요청에는 하나의 리소스 정보만을 표시하고 있기 때문에 여러 파일의 정보를 읽으려면 요청을 각각 보내야한다. 요청을 각각 보내면 매번 TCP Connection 을 새로 맺어야하는데, 이는 비효율적일 수 있다. 그래서 HTTP 1.1 버전부터 일정시간동안 연결을 유지할 수 있는 옵션이 추가되었다.</strong></p>

<p><br />
<br /></p>

<h1 id="reference">Reference</h1>

<p><a href="https://velog.io/@anhesu11/HTTP-%EA%B8%B0%EB%B3%B8-%EC%9D%B4%EB%A1%A0-%EC%A0%95%EB%A6%AC">https://velog.io/@anhesu11/HTTP-기본-이론-정리</a></p>

<p>성공과 실패를 결정하는 1%의 네트워크</p>]]></content><author><name>ramram</name></author><category term="networkStudy" /><category term="HTTP" /><category term="Socket" /><category term="DNS" /><category term="TCP" /><category term="성공과 실패를 위한 네트워크 1%의 원리" /><summary type="html"><![CDATA[📗 Chapter_01 웹 브라우저가 메세지를 만든다 1. HTTP 리퀘스트 메세지를 작성한다]]></summary></entry><entry><title type="html">[운영체제 스터디] 데드락과 데드락 발생조건 4가지</title><link href="http://localhost:4000/os/os-study-08/" rel="alternate" type="text/html" title="[운영체제 스터디] 데드락과 데드락 발생조건 4가지" /><published>2022-04-04T00:00:00+09:00</published><updated>2022-04-04T00:00:00+09:00</updated><id>http://localhost:4000/os/os-study-08</id><content type="html" xml:base="http://localhost:4000/os/os-study-08/"><![CDATA[<p>🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟</p>

<h1 id="️deadlock">⚠️ Deadlock</h1>

<p>✔️ Deadlock</p>

<ul>
  <li>이련의 프로세스들이 서로가 가진 자원을 기다리며 block된 상태</li>
</ul>

<p>✔️ Resource(자원)</p>

<ul>
  <li>하드웨어, 소프트웨어 등을 포함하는 개념</li>
  <li>(예) I/O device. CPU cycle, memory space, semaphore 등</li>
  <li>프로세스가 자원을 사용하는 절차
    <ul>
      <li>요청 (Request),획득 (Allocate),사용 (Use), 반납 (Release)</li>
    </ul>
  </li>
</ul>

<h2 id="1-deadlock-발생의-4가지-조건">1. Deadlock 발생의 4가지 조건</h2>

<p>✔️ Mutual exclusion (상호배제)</p>

<ul>
  <li>매 순간 하나의 프로세스만이 자원을 사용할 수 있음</li>
</ul>

<p>✔️ No Preemption(비선점)</p>

<ul>
  <li>프로세스 자원을 스스로 내어놓을 뿐 강제로 빼앗기지 않음</li>
</ul>

<p>✔️ Hold and wait</p>

<ul>
  <li>내가 가진 자원은 양보하지 않으면서 다른 프로세스의 자원을 기다리면서 보유 자원을 내놓지않고 계속 가지고 있는 현상</li>
</ul>

<p>✔️ Circular wait</p>

<ul>
  <li>자원을 기다리는 프로세스간에 사이클이 형성되어야 함</li>
  <li>프로세스 P0, P1 …… P5 이 있을 때
    <ul>
      <li>P0은 P1에 가진 자원을 기다림</li>
      <li>P1은 P2가 가진 자원을 기다림</li>
      <li>P2는 P3가 가진 자원을 기다림</li>
      <li>P4는 P0이 가진 자원을 기다림</li>
    </ul>
  </li>
</ul>

<h2 id="2-resource-allocation-graph-자원할당-그래프">2. Resource-Allocation Graph (자원할당 그래프)</h2>

<p>✔️  <strong>Graph에서 Deadlock 확인 방법</strong></p>

<p>그래프에 cycle이 없으면 deadlock이 아니다</p>

<p>그래프에 cycle이 있을 때 자원의 인스턴스가 여러개이면 deadlock 일 수도 있고 아닐수도 있다.</p>

<h3 id="1️⃣graph---1">1️⃣ Graph - 1</h3>

<p><strong>Vertex</strong></p>

<ul>
  <li>Process P = {P1, P2, …. Pn}</li>
  <li>Resource R = {R1, R2, …. Rn}</li>
</ul>

<p><strong>Edge</strong></p>

<ul>
  <li>R2를 보유한 상태로 P1 → R1 자원을 요청</li>
  <li>R2와 R1을 보유한 상태로 P2 → R3 자원을 요청</li>
  <li>P3가 R3를 보유</li>
</ul>

<p><strong>DeadLock ?</strong></p>

<ul>
  <li>P3에 할당된 R3가 해제될 수 있기 때문에 Cycle은 있으나 <strong>deadlock은 아니다.</strong></li>
</ul>

<p><img width="254" alt="스크린샷 2022-04-03 오후 7 06 49" src="https://user-images.githubusercontent.com/56028408/161425754-ce5a67f4-0051-4f91-84d7-00279f5e6654.png" /></p>

<h3 id="2️⃣graph---2">2️⃣ Graph - 2</h3>

<p><strong>Vertex</strong></p>

<ul>
  <li>Process P = {P1, P2, …. Pn}</li>
  <li>Resource R = {R1, R2, …. Rn}</li>
</ul>

<p><strong>Edge</strong></p>

<ul>
  <li>R2를 보유한 상태로 P1 → R1 자원을 요청</li>
  <li>R2와 R1을 보유한 상태로 P2 → R3 자원을 요청</li>
  <li>P3가 R3를 보유한 상태로 P3 → R2 요청</li>
</ul>

<p><strong>DeadLock ?</strong></p>

<ul>
  <li>프로세스가 서로 가진 자원을 놓지 않고 다른 자원을 기다리고 있기 때문에 <strong>Deadlock 발생</strong></li>
</ul>

<p><img width="238" alt="스크린샷 2022-04-03 오후 7 07 06" src="https://user-images.githubusercontent.com/56028408/161425752-4a3dd02a-6ac2-4112-ac99-2a6ed349f6b7.png" /></p>

<h2 id="3-deadlock의-처리-방법">3. Deadlock의 처리 방법</h2>

<p>✔️ Deadlock Prevention</p>

<p>✔️ Deadlock Avoidance</p>

<p>✔️ Deadlock Detection and recovery</p>

<p>✔️ Deadlock Ignorance</p>

<ul>
  <li>Deadlock을 시스템이 책임지지 않음</li>
  <li>UNIX를 포함한 대부분의 OS가 채택</li>
</ul>

<h3 id="31-deadlock-prevention">3.1 Deadlock Prevention</h3>

<blockquote>
  <p>자원 할당 시 Deadlock의 4가지 필요 조건 중 어느 하나가 만족되지 않도록 하는 것</p>

</blockquote>

<p>✔️ Mutual Exclusion</p>

<ul>
  <li>공유해서는 안되는 자원의 경우 반드시 성립해야 함</li>
</ul>

<p>✔️ Hold and Wait</p>

<ul>
  <li>프로세스가 자원을 요청할 때 다른 어떤 자원도 가지고 있지 않아야 한다</li>
  <li>방법 1. 프로세스 시작 시 모든 필요한 자원을 할당받게 하는 법</li>
  <li>방법 2. 다른 필요한 자원이 있으면 보유 자원을 내려놓고 다시 요청</li>
</ul>

<p>✔️ No Preemption(비선점)</p>

<ul>
  <li>Process가 어떤 자원을 기다려야 하는 경우 이미 보유한 자원이 선점됨</li>
  <li>모든 필요한 자원을 얻을 수 있을 때 그 프로세스는 다시 시작된다.</li>
  <li>State를 쉽게 저장할 수 있고 복원할 수 있는 자원에서 주로 사용된다 (CPU, Memory)</li>
</ul>

<p>✔️ Circular Wait</p>

<ul>
  <li>모든 자원 유형에 할당 순서를 정하여 정해진 순서대로만 자원 할당
    <ul>
      <li>예를 들어 순서가 3인 자원 R1를 보유 중인 프로세스가 순서가 1인 자원 R2를 할당받기 위해서는 우선 R1를  반납해야한다.</li>
    </ul>
  </li>
</ul>

<p>⚠️  <strong>하지만 아직 발생할지 안할지도 모르는 Deadlock을 위와같은 방법으로 미리 예방하게 된다면 사용성을 저하시키고 성능을 감소되는 문제가 발생할 수 있다. 추가로 기아현상의 위험도 발생한다 ⚠️</strong> </p>

<h3 id="32-deadlock-avoidance">3.2 Deadlock Avoidance</h3>

<blockquote>
  <p>자원 요청에 대한 부가정보를 이용해서 자원 할당이 deadlock으로부터 안전(safe)한지 확인하고 할당한다. 시스템이 unsafe state에 들어가지 않는 것을 보장한다.</p>

  <p>프로세스들이 필요로 하는 각 자원을 예측하거나 별 최대 사용량을 미리 선언하도록 하는 방법이다.</p>

</blockquote>

<p><img width="284" alt="스크린샷 2022-04-03 오후 3 50 26" src="https://user-images.githubusercontent.com/56028408/161425758-2893dc77-0790-4cbd-af5a-26b7aa9af242.png" /></p>

<p>✔️ safe state</p>

<ul>
  <li>시스템 내의 프로세스들에 대한 safe sequence가 존재하는 상태</li>
  <li>시스템이 safe state에 있으면 deadlock이 발생하지 않음</li>
</ul>

<p>✔️ unsafe state</p>

<ul>
  <li>시스템이 unsafe state에 있으면 deadlock 발생 가능성이 있음</li>
</ul>

<p>✔️ avoidance 알고리즘</p>

<ul>
  <li>Resource Allocation Graph alogorithm
    <ul>
      <li>자원의 인스턴스가 하나일 경우 사용하는 알고리즘</li>
    </ul>
  </li>
  <li>Banker’s Algorithm
    <ul>
      <li>자원의 인스턴스가 여러개일 경우 사용하는 알고리즘</li>
    </ul>
  </li>
</ul>

<h3 id="1️⃣resource-allocoation-graph-alogorithm">1️⃣ Resource Allocoation Graph Alogorithm</h3>

<blockquote>
  <p>이전에 소개한 Resource Allocoation Graph에서 점선(Clain edge)이 추가된 알고리즘</p>

  <p>점선은 미래에 사용될 수 있는 자산을 가리킨다.</p>

</blockquote>

<p>✔️ Claim edge</p>

<ul>
  <li>프로세스가 자원을 미래에 요구할 수 있다는 것을 뜻함 (점선)</li>
  <li>프로세스가 해당 자원 요청시 Claime edge가 request edge로 바뀜 (실선)</li>
  <li>요청자원이 해제되면 assignment edge는 다시 claim edge로 변경됨</li>
</ul>

<p>✔️ request edge가 assignment edge로 변경 시 (점선을 포함하여) cycle이 생기지 않는 경우에만 요청 자원을 할당한다.</p>

<p>✔️ Cycle 생성 여부 조사시 프로세스의 수가 n일 때 O(n2)시간이 걸린다.</p>

<p>✔️ <strong>Resource Allocoation Graph Alogorithm 예시</strong></p>

<p><img width="961" alt="스크린샷 2022-04-03 오후 7 32 33" src="https://user-images.githubusercontent.com/56028408/161425750-3e18dec7-0642-4e3f-8ae9-0d8344aa0261.png" /></p>

<ol>
  <li>P1과 P2가 미래에 R2를 요청할 가능성이 있음.</li>
  <li>P2가 R1을 요청한 상태로 R2자원을 요청함.</li>
  <li>P2가 R2을 할당받음 하지만 실제로 <strong>Resource Allocoation Graph Alogorithm</strong> 점선을 포함하여 cycle이 생성될 경우 자원을 내어주지 않기 때문에 R2를 할당받지 못한다. P2가 R2를 할당받으려면 R1을 소유하고 있는 P1이 R2를 할당받은 후 P1의 작업이 끝나서 R1과 R2가 해제될 때 P2가 할당받을 수 있다.</li>
</ol>

<h3 id="2️⃣bankers-algorithm">2️⃣ Banker’s Algorithm</h3>

<blockquote>
  <p>자원의 인스턴스가 여러개일 경우 사용되는 알고리즘</p>

  <p>모든 프로세스의 자원의 최대 사용량을 미리 명시하여 최대 사용량이 available 가능한 자원으로 충족 될 경우에만 자원을 내어준다.</p>

</blockquote>

<p>✔️  가정</p>

<ul>
  <li>모든 프로세스는 자원의 최대 사용량을 미리 명시한다.</li>
  <li>프로세스가 요청 자원을 모두 할당받은 경우 유한시간 안에 이들 자원을 다시 반납한다.</li>
</ul>

<p>✔️  방법</p>

<ul>
  <li>기본 개념 : 자원 요청시 safe 상태를 유지할 경우에만 할당</li>
  <li>총 요청 자원의 수가 가용 자원의 수보다 적은 프로세스를 선택함 만약 그런 프로세스가 없다면 unsafe한 상태</li>
  <li>그런 프로세스가 있으면 그 프로세스에게 자원을 할당</li>
  <li>할당받은 프로세스가 종료되면 모든 자원을 반납</li>
  <li>모든 프로세스가 종료될 때까지 이러한 과정을 반복</li>
</ul>

<p>✔️ <strong>Banker’s Algorithm 예시</strong></p>

<p>Allocation</p>

<ul>
  <li>현재 소유하고 있는 자원</li>
</ul>

<p>Max</p>

<ul>
  <li>최대로 요청할 수 있는 자원의 수</li>
</ul>

<p>Available</p>

<ul>
  <li>가용 자원의 수</li>
</ul>

<p>Need</p>

<ul>
  <li>앞으로 요청할수도 있는 남은 자원의 수 (Max - Allocation)</li>
</ul>

<p><img width="508" alt="스크린샷 2022-04-03 오후 7 50 06" src="https://user-images.githubusercontent.com/56028408/161425748-e1727a31-270f-4a79-a9e5-8de74c0c8366.png" /></p>

<p>✔️ 5개의 프로세스가 존재한다고 가정한다.</p>

<p>✔️ 3개의 자원이 존재한다  A(10), B(5), C(7) 각 자원은 10, 5, 7개의 인스턴스를 가지고 있다.</p>

<p>✔️  현재 가용 자원보다 Need 자원의 더 클 경우에 해당 프로세스는 자원을 할당받지 못한다. 자원 할당이 가능한 프로세스를 순서대로 나열하면 &lt;P1, P3, P4, P2, P0&gt; 이 된다.</p>

<h3 id="33deadlock-detection-and-recovery">3.3 Deadlock Detection and recovery</h3>

<blockquote>
  <p>Deadlock 발생은 허용하되 그에 대한 detection 루틴을 두어 deadlock 발견시 recover한다.</p>

  <blockquote>
    <p>Resource type 당 single instance인 경우 자원할당 그래프에서의 cycle이 곧 deadlock을 의미한다.</p>

    <p>Resource type 당 multiple instance인 경우 Banker’s algorithm과 유사한 방법을 활용한다.</p>

  </blockquote>
</blockquote>

<h3 id="1️⃣wait-for-graph-algorithm">1️⃣ Wait-for graph Algorithm</h3>

<ul>
  <li>자원당 하나의 인스턴스를 가지고 있을 경우 사용됨</li>
  <li>Wait-for graph
    <ul>
      <li>자원할당 그래프의 변형</li>
      <li>프로세스만으로 node를 구성함
        <ul>
          <li>P1이 가지고 있는 자원을 P2가 기다리는 경우 P2 → P1</li>
          <li>Avoidance에선 P2 → R1 → P1</li>
        </ul>
      </li>
      <li>그래프에 점선이 없음</li>
    </ul>
  </li>
  <li>Algorithm
    <ul>
      <li>Wait-for graph에 사이클이 존재하는지를 주기적으로 조사함 O(n2)</li>
    </ul>
  </li>
</ul>

<p><img width="458" alt="스크린샷 2022-04-03 오후 8 05 13" src="https://user-images.githubusercontent.com/56028408/161425744-b3764fa2-5213-4e4e-8254-a41d87ad2cf2.png" /></p>

<p><strong>⚠️  Graph에 Cycle이 존재할 경우 Deadlock Detection ⚠️</strong></p>

<h3 id="2️⃣-multiple-instance인-경우에-사용되는-알고리즘">2️⃣  Multiple instance인 경우에 사용되는 알고리즘</h3>

<blockquote>
  <p><strong>Banker’s Algorithm</strong> 과 비슷하지만 최대 요청가능한 자산을 예측하지 않고 Allocation, Request, Available 만 관리한다.</p>

</blockquote>

<p><img width="398" alt="스크린샷 2022-04-03 오후 8 11 22" src="https://user-images.githubusercontent.com/56028408/161425742-92f20077-6814-48c3-ac8b-3ab0da0981a5.png" /></p>

<p>사용중인 자원을 해제한다는 가정하에 가용자원으로 safe sequence를 확인해보면 &lt;P0, P2, P3, P1, P4&gt; 와 같은 순서가 나타난다.</p>

<p><strong>🌟 Request는 추가요청가능량이 아니라 현재 실제로 요청한 자원량을 나타낸다 🌟</strong></p>

<p>✔️ Recovery</p>

<ul>
  <li>Process termination
    <ul>
      <li>Deadlock에 연루된 모든 프로세스를 Abork 한다.</li>
      <li>Deadlock에 연루된 프로세스를 하나씩 Abork 해보고 해결되는 지 확인한다.</li>
    </ul>
  </li>
  <li>Resource Preemption
    <ul>
      <li>Deadlock에 연루된 프로세스 중에 비용을 최소화할 victim을 선점하여 자원을 뺏는다.</li>
      <li>Safe State로 Rollback하여 Process를 재시작한다.</li>
      <li>Stavation 문제 발생 위험
        <ul>
          <li>동일한 프로세스가 계속해서 victim으로 선점되는 경우
            <ul>
              <li>cost factor에 Rollback횟수도 고려한다.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="34deadlock-ignorance">3.4 Deadlock Ignorance</h3>

<blockquote>
  <p>Deadlock이 일어나지 않는다고 생각하고 아무런 조치도 취하지 않는 방법으로 대부분의 범용 OS가 채택한 방법이다.</p>

  <blockquote>
    <p>Deadlock은 매우 드물게 발생하므로 deadlock에 대한 조치 자체가 더 큰 overhead일 수 있다</p>

    <p>만약, 시스템에 deadlock이 발생한 경우 시스템이 비정상적으로 작동하는 것을 사용자가 느낀 후 직접 process를 죽이는 방법 등으로 대처한다.</p>

  </blockquote>
</blockquote>

<h3 id="reference"><strong>Reference</strong></h3>

<hr />

<p>이화여자대학교 반효경 교수님 운영체제 강의</p>]]></content><author><name>ramram</name></author><category term="OS" /><category term="반효경" /><category term="데드락" /><category term="운영체제" /><category term="데드락 발생 4가지 조건" /><summary type="html"><![CDATA[🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟]]></summary></entry><entry><title type="html">[운영체제 스터디] 프로세스 동기화 문제 3가지 해결방법과 세마포어 뮤텍스 차이</title><link href="http://localhost:4000/os/os-study-07/" rel="alternate" type="text/html" title="[운영체제 스터디] 프로세스 동기화 문제 3가지 해결방법과 세마포어 뮤텍스 차이" /><published>2022-04-02T00:00:00+09:00</published><updated>2022-04-02T00:00:00+09:00</updated><id>http://localhost:4000/os/os-study-07</id><content type="html" xml:base="http://localhost:4000/os/os-study-07/"><![CDATA[<p>🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟</p>

<h1 id="process-synchronizationconcurrency">Process Synchronization(Concurrency)</h1>
<h3 id="️-프로세스-동기화와-관련된-3가지-문제">‼️  프로세스 동기화와 관련된 3가지 문제</h3>

<ol>
  <li>Bounded-Buffer Problem</li>
  <li>Readers and Writers Problem</li>
  <li>Dining-Philosophers Problem</li>
</ol>

<h2 id="1-bounded-buffer-problem-producer-consumer-problem">1. Bounded-Buffer Problem (Producer-Consumer Problem)</h2>

<blockquote>
  <p>Bounded-Buffer Problem란 생산자와 사용자의 비율이 맞지않아서 사용자나 생산자가 무한히 대기하거나, 공유데이터에 동시에 접근하여 데이터 통일성이 깨질 수 있는 문제점을 얘기한다.</p>

  <p>아래 내용은 이러한 문제점을 세마포어로 해결한 예시이다.</p>

</blockquote>

<p><img width="509" alt="스크린샷 2022-03-28 오후 8 48 56" src="https://user-images.githubusercontent.com/56028408/160510432-4cd492fe-4ddf-4088-80a3-6dc21e8ba5c4.png" /></p>

<h3 id="11-bounded-buffer의-문제점-해결-방안">1.1 Bounded-Buffer의 문제점 해결 방안</h3>

<p><strong>✔️ Producer - 데이터를 버퍼에 채워넣는 역할</strong></p>

<ol>
  <li>비어있는 버퍼가 있는 지 확인한다. (없을 경우 대기)</li>
  <li>비어있는 버퍼가 있으면 공유데이터에 접근하고 lock을 건다.</li>
  <li>비어있는 버퍼에 데이터 입력 및 버퍼를 조작한다</li>
  <li>Lock을 해제한다.</li>
  <li>Full Buffer를 하나 증가시킨다.</li>
</ol>

<p><strong>✔️ Consumer - 데이터를 사용하는 역할</strong></p>

<ol>
  <li>full 버퍼가 있는 지 확인한다. (없으면 대기)</li>
  <li>full 버퍼가 있을 경우 공유데이터에 접근하고 lock을 건다.</li>
  <li>full 버퍼에서 데이터를 읽어오고 버퍼를 조작한다.</li>
  <li>Lock을 해제한다.</li>
  <li>Empty Buffer를 하나 증가시킨다.</li>
</ol>

<p>‼️  <strong>여기서 말하는 공유데이터는</strong> ‼️</p>

<ul>
  <li>Buffer 자체 및 Buffer 조작 변수(empty/full buffer의 시작 위치)</li>
</ul>

<h3 id="12-세마포어를-적용한-동기화-기법-예제코드">1.2 세마포어를 적용한 동기화 기법 예제코드</h3>

<p> <strong>Producer</strong></p>

<p><strong>Consumer</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span> <span class="p">{</span>
	<span class="n">produce</span> <span class="n">an</span> <span class="n">item</span> <span class="n">in</span> <span class="n">x</span>
	<span class="p">...</span> 
	<span class="n">P</span><span class="p">(</span><span class="n">empty</span><span class="p">);</span> <span class="cm">/* 비어있는 버퍼의 수 확인 */</span>
	<span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span> <span class="cm">/* 버퍼가 비어있으면 버퍼에 진입하고 lock */</span> 
	<span class="p">...</span>
	<span class="n">add</span> <span class="n">x</span> <span class="n">to</span> <span class="n">buffer</span>
	<span class="p">...</span>
	<span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span> <span class="cm">/* 버퍼 unlock */</span>
	<span class="n">V</span><span class="p">(</span><span class="n">full</span><span class="p">);</span>  <span class="cm">/* full 자원을 증가시킴 */</span>

<span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span> <span class="p">{</span>
	<span class="n">P</span><span class="p">(</span><span class="n">full</span><span class="p">);</span> <span class="cm">/* 비어있지않은 버퍼의 수 확인 */</span>
	<span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span> <span class="cm">/* 버퍼가 하나라도 비어있지 않으면 버퍼에 진입하고 lock */</span>
	<span class="p">...</span>
	<span class="n">remove</span> <span class="n">an</span> <span class="n">item</span> <span class="n">from</span> <span class="n">buffer</span> <span class="n">to</span> <span class="n">y</span>
	<span class="p">...</span>
	<span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span> <span class="cm">/* 버퍼 unlock */</span>
	<span class="n">V</span><span class="p">(</span><span class="n">empty</span><span class="p">);</span> <span class="cm">/* 비어있는 버퍼의 갯수 증가 */</span>
	<span class="p">...</span>
	<span class="n">consume</span> <span class="n">the</span> <span class="n">item</span> <span class="n">in</span> <span class="n">y</span>
	<span class="p">...</span>
<span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>✔️ <strong>Synchrozination variables</strong></p>

<ul>
  <li>semaphore empty = n; semaphore full = 0;
    <ul>
      <li>남은 full/empty의 buffer의 수 표시</li>
    </ul>
  </li>
  <li>semaphore mutex = 1;
    <ul>
      <li>공유 데이터의 상호배제를 위한 변수</li>
    </ul>
  </li>
</ul>

<h2 id="2-readers-and-writers-problem">2. Readers and Writers Problem</h2>

<blockquote>
  <p>다수의 Readers Writer가 공용 데이터베이스에 접근하여 데이터 일관성을 해치는 문제점을 말한다. 이는 프로세스 동기화 기법으로 해결할 수 있다.</p>

  <p>아래 내용은 프로세스 동기화 기법을 사용하여 해결한 예시이다.</p>

</blockquote>

<p><img src="https://user-images.githubusercontent.com/56028408/160510449-35f712bd-9ed8-44eb-8425-ae22d07628e9.png" alt="image" /></p>

<h3 id="21-readers-and-writers-문제점-해결-방안">2.1 Readers and Writers 문제점 해결 방안</h3>

<p><strong>✔️ Reader &amp; Writer</strong></p>

<ul>
  <li>Reader는 데이터를 읽기만 하는 프로세스</li>
  <li>Writer는 데이터를 읽고 수정하는 프로세스</li>
</ul>

<p><strong>✔️ Reader &amp; Writer Problem 방지</strong></p>

<ul>
  <li>한 Writer가 임계구역에 진입한 상황일 때는 다른 프로세스가 임계구역에 접근하게 해선 안된다.
    <ul>
      <li>일단 Writer가 공유데이터에 접근 중이면 다른 Writer나 Reader들은 접근이 금지된다.</li>
      <li>Writer가 공유데이터에서 빠져나가야만 Reader의 접근이 허용된다.</li>
    </ul>
  </li>
  <li>Reader는 여럿이 임계구역에 접근해도 된다. 하지만 Reader가 접근 중일 때 Writer가 접근하게 해선 안된다.
    <ul>
      <li>Writer는 대기 중인 Reader가 하나도 없을 때 공유데이터 접근이 허용된다.</li>
    </ul>
  </li>
  <li>Writer가 공유데이터에 접근 허가를 아직 얻지 못한 상태에서는 모든 대기중인 Reader들을 다 임계구역에 접근하게 해준다</li>
</ul>

<h3 id="22-세마포어를-적용한-동기화-기법-예제코드">2.2 세마포어를 적용한 동기화 기법 예제코드</h3>

<p>✔️  <strong>Shared data</strong></p>

<ul>
  <li>int readcount = 0</li>
  <li>DB 자체</li>
</ul>

<p><strong>✔️ Synchronization variables</strong></p>

<ul>
  <li>semaphore mutex = 1;</li>
  <li>semaphore db = 1;</li>
</ul>

<p><strong>Writer</strong></p>

<p><strong>Reader</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">P</span><span class="p">(</span><span class="n">db</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">writing</span> <span class="n">DB</span> <span class="n">is</span> <span class="n">performed</span> 
<span class="p">...</span>
<span class="n">V</span><span class="p">(</span><span class="n">db</span><span class="p">);</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span> <span class="cm">/* 동시에 다른 reader가 readcount를 변경하는 문제가 발생하지 않도록 lock */</span>
<span class="n">readcount</span><span class="o">++</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">readcount</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">P</span><span class="p">(</span><span class="n">db</span><span class="p">);</span> <span class="cm">/* 최초의 접근일 경우 writer가 접근 못하도록 db 봉쇄 */</span>
<span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span> <span class="cm">/* readcount unlock */</span>
</code></pre></div></div>

<p><strong>‼️  하지만 위 코드와 같은 해결방법은 stavation 발생 위험이 있음</strong> ‼️ </p>

<p>예를 들어 writer가 대기 중일 때 reader가 끈임없이 진입하게 되면 wrtier가 무한히 대기하게 되는 현상이 발생한다.</p>

<p>단순한 프로세스 동기화 예제일 뿐 최적의 해결방법이 아니기 때문에 참고만 하자.</p>

<h2 id="3-dining-philosophers-problem-식사하는-철학자-문제">3. Dining-Philosophers Problem (식사하는 철학자 문제)</h2>

<blockquote>
  <p>하나 이상의 프로세스가 공유데이터 중 서로에게 필요한 자원을 하나씩만 가지고 양보하지 않아서 Deadlock 이 발생할 수 있는 문제</p>

  <p>아래 예제를 참고하여 어떤한 경우에 문제가 발생하는지 알아보고 어떻게 해결하는지 알아보자</p>

</blockquote>

<h3 id="문제-발생-예제-코드"><strong>[문제 발생 예제 코드]</strong></h3>

<p><strong>✔️ Synchronization variables</strong></p>

<ul>
  <li>semaphore chopstick[5]
    <ul>
      <li>배열의 모든 값을 1로 초기화 했다고 가정한다</li>
    </ul>
  </li>
</ul>

<p><strong>Philosopher i</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span> <span class="p">{</span>
	<span class="n">P</span><span class="p">(</span><span class="n">chopstick</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">P</span><span class="p">(</span><span class="n">chopstick</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="mi">5</span><span class="p">);</span>
	<span class="p">...</span>
	<span class="n">eat</span><span class="p">();</span>
	<span class="p">...</span>
	<span class="n">V</span><span class="p">(</span><span class="n">chopstick</span><span class="p">);</span>
	<span class="n">V</span><span class="p">(</span><span class="n">chopstick</span><span class="p">);</span>
	<span class="p">...</span>
	<span class="n">think</span><span class="p">();</span>
	<span class="p">...</span>
<span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/56028408/160510437-ee36b87b-a22f-4ae4-bd0c-342c1d9630f9.png" alt="스크린샷 2022-03-29 오전 9 25 43" /></p>

<p>✔️  위 예제 코드의 문제점</p>

<ul>
  <li>모든 철학자가 동시에 배가 고파져 왼쪽 젓가락을 집어버린 경우 아무도 먹지 못하는 문제가 발생한다.</li>
  <li>Deadlock 발생 위험이 있다.</li>
</ul>

<h3 id="해결방안-예제-코드"><strong>[해결방안 예제 코드]</strong></h3>

<p>✔️ <strong>Synchronization variables</strong></p>

<ul>
  <li>enum {thinking, hungry, eating} state[5];</li>
  <li>semaphore self[5] = 0;</li>
  <li>semaphore mutex = 1;</li>
</ul>

<p><strong>Philosopher i</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 실행메소드 */</span>
<span class="k">do</span> <span class="p">{</span>
	<span class="n">pickup</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="n">eat</span><span class="p">();</span>
	<span class="n">putdown</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="n">think</span><span class="p">();</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">pickup</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hungry</span><span class="p">;</span>
	<span class="n">test</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">P</span><span class="p">(</span><span class="n">self</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">pickdown</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">thinking</span><span class="p">;</span>
	<span class="n">test</span><span class="p">((</span><span class="n">j</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span> <span class="o">%</span> <span class="mi">5</span><span class="p">);</span>
	<span class="n">test</span><span class="p">((</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">5</span><span class="p">);</span>
	<span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* 대상 철학자의 오른쪽과 왼쪽 철학자가 식사중인지 검사하고 대상 철학자가 배고픈 상태일 때 식사를 허용한다. */</span>
<span class="kt">void</span> <span class="nf">test</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">state</span><span class="p">[(</span><span class="n">j</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">5</span><span class="p">]</span> <span class="o">!=</span> <span class="n">eating</span> <span class="o">&amp;&amp;</span> <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">hungry</span> <span class="o">&amp;&amp;</span> <span class="n">state</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">5</span><span class="p">]</span> <span class="o">!=</span> <span class="n">eating</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">eating</span><span class="p">;</span>
		<span class="n">V</span><span class="p">(</span><span class="n">self</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>		
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>✔️ 해결 방안</p>

<ul>
  <li>4명의 철학자만이 테이블에 동시에 앉을 수 있도록 한다</li>
  <li>젓가락을 두 개 모두 잡을 수 있을 때에만 젓가락을 집을 수 있게 한다</li>
  <li>비대칭
    <ul>
      <li>짝수(홀수) 철학자는 왼쪽(오른쪽) 젓가락부터 집도록</li>
    </ul>
  </li>
</ul>

<h3 id="️-여태까지의-예제코드를-살펴봤을-때-semaphore의-문제점-️">‼️  여태까지의 예제코드를 살펴봤을 때 Semaphore의 문제점 ‼️</h3>

<ul>
  <li>코딩하기 힘들다</li>
  <li>정확성(correctness)의 입증이 어렵다</li>
  <li>자발적 협력(voluntary cooperation)이 필요하다</li>
  <li>한번의 실수가 모든 시스템에 치명적 영향을 끼친다.</li>
</ul>

<p>💡 예시 1번</p>

<p>💡 예시 2번</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
<span class="n">Critical</span> <span class="n">Section</span>
<span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
<span class="n">Critical</span> <span class="n">Section</span>
<span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>[예시 1번]</strong></p>

<ul>
  <li>Wait 시점과 Signal 시점이 반대가 되어 Mutual Exclusion이 깨진다.</li>
</ul>

<p><strong>[예시 2번]</strong></p>

<ul>
  <li>자원을 해제하는 코드가 없기 때문에 서로 필요한 자원을 얻지 못하여 Deadlock 발생 위험이 있다.</li>
</ul>

<h2 id="4-monitor">4. Monitor</h2>

<blockquote>
  <p>동시에 수행중인 프로세스 사이에서 추상 데이터 타입의 안전한 공유를 보장하기 위한 high-level synchronization construct이다. 기본적으로 Monitor는 여러 프로세스가 동시적으로 접근할 수 없기 때문에 lock, unlock이 필요없다. 이는 프로그래머가 동기화 제약 조건을 명시적으로 코딩할 필요가 사라지기 때문에 프로그래머의 부담이 줄어든다고 할 수 있다.</p>

</blockquote>

<p>✔️ Monitor</p>

<ul>
  <li>모니터 내에서는 한번에 하나의 프로세스만이 활동 가능</li>
  <li>프로세스가 모니터를 사용하다가 타이머 인터럽트가 발생하여도 다른 프로세스가 모니터에 접근하지 못한다. active한 프로세스가 0이 되거나 프로세스가 모니터 내부에서 잠들었을 때 다른 프로세스가 진입한다.</li>
  <li>프로세스가 모니터 안에서 기다릴 수 있도록 하기 위해 condition variable 사용</li>
  <li>condition x;
    <ul>
      <li>condition value는 값을 가지지 않고 자신의 큐에 프로세스를 sleep 시키거나 깨우는 역할만 한다.</li>
    </ul>
  </li>
  <li>condition variable은 wait과 signal 연산에 의해서만 접근 가능
    <ul>
      <li>x.wait();
        <ul>
          <li>x.wait()을 invoke한 프로세스는 다른 프로세스가 x.signal()을 invoke하기 전까지 suspend된다</li>
        </ul>
      </li>
      <li>x.signal();
        <ul>
          <li>x.signal()은 정확하게 하나의 suspend된 프로세스를 resume한다. suspend된 프로세스가 없으면 아무 일도 일어나지 않는다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="41-모니터를-활용한-bounded-buffer-problem-문제-해결-방법">4.1 모니터를 활용한 Bounded-Buffer Problem 문제 해결 방법</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">monitor</span> <span class="n">bounded_buffer</span>
<span class="p">{</span> <span class="kt">int</span> <span class="n">buffer</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
	<span class="n">condition</span> <span class="n">full</span><span class="p">,</span> <span class="n">empty</span><span class="p">;</span>

	<span class="kt">void</span> <span class="n">produce</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> 
	<span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">N</span><span class="p">)</span> <span class="c1">// 1</span>
			<span class="n">empty</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>  <span class="c1">// 2</span>
		<span class="k">else</span>
			<span class="cm">/* add x to empty buffer*/</span>
			<span class="n">full</span><span class="p">.</span><span class="n">signal</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// 3</span>
		
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">consume</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span> 
	<span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// 1</span>
				<span class="n">full</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>      <span class="c1">// 2</span>
		<span class="k">else</span> 
			<span class="cm">/* remove an item from buffer an store it to */</span>
			<span class="n">empty</span><span class="p">.</span><span class="n">signal</span><span class="p">();</span>     <span class="c1">// 3</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<p>앞에 소개한 Bounded-Buffer 문제를 모니터로 변경한 소스코드이다. 모니터는 한 프로세스만 접근할 수 있으므로</p>

<p>세마포어처럼 공유변수에 lock/unlock 작업을 수행하지 않아도 된다.</p>

<p>✔️  <strong>produce(int x)</strong></p>

<ol>
  <li>빈 버퍼가 있는 지 확인한다.</li>
  <li>빈 버퍼가 없으면 empty큐에서 대기한다.</li>
  <li>빈 버퍼가 있으면 버퍼에 데이터를 추가하고 full큐에 잠들어있는 프로세스 하나를 깨운다.</li>
</ol>

<p>✔️  <strong>consume(int *x)</strong></p>

<ol>
  <li>버퍼에 데이터가 있는 지 확인한다.</li>
  <li>버퍼에 데이터가 없으면 full큐에 대기한다.</li>
  <li>데이터가 있을 경우 버퍼에서 데이터 하나를 읽어오고 empty큐에 잠들어있는 프로세스 하나를 깨운다.</li>
</ol>

<h3 id="reference"><strong>Reference</strong></h3>

<hr />

<p><a href="https://mangkyu.tistory.com/104">https://mangkyu.tistory.com/104</a></p>

<p>이화여자대학교 반효경 교수님 운영체제 강의</p>]]></content><author><name>ramram</name></author><category term="OS" /><category term="반효경" /><category term="식사하는 철학자" /><category term="모니터" /><category term="세마포어" /><category term="뮤텍스" /><summary type="html"><![CDATA[🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟]]></summary></entry><entry><title type="html">[운영체제 스터디] 프로세스 동기화 조건 3가지와 뮤텍스 세마포어</title><link href="http://localhost:4000/os/os-study-06/" rel="alternate" type="text/html" title="[운영체제 스터디] 프로세스 동기화 조건 3가지와 뮤텍스 세마포어" /><published>2022-03-28T00:00:00+09:00</published><updated>2022-03-28T00:00:00+09:00</updated><id>http://localhost:4000/os/os-study-06</id><content type="html" xml:base="http://localhost:4000/os/os-study-06/"><![CDATA[<p>🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟</p>

<h2 id="1-프로세스-동기화-프로그램적-해결법의-충족-조건">1. 프로세스 동기화 프로그램적 해결법의 충족 조건</h2>

<blockquote>
  <p>프로세스가 임계구역에 동시에 접근하는 것을 방지하고 데이터 일관성을 유지하려면 아래 세가지 조건을 충족해야한다.</p>

</blockquote>

<p>✔️ Mutual Exclustion</p>

<ul>
  <li>프로세스 Pi가 Critical Section 부분을 수행 중이면 다른 모든 프로세스들은 그들의 Critical Section에 접근하면 안된다.</li>
</ul>

<p>✔️ Progress</p>

<ul>
  <li>Critical Section에 접근한 프로세스가 없는 상황에서 Critical Section에 접근하고자 하는 프로세스가 있으면 Critical Section에 접근하게 해야한다.</li>
</ul>

<p>✔️ Bounded Waiting</p>

<ul>
  <li>프로세스가 Critical Section에 들어가려고 요청한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 Critical Section에 들어가는 횟수에는 한계가 있어야 한다. (기다리는 시간이 유한 해야함)
    <ul>
      <li>기아현상 방지</li>
    </ul>
  </li>
</ul>

<p>‼️  <strong>예제 알고리즘으로 위 세가지 조건에 만족할 수 있는 방법이 무엇인지 알아보자</strong></p>

<p><strong>💡  실습 가정 !</strong></p>

<ul>
  <li>모든 프로세스 수행 속도는 0보다 크다</li>
  <li>프로세스들 간의 상대적인 수행 속도는 가정하지 않는다</li>
  <li>예제 알고리즘은  두개의 프로세스가 있다고 가정한다 (P1, P2)</li>
  <li>프로세스들은 수행의 동기화를 위해 몇몇 변수를 공유할 수 있다 (Synchronization variable)</li>
</ul>

<h2 id="2-algorithm---1">2. Algorithm - 1</h2>

<h3 id="변수-초기화">[변수 초기화]</h3>

<p>✔️ Synchronization variable</p>

<ul>
  <li>int turn; →  프로세스가 임계구역에 들어갈 수 있는 조건인지 확인하는 변수</li>
  <li>initially turn = 1; →  첫 진입을 P1에게 허용하기 위해 1로 초기화 함</li>
</ul>

<h3 id="구현-코드">[구현 코드]</h3>

<p>✔️ Process P1 구현 코드</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span> <span class="p">{</span>
		<span class="k">while</span><span class="p">(</span><span class="n">turn</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span> <span class="cm">/* P1가 접근 가능한 상황이 될 때까지 while */</span>
		<span class="o">**</span><span class="n">critical</span> <span class="n">section</span><span class="o">**</span>  <span class="cm">/* 임계구역 */</span>
		<span class="o">****</span><span class="n">turn</span> <span class="o">****=</span> <span class="mi">2</span><span class="p">;</span>         <span class="cm">/* 프로세스 P2(이)가 접근할 수 있게 값 변경*/</span>
		<span class="o">**</span><span class="n">remainder</span> <span class="n">section</span><span class="o">**</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span> 
</code></pre></div></div>

<p>✔️ Process P2 구현 코드</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span> <span class="p">{</span>
		<span class="k">while</span><span class="p">(</span><span class="n">turn</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">);</span> <span class="cm">/* P2가 접근 가능한 상황이 될 때까지 while */</span>
		<span class="o">**</span><span class="n">critical</span> <span class="n">section</span><span class="o">**</span>  <span class="cm">/* 임계구역 */</span>
		<span class="o">****</span><span class="n">turn</span> <span class="o">****=</span> <span class="mi">1</span><span class="p">;</span>         <span class="cm">/* 프로세스 P1(이)가 접근할 수 있게 값 변경 */</span>
		<span class="o">**</span><span class="n">remainder</span> <span class="n">section</span><span class="o">**</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span> 
</code></pre></div></div>

<p><strong>💡  Algorithm - 1 은 Mutual Exclustion 을 만족하지만 Progress 조건은 만족하지 못한다. 💡</strong> </p>

<p><strong>Algorithm - 1</strong> 을 예로 들면 반드시 교대로 임계구역에 들어갈 수 있게 설계되어있기 때문에 P1이 임계구역 접근에 시도를 하지않을 경우 turn의 값은 영원히 바뀌지 않는다. turn이 변경되지 않을 경우 P2이 입계구역에 접근하려고 해도 접근할 수 없게 된다. 또한 임계구역 접근 빈도가 서로 다를 경우에도 문제가 발생할 수 있다.</p>

<h2 id="3-algorithm---2">3. Algorithm - 2</h2>

<h3 id="변수-초기화-1">[변수 초기화]</h3>

<p>✔️ Synchronization variable</p>

<ul>
  <li>boolean falg[2];</li>
  <li>initially flag[모두] = false; /* no one is in CS */</li>
  <li>프로세스가 임계구역에 접근할 준비가 되면 (flag[i] == true)</li>
</ul>

<h3 id="구현코드">[구현코드]</h3>

<p>✔️ Process P1 구현 코드</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span> <span class="p">{</span>
		<span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span> <span class="cm">/* 임계구역에 들어갈 준비가 되었다 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="cm">/* P2가 임계구역에 접근한 상태인지? 접근했다면 P1은 대기 */</span>
		<span class="o">**</span><span class="n">critical</span> <span class="n">section</span><span class="o">**</span>  <span class="cm">/* 임계구역 */</span>
		<span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="o">**</span><span class="n">remainder</span> <span class="n">section</span><span class="o">**</span>
<span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>✔️ Process P2 구현 코드</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span> <span class="p">{</span>
		<span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span> <span class="cm">/* 임계구역에 들어갈 준비가 되었다 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="cm">/* P1가 임계구역에 접근한 상태인지? 접근했다면 P2은 대기 */</span>
		<span class="o">**</span><span class="n">critical</span> <span class="n">section</span><span class="o">**</span> <span class="cm">/* 임계구역 */</span>
		<span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="o">**</span><span class="n">remainder</span> <span class="n">section</span><span class="o">**</span>
<span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p><strong>💡  Algorithm - 2 은 Mutual Exclustion 을 만족하지만 Progress 조건은 만족하지 못한다. 💡</strong> </p>

<p>P1과 P2가 둘 다 임계구역에 접근하려고 값을 true로 변경했을 경우 2행까지 수행 후 끊임 없이 양보하는 상황이 발생할 수 있다. 이럴 경우 P1, P2 두 프로세스가 전부 임계구역에 접근하지 못하는 상황이 발생하기 때문에 <strong>Progress</strong> 조건을 만족하지 못한다.</p>

<h2 id="4-algorithm---3-petersons-algorithm">4. Algorithm - 3 (Peterson’s Algorithm)</h2>

<h3 id="변수-초기화-2">[변수 초기화]</h3>

<ul>
  <li>Combined syschronization variables of algorithms 1 and 2
    <ul>
      <li>Peterson’s Algorithm은 Algorithm - 1 , Algorithm - 2 에서 사용했던 모든 변수를 사용한다.</li>
    </ul>
  </li>
</ul>

<h3 id="구현코드-1">[구현코드]</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span> <span class="p">{</span>
		<span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="cm">/* My intention is to enter */</span>
		<span class="n">turn</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>       <span class="cm">/* Set to his turn */</span>
		<span class="k">while</span><span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">turn</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="cm">/* wait only if */</span>
		<span class="o">**</span><span class="n">critical</span> <span class="n">section</span><span class="o">**</span> <span class="cm">/* 임계구역 */</span>
		<span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="o">**</span><span class="n">remainder</span> <span class="n">section</span><span class="o">**</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>💡 Algorithm - 3는 프로세스 동기화의 세가지 요구사항을 모두 만족한다. 💡</strong></p>

<p>피터슨의 알고리즘은 다른 프로세스가 임계구역에 접근한 상황인지와 다른 프로세스의 임계구역 접근 차례를 모두 검사하고 접근을 시도하기 때문에 세가지 요구사항을 모두 만족한다.</p>

<p>‼️  <strong>Algorithm - 3 의 문제점 → Busy Waiting(=spin lock)! (계속 CPU와 memory를 쓰면서 wait)</strong> ‼️</p>

<p>만약 한 프로세스가 임계구역에 접근한 상황에서 다른 프로세스가 CPU를 할당받을 경우 while 조건에 충족하기 때문에 다른 작업은 수행하지 못하고 CPU를 빼앗길 때까지 while을 반복하게 된다. (의미없이 CPU 수행시간을 낭비하게 됨)</p>

<h2 id="5-synchronization-hardware">5. Synchronization Hardware</h2>

<blockquote>
  <p>프로세스 동기화 문제는 소프트웨어가 Input과 Output을 하나의 인스트럭션으로 진행할 수 없어서 생긴 문제점이다. 이러한 문제점을 하드웨어적으로 test &amp; modify를 atomic하게 수행할 수 있도록 지원하면 앞의 문제는 간단히 해결된다.</p>

</blockquote>

<p>✔️ Counting semaphore (세마포어)</p>

<ul>
  <li>도메인이 0 이상인 임의의 정수값</li>
  <li>자원의 갯수가 여러개인 경우</li>
  <li>주로 resource counting에 사용</li>
</ul>

<p>✔️ Binary semaphore (=mutex)</p>

<ul>
  <li>0 또는 1 값만 가질 수 있는 세마포어
    <ul>
      <li>자원의 갯수가 하나인 경우</li>
    </ul>
  </li>
  <li>주로 mutual exclusion (lock/unlock)에 사용 (=mutex)</li>
</ul>

<h3 id="51-mutex">5.1 Mutex</h3>

<blockquote>
  <p>Mutex는 Mutual Exclustion의 약자이고 상호배재 한다는 뜻으로 사용된다. Mutex는 Locking 매커니즘으로 오직 하나의 쓰레드만이 동일한 시점에 뮤텍스를 얻어 임계 영역에 들어올 수 있고 오직 이 쓰레드만이 임계 영역에서 나갈 때 뮤텍스를 해제할 수 있다.</p>

</blockquote>

<h3 id="52-mutual-exclustion-with-test--set">5.2 Mutual Exclustion with Test &amp; Set</h3>

<h3 id="변수-초기화-3">[변수 초기화]</h3>

<p>✔️ Synchronization variable</p>

<ul>
  <li>boolean lock = false;</li>
</ul>

<h3 id="구현코드-2">[구현코드]</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span> <span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">Test_and_Set</span><span class="p">(</span><span class="n">lock</span><span class="p">));</span>
	<span class="o">**</span><span class="n">critical</span> <span class="n">section</span><span class="o">**</span>
	<span class="n">lock</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="o">**</span><span class="n">remainder</span> <span class="n">section</span><span class="o">**</span>
<span class="p">}</span>
</code></pre></div></div>

<p>💡 <strong>Test_and_set()</strong></p>

<p>파라미터 변수의 값을 읽고, TRUE로 변경작업을 수행한다. 이전 알고리즘 1,2,3은 값을 읽고 변경하는 작업을 따로따로 진행했다면, <strong>Test_and_set()</strong>은 값을 읽고 변경하는 작업을 하나의 인터럭션으로 수행하므로 조금 더 간결하게 해결할 수 있도록 도와준다.</p>

<h2 id="6-semaphores">6. Semaphores</h2>

<blockquote>
  <p>세마포어란 임계구역에 진입하기 어려울 때 프로세스가 자발적으로 대기 상태로 들어가는 방식이다. 세마포어는 앞의 방식들을 추상화 시킨 방식이다.</p>

</blockquote>

<p>❓ 세마포어</p>

<ul>
  <li>block/wakeup 알고리즘</li>
  <li>진입 불가능 시에는 대기상태로 전환</li>
  <li>임계구역을 떠나는 프로세스가 대기 프로세스를 준비 상태로 깨워줌</li>
</ul>

<p>❓ 세마포어 구성</p>

<ul>
  <li>하나의 정수값 (정수변수 value)</li>
  <li>프로세스 대기 큐</li>
  <li>정수에 대한 3가지 연산 : init, wait, signal
    <ul>
      <li>wait 은 P 연산이라고도 불린다.</li>
      <li>signal 은 V 연산이라고도 불린다.</li>
    </ul>
  </li>
</ul>

<p>✔️ Semaphore 객체를 S 라 할 때</p>

<ul>
  <li>S.value: 자원 활용 현황
    <ul>
      <li>양수: 남아있는 자원의 수</li>
      <li>음수: 부족하여 대기하고 있는 대기자 수</li>
    </ul>
  </li>
  <li>S.value의 초기값 n : 자원의 개수</li>
</ul>

<p>아래의 두 가지 atomic 연산에 의해서만 자원에 접근 가능하다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">P</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="o">:</span> <span class="k">while</span> <span class="p">(</span><span class="n">s</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">)</span> <span class="k">do</span> <span class="n">no</span><span class="o">-</span><span class="n">op</span><span class="p">;</span> <span class="cm">/*wait*/</span>
			<span class="n">S</span><span class="o">--</span><span class="p">;</span>

<span class="n">V</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="o">:</span> <span class="n">S</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* 자원 반납 */</span>
</code></pre></div></div>

<blockquote>
  <p>세마포어의 모든 오퍼레이션은 atomic하게 실행되어야 한다. wait 연산을 하는 동안 signal 연산을 하거나, 또는 그 반대의 경우 모두 발생해서는 안된다. 이를 보장하기 위해 각 연산이 실행되는 동안 인터럽트를 disable 시킴으로써 해결할 수 있다. 만약 다중 CPU 환경이라면 모든 CPU의 인터럽트를 disable 시켜야 한다. 헌데 모든 인터럽트를 디스에이블 할 경우 성능이 저하될 수 있기 때문에 compare_and_swap()을 사용하거나 spinlock 과 같은 busy waiting 기법을 사용하기도 한다.</p>

</blockquote>

<h2 id="61-block--wakeup-inmplementation">6.1 Block &amp; Wakeup Inmplementation</h2>

<p>✔️ Busy-wait 과 Block/wakeup</p>

<p>busy-wait과 block/wakeup 방식을 비교하자면 block/wakeup 방식을 사용하는 것이 효율적이다. busy-wait 방식은 자기 차례가 아니면 의미없이 CPU 시간을 낭비하는 반면에 block/wakeup 방식은 자기 차례가 아닐 경우 block 상태로 전환하기 때문이다.</p>

<p>그런데 임계구역의 코드가 짧을 경우에는 block/wakeup 방식보다 busy-wait 방식이 더 효율적일 수 있다. ready 상태에서 block 상태로 전환하고 다시 block 상태에서 ready 상태로 전환하는 것에 오버헤드가 따르기 때문이다.</p>

<p>정리하자면 임계구역이 짧을 경우에는 busy-wait 방식이 효율적이고 임계구역 코드가 길 경우에는 block/wakeup 방식이 효율적이다.</p>

<h2 id="7-deadlock">7. Deadlock</h2>

<blockquote>
  <p>둘 이상의 프로세스가 서로 원하는 리소스가 상대방에게 할당되어 있을 경우 무한히 대기하는 현상을 말한다. 보통 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생한다.</p>

</blockquote>

<h3 id="reference"><strong>Reference</strong></h3>

<hr />

<p><a href="https://mangkyu.tistory.com/104">https://mangkyu.tistory.com/104</a></p>

<p>이화여자대학교 반효경 교수님 운영체제 강의</p>]]></content><author><name>ramram</name></author><category term="OS" /><category term="반효경" /><category term="교착상태" /><category term="프로세스 동기화" /><category term="세마포어" /><category term="뮤텍스" /><summary type="html"><![CDATA[🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟]]></summary></entry><entry><title type="html">[운영체제 스터디] 다단계 큐 스케줄링과 프로세스 동기화</title><link href="http://localhost:4000/os/os-study-05/" rel="alternate" type="text/html" title="[운영체제 스터디] 다단계 큐 스케줄링과 프로세스 동기화" /><published>2022-03-23T00:00:00+09:00</published><updated>2022-03-23T00:00:00+09:00</updated><id>http://localhost:4000/os/os-study-05</id><content type="html" xml:base="http://localhost:4000/os/os-study-05/"><![CDATA[<p>🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟</p>

<h2 id="1-multilevel-queue-singlecore-cpu-기준">1. Multilevel Queue (SingleCore Cpu 기준)</h2>

<p>✔️ Multilevel Feedback Queue보다 프로세스 차별적인 방식</p>

<p>✔️ Ready queue를 여러 개로 분할</p>

<ul>
  <li>foreground (interactive)</li>
  <li>background (batch - no human interaction)</li>
</ul>

<p>✔️  각 큐는 독립적인 스케줄링 알고리즘을 가짐</p>

<ul>
  <li>foreground - RR (라운드 로빈)
    <ul>
      <li>사용자와 대화하는 프로세스이기 때문에 응답시간이 짧은 것이 중요하다</li>
    </ul>
  </li>
  <li>background - FCFS (선입선출)
    <ul>
      <li>사용자와 대화없이 CPU만 사용하는 batch형 작업이기 때문에 응답시간이 빠를 필요가 없다</li>
    </ul>
  </li>
</ul>

<p>✔️  큐에 대한 스케줄링이 필요</p>

<ul>
  <li>Fixed priority scheduling
    <ul>
      <li>serve all from foreground then from background</li>
      <li>Possibility of starvation
        <ul>
          <li>우선순위가 높은 작업이 종료되지 않으면 우선순위가 낮은 프로세스는 영원히 실행되지 못하는 문제가 발생할 수 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Time slice
    <ul>
      <li>각 큐에  CPU time을 적절한 비율로 할당</li>
      <li>starvation을 막기위해 전체 CPU 사용시간을 우선순위가 높은 foreground 작업에 80% 할당하고 우선순위가 낮은 background 작업에 20%를 할당하게 한다.</li>
    </ul>
  </li>
</ul>

<h2 id="2-multilevel-feedback-queue-singlecore-cpu-기준">2. Multilevel Feedback Queue (SingleCore Cpu 기준)</h2>

<p>✔️  프로세스가 다른 큐로 이동할 수 있음</p>

<p>✔️  에이징(aging)을 이와 같은 방식으로 구현할 수 있음</p>

<p>✔️ Multilevel-feedback-queue scheduler를 이루고 있는 요소들</p>

<ul>
  <li>Queue의 수</li>
  <li>각 큐의 scheduling algorithm</li>
  <li>Process를 상위 큐로 보내는 기준</li>
  <li>Process를 하위 큐로 내쫓는 기준</li>
  <li>프로세스가 CPU 서비스를 받으려 할 때 들어갈 큐를 결정하는 기준</li>
</ul>

<p>✔️  처음 실행되는 작업은 우선순위를 가장 높게 받음</p>

<h3 id="21-multilevel-feedback-queue-예시">2.1 Multilevel Feedback Queue 예시</h3>

<p>✔️ Three queues:</p>

<ul>
  <li>Q0 - time quantum 8 milliseconds</li>
  <li>Q1 -  time quantun 16 milliseconds</li>
  <li>Q2 - FCFS (선입선출)</li>
</ul>

<p>✔️ Schduling</p>

<ul>
  <li>새로운 작업이 Q0으로 들어간다.</li>
  <li>CPU를 잡아서 할당 시간 8milliseconds 동안 수행된다</li>
  <li>Q0에서 할당받은 시간내에 작업을 다 끝내지 못했으면 Q1로 내려간다.</li>
  <li>Q1에 줄서서 기다렸다가 CPU를 할당받고 16ms 동안 수행된다.</li>
  <li>Q1에서 할당받은 시간내에 작업을 끝내지 못한 경우 Q2로 쫓겨난다.</li>
</ul>

<h2 id="3-멀티코어-cpu의-경우-고려해야할-점">3. 멀티코어 CPU의 경우 고려해야할 점</h2>

<blockquote>
  <p>CPU가 여러 개인 경우 스케줄링은 더욱 복잡해진다.</p>

</blockquote>

<p>✔️ Homogeneous processor인 경우</p>

<ul>
  <li>Queue에 한줄로 세워서 각 프로세서가 알아서 꺼내가게 할 수 있다.</li>
  <li>반드시 특정 프로세스에세 수행되어야 하는 프로세스가 있는 경우에는 문제가 복잡해진다.</li>
</ul>

<p>✔️ Load sharing</p>

<ul>
  <li>일부 프로세서에 job이 몰리지 않도록 부하를 적절히 공유하는 메커니즘이 필요하다</li>
  <li>별개의 큐를 두는 방법 vs 공동 큐를 사용하는 방법</li>
</ul>

<p>✔️ Symmetric Multiprocessing (SMP)</p>

<ul>
  <li>각 프로세서가 각자 알아서 스케줄링 결정</li>
</ul>

<p>✔️ Asymmetric multiprocessing</p>

<ul>
  <li>비대칭형 다중 처리기
    <ul>
      <li>하나의 프로세서가 시스템 데이터의 접근과 공유를 책임지고 나머지 프로세서는 거기에 따라 움직이는 방식</li>
    </ul>
  </li>
  <li>대칭형 다중 처리기
    <ul>
      <li>CPU가 각자 알아서 스케줄링하는 방식</li>
    </ul>
  </li>
</ul>

<h2 id="4-real-time-scheduling">4. Real-Time Scheduling</h2>

<p>✔️ Hard real-time systems</p>

<ul>
  <li>Hard real-time task는 정해진 시간 안에 반드시 끝내도록 스케줄링해야 함</li>
</ul>

<p>✔️ Soft real-time computing</p>

<ul>
  <li>Soft real-time task는 일반 프로세스에 비해 높은 priority를 갖도록 해야 함</li>
</ul>

<p>✔️ EDF (Earlist Deadline scheduling)</p>

<ul>
  <li>실시간 환경에서는 먼저 온 요청보다 데드라인이 다가온 요청을 먼저 처리하는 스케줄링</li>
  <li>연성 실시간 시스템처럼 일반 작업과 VOD 작업 등이 혼합된 환경에서는 데드라인이 존재하는 프로세스에게 일반 프로세스보다 높은 우선 순위를 할당한다.</li>
</ul>

<h2 id="5-thread-scheduling">5. Thread Scheduling</h2>

<p>✔️ Local Scheduling</p>

<ul>
  <li>User level thread의 경우 사용자 수준의 thread library에 의해 어떤 thread를 스케줄링할지 결정
    <ul>
      <li>이 경우에 운영체제는 해당 thread의 존재를 알지 못한다.</li>
    </ul>
  </li>
</ul>

<p>✔️ Global Sheduling</p>

<ul>
  <li>Kernel level thread의 경우 일반 프로세스와 마찬 가지로 커널의 단기 스케줄러가 어떤 thread를 스케줄할지 결정</li>
</ul>

<h2 id="6-process-synchronization">6. Process Synchronization</h2>

<blockquote>
  <p>멀티 프로세서 시스템의 경우 메모리 주소공간을 공유하는 CPU 프로세스가 여럿 있는 경우 Race Condition의 가능성이 있다. 아래 내용들은 Race Condition 발생 원인과 이를 해결하기 위한 프로세스 동기화 방법이다.</p>

</blockquote>

<p>✔️ <strong>Race Condition?</strong></p>

<blockquote>
  <p>여러 프로세스들이 동시에 공유데이터에 접근하여 경쟁하는 상태이다.</p>

  <p>여러 프로세스가 동시에 공유데이터에 접근하게되면 데이터의 불일치 문제를 발생시킬 수 있다.</p>

  <p>일관성 유지를 위해서는 협력 프로세스간의 실행 순서를 정해주는 메커니즘이 필요하다</p>

</blockquote>

<p>✔️ <strong>OS에서 Race Condition은 언제 발생하는가?</strong></p>

<ul>
  <li>Kernel에서 수행 중 인터럽트 발생 시</li>
  <li>Process가 system call을 하여 kernel mode로 수행 중인데 context switch가 일어나는 경우</li>
  <li>N 개의 프로세스가 공유 데이터를 동시에 사용하기를 원하는 경우</li>
</ul>

<p>‼️  <strong>한 프로세스가 공유 데이터를 사용하고 있을 때 다른 프로세스가 접근하면 안되는 이유</strong> ‼️</p>

<ul>
  <li>각 프로세스의 <strong>code segment</strong>에는 공유 데이터를 접근하는 코드인 <strong>ciritical section</strong>이 존재한다.</li>
  <li>이 경우에 하나의 프로세스가 <strong>critical section</strong>에 있을 때 다른 모든 프로세스는 <strong>critical section</strong>에 들어갈 수 없어야 한다.</li>
</ul>

<p><strong>✔️ Race Condition은 어떻게 방지하는가?</strong></p>

<ul>
  <li>Process가 system call을 하여 kernel mode로 수행 중인데 context switch가 일어나는 경우
    <ul>
      <li>커널 모드에서 수행 중일 때는 CPU를 선점하지 않고 커널모드에서 사용자 모드로 돌아갈 때 CPU를 선점하는 방식</li>
    </ul>
  </li>
  <li>Multiprocessor에서 shared memory 내의 kernel data
    <ul>
      <li>방법 1) 한번에 하나의 CPU만이 커널에 들어갈 수 있게 하는 방법</li>
      <li>방법 2) 커널 배우에 있는 각 공유 데이터에 접근할 때마다 그 데이터에 대한 lock / unlock을 하는 방법</li>
    </ul>
  </li>
</ul>]]></content><author><name>ramram</name></author><category term="OS" /><category term="멀티 피드백 큐" /><category term="멀티레벨 큐" /><category term="프로세스 동기화" /><category term="Operating System" /><category term="반효경" /><category term="운영체제와 정보기술의 원리" /><summary type="html"><![CDATA[🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟]]></summary></entry><entry><title type="html">[운영체제 스터디] 프로세스 생성과 프로세스의 협력</title><link href="http://localhost:4000/os/os-study-04/" rel="alternate" type="text/html" title="[운영체제 스터디] 프로세스 생성과 프로세스의 협력" /><published>2022-03-22T00:00:00+09:00</published><updated>2022-03-22T00:00:00+09:00</updated><id>http://localhost:4000/os/os-study-04</id><content type="html" xml:base="http://localhost:4000/os/os-study-04/"><![CDATA[<p>🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟</p>

<h2 id="1-프로세스와-관련한-시스템-콜">1. 프로세스와 관련한 시스템 콜</h2>

<p>✔️ fork()</p>

<ul>
  <li>create a child (copy)</li>
</ul>

<p>✔️ exec()</p>

<ul>
  <li>overlay new image</li>
</ul>

<p>✔️ wait()</p>

<ul>
  <li>sleep until child is done</li>
</ul>

<p>✔️ exit()</p>

<ul>
  <li>frees all the resources, notify parent</li>
</ul>

<h2 id="2-프로세스-생성-process-creation">2. 프로세스 생성 (Process Creation)</h2>

<p>‼️  <strong><em>Copy-on-wirte(COW)</em></strong></p>

<ul>
  <li>자원의 내용이 변경될 때 메모리 영역을 복제하고 변경되지 않을 경우에는 부모 프로세스의 자원을 공유한다.</li>
</ul>

<p>✔️  부모프로세스(Parent process)가 자식 프로세스(chlidren process) 생성</p>

<p>✔️ 프로세스의 트리(계층 구조) 형성</p>

<p>✔️ 프로세스는 자원을 필요로 함</p>

<ul>
  <li>운영체제로부터 받는다</li>
  <li>부모와 공유한다.</li>
</ul>

<p>✔️ 자원의 공유</p>

<ul>
  <li>부모와 자식이 모든 자원을 공유하는 모델</li>
  <li>일부를 공유하는 모델
    <ul>
      <li>보통은 공유하는 모델보다 공유하지않는 모델이 대부분이다.</li>
    </ul>
  </li>
  <li>전혀 공유하지 않는 모델
    <ul>
      <li>부모와 자식 프로세스가 자원을 공유하지 않을 경우엔 자원을 두고 부모와 자식이 경쟁하게 된다.</li>
    </ul>
  </li>
</ul>

<p>✔️ 수행(Execution)</p>

<ul>
  <li>부모와 자식이 공존하며 수행되는 모델
    <ul>
      <li>부모와 자식이 공존하며 수행되는 모델은 자식과 부모가 CPU를 획득하기 위해 경쟁하는 관계가 된다.</li>
    </ul>
  </li>
  <li>자식이 종료(terminate)될 때까지 부모가 기다리는(wait)모델
    <ul>
      <li>자식 프로세스가 종료될 때까지 부모는 봉쇄상태에 머물러 있다가 자식프로세스가 종료된 이후에 CPU를 얻을 수 있는 권한이 생긴다.</li>
      <li>일반적인 봉쇄상태와 다르게 자원을 기다리며 줄 서 있는 것이 아니다.</li>
    </ul>
  </li>
</ul>

<p>✔️ 주소 공간 (Address space)</p>

<ul>
  <li>자식은 부모의 공간을 복사함 (binary and OS data)</li>
  <li>자식은 그 공간에 새로운 프로그램을 올림</li>
</ul>

<p>✔️ 유닉스의 예</p>

<ul>
  <li>fork()
    <ul>
      <li>fork() 시스템 콜이 새로운 프로세스를 생성</li>
      <li>부모를 그대로 복사 (OS data execpt PID + binary)
        <ul>
          <li>주소공간은 따로 가지고 있지만 주소공간의 내용은 동일한 내용을 갖게 된다 (문맥이 동일하다)</li>
          <li>문맥이 동일하기 때문에 부모 프로세스의 프로그램 카운터 지점부터 수행하게 된다.</li>
        </ul>
      </li>
      <li>주소 공간 할당</li>
      <li>부모 프로세스와 다른 작업을 수행할 수 있지만, 이는 조건문에 의한 분기일 뿐 사실상 부모 프로세스와 동일한 코드의 내용을 갖는다.</li>
    </ul>
  </li>
  <li>exec()
    <ul>
      <li>exec() 시스템 콜을 통해 새로운 프로그램으로 주소 공간을 덮어씌울 수 있다.</li>
      <li>부모 프로세스와 문맥이 달라지므로 부모프로세스의 실행시점부터 수행하지 않고 처음부터 실행하게 된다.</li>
    </ul>
  </li>
</ul>

<h2 id="3-프로세스-종료-process-termination">3. 프로세스 종료 (Process Termination)</h2>

<p>✔️ exit()</p>

<ul>
  <li>프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려준다(exit)</li>
  <li>자식이 부모에게 output data를 보냄 (via wait)</li>
  <li>프로세스의 각종 자원들이 운영체제에게 반납됨</li>
  <li>명시적으로 exit()를 호출하지 않았더라도 컴파일러가 main 함수가 리턴되는 위치에 exit()를 넣어줌</li>
</ul>

<p>✔️ abort()</p>

<ul>
  <li>자식이 할당 자원의 한계치를 넘어섬</li>
  <li>자식에게 할당된 태스크가 더 이상 필요하지 않음</li>
  <li>키보드로 kill, break를 친 경우</li>
  <li>부모가 종료(exit)하는 경우
    <ul>
      <li>운영체제는 부모 프로세스가 종료하는 경우 자식이 더 이상 수행되도록 두지 않는다.</li>
      <li>단계적인 종료</li>
    </ul>
  </li>
</ul>

<h2 id="4-자식-프로세스-생성">4. 자식 프로세스 생성</h2>

<p>✔️ 부모 프로세스가 자식 프로세스를 생성할 때의 플로우</p>

<ol>
  <li>부모 프로세스가 자식 프로세스 생성을 위해 fork() 시스템 콜을 발생시킨다.</li>
  <li>fork() 시스템 콜이 발생하면 CPU의 제어권이 커널로 넘어간다.</li>
  <li>커널은 fork()를 호출한 프로세스를 복제하여 자식 프로세스를 생성한다.</li>
</ol>

<blockquote>
  <p>부모 프로세스를 복제하여 생성된 자식 프로세스는 현실세계의 부모 자식과는 달리 자신을 똑닮은 자식이 아닌, 자신의 외모와 기억이 전부 동일한 복제인간을 생성하는 것과 같다.</p>

  <p>복제된 대상은 ‘복제되었다’는 기억을 가지는 것이 아니라 부모와 마찬가지로 방금 전에 자기 자신을 ‘복제했다’는 기억을 가지게 된다. 자식 프로세스가 복제된 프로세스라는 사실을 알 수 있는 단서는 fork() 함수의 결과값이 원본 프로세스는 양수를 가지고 복제본은 0을 갖는다는 차이점이 있다.</p>

</blockquote>

<h2 id="5-프로세스간의-협력">5. 프로세스간의 협력</h2>

<blockquote>
  <p>프로세스는 각자 자신만의 독립적인 공간을 가지고 수행되며 프로세스가 다른 프로세스의 주소공간을 참조하는 것은 허용되지 않는다. 따라서 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미칠 수 없다.</p>

</blockquote>

<p>🤔 <strong><em>독립적인 프로세스가 서로 협력하면 프로세스 작업의 효율성이 증가할 것 같은데..?</em></strong></p>

<p>원칙적으론 프로세스는 다른 프로세스의 수행에 영향을 미칠 수 없지만, 프로세스가 협력했을 때 작업 효율이 증가할 수 있기 때문에 운영체제는 여러가지 매커니즘을 제공한다. 대표적인 매커니즘으론 IPC가 있다.</p>

<p>✔️  프로세스 간 협력 메커니즘 (IPC: Interprocess Communication)</p>

<ul>
  <li>하나의 컴퓨터안에서 실행 중인 서로 다른 프로세스 간에 발생하는 통신</li>
  <li>프로세스간의 통신과 동기화를 이루기 위한 메커니즘</li>
  <li>메시지 전달 방식과 공유 메모리 방식이 있음.
    <ul>
      <li>두 방식의 차이는 프로세스 사이에 공유 데이터를 사용하는가, 그렇지 않는가에 있다</li>
    </ul>
  </li>
  <li>메시지를 전달하는 방법
    <ul>
      <li>Massage passing
        <ul>
          <li>커널을 통해 메시지 전달</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>주소공간을 공유하는 방법
    <ul>
      <li>Shared memory
        <ul>
          <li>서로 다른 프로세스 간에도 일부 주소 공간을 공유하게 하는 shared momory 메커니즘이 있음</li>
        </ul>
      </li>
      <li>🤔 Thread
        <ul>
          <li>thread는 사실상 하나의 프로세스이므로 프로세스 간 협렵으로 보기는 어렵지만 동일한 process를 구성하는 thread들 간에는 주소 공간을 공유하므로 협력이 가능</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="️ipc의-메세지-전달-방식-massage-passing">‼️ IPC의 메세지 전달 방식 (Massage passing)</h3>

<p>✔️ Message system</p>

<ul>
  <li>프로세스 사이에 공유 변수(shared variable)를 일체 사용하지 않고 통신하는 시스템</li>
</ul>

<p>✔️ Direct Communication</p>

<ul>
  <li>통신하려는 프로세스의 이름을 명시적으로 표시</li>
</ul>

<p><img width="583" alt="스크린샷 2022-03-20 오후 8 03 43" src="https://user-images.githubusercontent.com/56028408/159159351-86081a47-49b8-424c-9490-3dd586acbc92.png" /></p>

<p>✔️ Indirect Communication</p>

<ul>
  <li>mailbox (또는 port)를 통해 메세지를 간접 전달</li>
</ul>

<p><img width="583" alt="스크린샷 2022-03-20 오후 8 04 12" src="https://user-images.githubusercontent.com/56028408/159159348-1860f708-522d-487f-ab62-543c36d90581.png" /></p>

<p>💡 <strong>Massage passing</strong></p>

<blockquote>
  <p>공유데이터를 사용하지 않는 프로세스들이 메시지를 주고받으며 통신하는 방식을 사용한다. 이때 두 프로세스의 주소공간이 다르므로 메시지를 직접 전달할 수 없기 때문에 커널이 그 역할을 대신한다.</p>

  <p>메시지 통신을 하는 시스템은 커널에 의해 send와 receive라는 두 가지 연산을 제공받게 된다. 이 두 연산을 통해 프로세스는 전달할 메세지를 운영체제에게 시스템 콜 방식으로 요청해 전달할 수 있다.</p>

  <p>통신하기를 원하는 두 프로세스는 커뮤니케이션 링크를 생성한 후 send()와 receive()를 이용해서 메시지를 주고받게 된다.</p>

</blockquote>]]></content><author><name>ramram</name></author><category term="OS" /><category term="프로세스 생성" /><category term="부모 프로세스" /><category term="자식 프로세스" /><category term="Operating System" /><category term="반효경" /><category term="운영체제와 정보기술의 원리" /><summary type="html"><![CDATA[🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟]]></summary></entry><entry><title type="html">[운영체제 스터디] 프로세스의 특성과 CPU 스케줄링</title><link href="http://localhost:4000/os/os-study-04-02/" rel="alternate" type="text/html" title="[운영체제 스터디] 프로세스의 특성과 CPU 스케줄링" /><published>2022-03-22T00:00:00+09:00</published><updated>2022-03-22T00:00:00+09:00</updated><id>http://localhost:4000/os/os-study-04-02</id><content type="html" xml:base="http://localhost:4000/os/os-study-04-02/"><![CDATA[<p>🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟</p>

<h2 id="1cpu-and-io-bursts-in-program-execution">1. CPU and I/O Bursts In Program Execution</h2>

<blockquote>
  <p>어떤 프로그램이든 프로그램을 실행한다는 것은 CPU Burst와 I/O Burst를 반복하게 되는 것이다.</p>

</blockquote>

<p>❓CPU Burst</p>

<ul>
  <li>CPU에서 instruction을 수행하는 것</li>
</ul>

<p>❓ I/O Burst</p>

<ul>
  <li>I/O를 instruction을 수행하는 작업</li>
</ul>

<h3 id="프로세스의-특성-분류">💡 프로세스의 특성 분류</h3>

<p>✔️ I/O-bound process</p>

<ul>
  <li>CPU를 잡고 계산하는 시간보다 I/O에 많은 시간이 필요한 Job</li>
  <li>(many short CPU bursts)</li>
</ul>

<p>✔️CPU-bound process</p>

<ul>
  <li>계산 위주의 job</li>
  <li>(few very long CPU bursts)</li>
</ul>

<h3 id="cpu-burst-time의-분포">💡 CPU-burst Time의 분포</h3>

<p><img width="713" alt="image" src="https://user-images.githubusercontent.com/56028408/159224088-360d62a2-4066-4a8b-99cc-4935e80941d8.png" /></p>

<p>✔️ 여러 종류의 job(=process)이 섞여 있기 때문에 CPU 스케줄링이 필요하다.</p>

<ul>
  <li>Interactive job에게 적절한 reponse 제공 요망</li>
  <li>CPU와 I/O 장치 등 시스템 자원을 골고루 효율적으로 사용해야 함</li>
</ul>

<h2 id="2-cpu-scheduler--dispatcher">2. CPU Scheduler &amp; Dispatcher</h2>

<p>✔️ CPU Scheduler</p>

<ul>
  <li>Ready 상태의 프로세스 중에서 이번에 CPU를 줄 프로세스를 고른다.</li>
</ul>

<p>✔️ Dispatcher</p>

<ul>
  <li>CPU의 제어권을 CPU scheduler에 의해 선택된 프로세스에게 넘긴다</li>
  <li>이 과정을 context switch(문맥 교환)라고 한다.</li>
</ul>

<p>✔️ CPU 스케줄링이 필요한 경우</p>

<ol>
  <li>Running → Blocked (예: I/O 요청하는 시스템 콜)</li>
  <li>Running → Ready (예: 할당시간만료로 timer interrupt)</li>
  <li>Blocked → Ready (예: I/O 완료후 interrupt)</li>
  <li>Terminate</li>
</ol>

<blockquote>
  <p><strong>I/O를 발생시켜 Blocked 되는 경우나 Terminate에서의 스케줄링은 강제로 빼앗지 않고 자진반납(nonpreemptive)한다. 다른 상태는 모두 강제로 빼앗기는(preemptive) 경우이다.</strong></p>

</blockquote>

<p>❓<strong>nonpreemptive = 비선점형 방식</strong></p>

<ul>
  <li>CPU를 획득한 프로세스가 스스로 CPU를 반납하기 전까지는 CPU를 빼앗기지 않음</li>
</ul>

<p><strong>❓preemptive = 선점형 방식</strong></p>

<ul>
  <li>프로세스가 CPU를 계속 사용하길 원한다고 하더라도 강제로 빼앗길 수 있음</li>
</ul>

<h2 id="3-dispatcher">3. Dispatcher</h2>

<blockquote>
  <p>CPU 스케줄러가 어떤 프로레스에게 CPU를 할당해야 할지 결정하고나면 선택된 프로세스에게 실제로 CPU를 이양하는 작업이 필요하다.</p>

  <p>이와 같이 새롭게 선택된 프로세스가 CPU를 할당받고 작업을 수행할 수 있도록 환경설정 하는 운영체제의 코드를 디스패처라고 부른다.</p>

  <p>디스패처는 현재 수행 중이던 프로세스의 문맥(context)을 그 프로세스의 PCB에 저장하고, 새롭게 선택된 프로세스의 문맥을 PCB로부터 복원한 후 그 프로세스에게 CPU를 넘기는 작업을 수행한다.</p>

  <p>디스패처가 하나의 프로세스를 정지시키고 다른 프로세스에게 CPU를 전달하기까지 걸리는 시간을 디스패치 지연시간(dispatch Latency)이라고 하며, 디스패치 지연시간의 대부분은 문맥교환 오버헤드에 해당된다.</p>

</blockquote>

<h2 id="4-스케줄링-알고리즘">4. 스케줄링 알고리즘</h2>

<h3 id="1-선입선출-스케줄링fcfs"><strong>1. 선입선출 스케줄링(FCFS)</strong></h3>

<blockquote>
  <p>선입선출(First-Come First-Served: FCFS) 스케줄링은 프로세스가 준비큐에 도착한 시간 순서대로 CPU를 할당하는 방식을 말한다.  이 방식에서는 CPU를 먼저 요청한 프로세스에게 CPU를 할당하고, 해당 프로세스가 자발적으로 CPU를 반납할 때까지 빼앗기지 않는다.</p>

</blockquote>

<p><strong>1.1 선입선출 스케줄링의 단점</strong></p>

<ul>
  <li>도착한 순서대로 CPU 작업을 처리하기 때문에 CPU Burst가 짧은 작업이어도 도착시간이 늦어지게 되면, CPU Burst가 높은 작업이 끝날 때까지 기다려야 하므로 사용량에 비해 대기시간이 길어진다는 단점이 있다. 이를 콘보이 현상 이라고 하며, 이는 FCFS 스케줄링의 대표적인 단점에 해당된다.</li>
</ul>

<hr />

<h3 id="2-최단작업-우선-스케줄링-sjf"><strong>2. 최단작업 우선 스케줄링 (SJF)</strong></h3>

<blockquote>
  <p>최단작업 우선(Shortest-job First: SFJ) 스케줄링 알고리즘은 CPU 버스트가 가장 짧은 프로세스에게 CPU를 제일 먼저 할당하는 방식이다. 이와 같은 할당 방식을 통해 CPU 버스트가 짧은 프로세스가 CPU를 먼저 사용하고 준비 큐를 빠져나가게 되면 프로세스들이 준비 큐에서 기다리는 전체적인 시간이 줄어들게 된다. SJF 스케줄링 알고리즘은 평균 대기시간을 가장 짧게 하는 최적 알고리즘으로 알려져 있다.</p>

</blockquote>

<p><strong>2.1 선점방식</strong></p>

<ul>
  <li>진행중인 작업의 남은 CPU 버스트보다 짧은 작업이 도착하면 더 짧은 작업에게 CPU를 할당하는 방식 이러한 방식을 SRTF(Shortest Remaining Time First)라고도 부른다.</li>
  <li>프로세스들이 준비 큐에 도착하는 시간이 불규칙한 경우 선점형방식이 프로세스들의 평균 대기시간을 최소화 하는 최적의 알고리즘이 된다.</li>
  <li>일반적인 시분할 환경에서는 중간중간에 새로운 프로세스가 도착하는 경우가 발생하므로 선점형 방식이 평균 대기시간을 가장 많이 줄일 수 있다.</li>
</ul>

<p><strong>2.2 비선점방식</strong></p>

<ul>
  <li>먼저 도착한 작업의 CPU 수행이 끝나서 스스로 CPU를 내어놓을 때까지 스케줄링을 하지 않는다.</li>
  <li>일련의 프로세스들이 준비큐에 한번에 도착하고 그 후에는 따로 도착하지 않는 환경에선 선점형방식과 같은 대기시간 결과를 나타내기도 한다.</li>
</ul>

<p><strong>2.1 SFJ 스케줄링의 단점</strong></p>

<ul>
  <li>CPU 버스트가 짧은 프로세스가 계속 도착할 경우 CPU 버스트가 긴 프로세스는 영원히 CPU를 할당받지 못할 수 있다. 이를 기아 현상(starvation)이라고 한다.</li>
</ul>

<hr />

<h3 id="3-우선순위-스케줄링"><strong>3. 우선순위 스케줄링</strong></h3>

<blockquote>
  <p>우선순위 스케줄링(priority scheduling)이란 준비 큐에서 기다리는 프로세스들 중 우선순위가 가장 높은 프로세스에게 제일 먼저 CPU를 할당하는 방식을 말한다. 이때 우선순위는 우선순위값(priority number)을 통해 표시하며 우선순위값이 작을수록 높은 우선순위를 가지는 것으로 가정한다.</p>

  <p>우선순위 스케줄러도 비선점형방식과 선점형방식이 있는데 이는 SJF 알고리즘의 비선점형,선점형과 동일한 방식에서 CPU 버스트 시간 기준이 아닌, 우선순위 기준으로 변경된 것이다.</p>

</blockquote>

<p><strong>3.1 우선순위를 정하는 방법</strong></p>

<ul>
  <li>CPU 버스트 시간으로 우선순위 선정
    <ul>
      <li>이러한 경우 SJF 알고리즘과 동일한 의미를 가지게 됨</li>
    </ul>
  </li>
  <li>시스템과 관련된 동일한 작업을 수행하는 프로세스의 우선순위를 높게 부여하는 것</li>
  <li></li>
</ul>

<p><strong>3.2 우선순위 스케줄링 단점</strong></p>

<ul>
  <li>우선순위 스케줄러 방식에서도 기아현상이 발생할 수 있다. 우선순위가 높은 프로세스가 계속 도착하는 상황에서 우선순위가 낮은 프로세스는 CPU를 얻지못한 채 계속 기다려야 할 수 있기 때문이다. 이러한 단점을 해결하기 위해 노화(aging) 기법이 존재한다.</li>
</ul>

<p><strong>3.3 노화기법 (aging)</strong></p>

<ul>
  <li>노화 기법이란 기다리는 시간이 길어지면 우선순위를 조금씩 높여, 언젠가는 가장 높은 우선순위가 되어 CPU를 할당받을 수 있게 해주는 방법이다.</li>
</ul>

<hr />

<h3 id="4-라운드로빈-스케줄링"><strong>4. 라운드로빈 스케줄링</strong></h3>

<blockquote>
  <p>라운드로빈 스케줄링은 시분할 시스템 성질을 가장 잘 활용한 새로운 의미의 스케줄링 방식이라 할 수 있다. 라운드로빈 스케줄링에서는 각 프로세스가 CPU를 연속적으로 사용할 수 있는 시간이 특정 시간으로 제한된다.</p>

  <p>제한된 시간이 경과하면 해당 프로세스로부터 CPU를 회수해 준비 큐에 줄 서 있는 다른 프로세스에게 CPU를 할당한다.</p>

  <p>라운드로빈 스케줄링의 할당시간을 너무 길게 설정하면 이는 FCFS와 같은 결과를 나타나게 되고, 너무 짧게 설정할 경우엔 CPU 프로세스가 빈번하게 변경되어 문맥교환 오버헤드가 발생하게 된다. 따라서 일반적으로 할당시간은 수십 밀리초 정도의 규모로 설정하게 된다.</p>

</blockquote>]]></content><author><name>ramram</name></author><category term="OS" /><category term="CPU 스케줄링" /><category term="Round Robin" /><category term="SJF 스케줄링" /><category term="FCFS" /><category term="우선순위 스케줄링" /><category term="반효경" /><category term="운영체제와 정보기술의 원리" /><summary type="html"><![CDATA[🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟]]></summary></entry><entry><title type="html">[운영체제 스터디] 프로세스와 쓰레드</title><link href="http://localhost:4000/os/os-study-03/" rel="alternate" type="text/html" title="[운영체제 스터디] 프로세스와 쓰레드" /><published>2022-03-16T00:00:00+09:00</published><updated>2022-03-16T00:00:00+09:00</updated><id>http://localhost:4000/os/os-study-03</id><content type="html" xml:base="http://localhost:4000/os/os-study-03/"><![CDATA[<p>🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟</p>

<h2 id="1-프로세스">1. 프로세스</h2>

<blockquote>
  <p>“Process is a program in execution”</p>

</blockquote>

<p>✔️ 프로세스의 문맥(context)</p>

<ul>
  <li>CPU 수행 상태를 나타내는 하드웨어 문맥
    <ul>
      <li>하드웨어 문맥
        <ul>
          <li>Program Counter</li>
          <li>각종 register</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>프로세스의 주소 공간 (프로세스마다 각자의 주소공간을 가지고 있음)
    <ul>
      <li>code, data, stack</li>
    </ul>
  </li>
  <li>프로세스 관련 커널 자료 구조
    <ul>
      <li>PCB (Process Control Block)</li>
      <li>Kernel stack</li>
    </ul>
  </li>
</ul>

<p>✔️ 프로세스는 상태가 변경되며 수행된다</p>

<ul>
  <li>Running
    <ul>
      <li>CPU를 잡고 Instruction을 수행중인 상태</li>
    </ul>
  </li>
  <li>Ready
    <ul>
      <li>CPU를 기다리는 상태(메모리 등 다른 조건을 모두 만족하고)</li>
    </ul>
  </li>
  <li>Blocked (wait, sleep)
    <ul>
      <li>CPU를 주어도 당장 Instruction을 수행할 수 있는 상태</li>
      <li>Process 자신이 요청한 event가 즉시 만족되지 않아 이를 기다리는 상태</li>
    </ul>
  </li>
  <li>Suspended (stopped)
    <ul>
      <li>외부적인 이유로 프로세스의 수행이 정지된 상태
        <ul>
          <li>사용자가 프로그램을 일시 정지시킨 경우 (break key)</li>
          <li>메모리에 너무 많은 프로세스가 올라와 있을 때</li>
          <li>시스템이 특정한 이유로 프로세스를 잠시 중단시킨 경우</li>
        </ul>
      </li>
      <li>프로세스는 통째로 디스크에 swap out 된다.</li>
    </ul>
  </li>
</ul>

<p>❗New : 프로세스가 생성중인 상태</p>

<p>❗Termonated: 수행(execution)이 끝난 상태</p>

<p>❗Blocked: 자신이 요청한 event가 만족되면 Ready</p>

<p>❗Suspended: 외부에서 resume해 주어야 Active</p>

<h3 id="프로세스-상태도">🌟 프로세스 상태도</h3>

<p><img src="https://user-images.githubusercontent.com/67252475/158180436-40a50fc5-2c26-4935-a195-b00796adbc1a.png" alt="image" /></p>

<h2 id="2-pcb">2. PCB</h2>

<ul>
  <li>운영체제가 각 프로세스를 관리하기 위해 프로세스당 유지하는 정보</li>
  <li>다음의 구성 요소를 가진다(구조체로 유지)
    <ul>
      <li>OS가 관리상 사용하는 정보
        <ul>
          <li>process state, process ID</li>
          <li>scheduling Information, priority</li>
        </ul>
      </li>
      <li>CPU 수행 관련 하드웨어 값
        <ul>
          <li>Program counter, registers</li>
        </ul>
      </li>
      <li>메모리 관련
        <ul>
          <li>Code, data, stack의 위치 정보</li>
        </ul>
      </li>
      <li>파일 관련
        <ul>
          <li>Open file descriptors</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="3-문맥-교환-context-switch">3. 문맥 교환 (Context Switch)</h2>

<p>✔️ CPU를 한 프로세스에서 다른 프로세르로 넘겨주는 과정</p>

<p>✔️ CPU가 다른 프로세스에게 넘어갈 때 운영체제는 다음을 수행</p>

<ul>
  <li>CPU를 내어주는 프로세스의 상태를 그 프로세스의 PCB에 저장</li>
  <li>CPU를 새롭게 얻는 프로세스의 상태를 PCB에서 읽어옴
    <ul>
      <li>프로세스가 이전에  실행 중이던 상태부터 다시 실행하기 위해</li>
    </ul>
  </li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">문맥교환은</span> <span class="o">**</span><span class="kt">Timer</span> <span class="kt">Interuppt</span><span class="o">**</span><span class="n">가</span> <span class="n">발생하거나</span> <span class="o">**</span><span class="kt">I</span><span class="o">/</span><span class="kt">O</span> <span class="kt">SystemCall</span><span class="o">**</span><span class="n">이</span> <span class="n">발생할</span> <span class="n">때</span> <span class="n">이뤄진다</span><span class="o">.</span> 
<span class="n">사용자</span> <span class="n">프로그램이</span> <span class="o">**</span><span class="kt">Interuppt</span><span class="o">**</span><span class="n">를</span> <span class="n">발생시키거나</span> <span class="o">**</span><span class="kt">SystemCall</span><span class="o">**</span><span class="n">을</span> <span class="n">하여</span> <span class="n">사용자</span> <span class="n">모드에서</span> <span class="n">커널모드로</span> <span class="n">변경되는</span> <span class="n">것은</span>
<span class="n">문맥교환이</span> <span class="n">아니다</span><span class="o">.</span> 

<span class="n">사용자모드에서</span> <span class="n">커널모드로</span> <span class="n">변경되는</span> <span class="n">것도</span> <span class="n">문맥교환은</span> <span class="n">이러나지</span> <span class="n">않았지만</span> <span class="n">이전에</span> <span class="n">실행했던</span> 
<span class="n">사용자</span> <span class="n">프로그램이</span> <span class="n">실행</span> <span class="n">중이던</span> <span class="n">정보를</span> <span class="kt">PCB에</span> <span class="n">저장하기</span> <span class="n">때문에</span> <span class="n">약간의</span> <span class="n">문맥은</span> <span class="n">저장이</span> <span class="n">되지만</span>
<span class="n">문맥교환처럼</span> <span class="n">프로세스</span> <span class="n">자체가</span> <span class="n">변경되는</span> <span class="n">것보다</span> <span class="n">오버헤드가</span> <span class="n">적다</span><span class="o">.</span>

<span class="n">문맥교환이</span> <span class="n">발생하면</span> <span class="n">해당</span> <span class="n">프로세스가</span> <span class="n">사용하던</span> <span class="o">**</span><span class="kt">Cache</span> <span class="kt">Memory</span><span class="o">**</span><span class="n">를</span> <span class="o">**</span><span class="kt">Flush</span><span class="o">**</span> <span class="n">해야하기</span> <span class="n">때문에</span> <span class="n">커널모드와</span> <span class="n">사용자모드</span> 
<span class="n">스위칭보다</span> <span class="n">상당한</span> <span class="n">오버헤드가</span> <span class="n">발생한다</span><span class="o">.</span>
</code></pre></div></div>

<p>💡 프로세스의 문맥이란 프로세스 실행상태와 프로세스 자원 등 커널에서 관리하는 <strong>프로세스 실행 정보</strong>를 말한다.</p>

<h2 id="4-프로세스를-스케줄링하기-위한-큐">4. 프로세스를 스케줄링하기 위한 큐</h2>

<p>✔️  Job queue</p>

<ul>
  <li>현재 시스템 내에 있는 모든 프로세스의 집합</li>
</ul>

<p>✔️ Ready queue</p>

<ul>
  <li>현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합</li>
</ul>

<p>✔️ Device queue</p>

<ul>
  <li>I/O device의 처리를 기다리는 프로세스의 집합</li>
</ul>

<blockquote>
  <p>💡 이와 같은 큐는 소프트웨어 자원을 기다리는 경우에도 필요하다. 예를 들면 공유 데이터에 대한 접근 권한은 소프트웨어 자원으로 분류될 수 있다. 어떠한 프로세스가 공유 데이터를 사용하는 중에 다른 프로세스가 같은 데이터를 접근하면 일관성이 훼손될 수 있기 때문에 매 시점 하나의 프로세스만이 접근할 수 있도록 해야한다.</p>
</blockquote>

<h2 id="5-스케줄러-scheduler">5. 스케줄러 (Scheduler)</h2>

<p>✔️  Long-term scheduler (장기 스케줄러 or Job Scheduler)</p>

<ul>
  <li>시작 프로세스 중(new 상태의 프로세스) 어떤 것들을 ready queue로 보낼지 결정</li>
  <li>프로세스에 메모리(및 각종 자원)을 주는 문제</li>
  <li>degree of Multiprogramming을 제어</li>
  <li>time sharing system에는 보통 장기 스케줄러가 없음 (무조건 ready 상태)</li>
  <li>현대의 운영체제에는 장기 스케줄러가 없다</li>
</ul>

<p>✔️ Short-term scheduler (단기 스케줄러 or CPU scheduler)</p>

<ul>
  <li>어떤 프로세스를 다음번에 running 시킬지 결정</li>
  <li>프로세스에 CPU를 주는 문제</li>
  <li>충분히 빨라야 함 (milliseconde 단위)</li>
</ul>

<p>✔️ Medium-Tern Scheduler (중기 스케줄러 or Swapper)</p>

<ul>
  <li>여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아냄</li>
  <li>프로세스에게서 memory를 뺏는 문제</li>
  <li>degree of Multiprogramming을 제어</li>
</ul>

<blockquote>
  <p>💡 스왑아웃 대상 0순위는 봉쇄상태의 프로세스다.</p>

  <p>봉쇄상태의 프로세스를 스왑아웃 시켜도 메모리가 부족하면 타이머 인터럽트가 발생하여 준비큐로 이동하는 프로세스를 추가적으로 스왑아웃 시킨다.</p>

  <p>준비큐에 너무 많은 프로세스가 존재하면 개별 프로세스에 배정되는 메모리양이 지나치게 적어지고 CPU를 한번 할당받은 후 다시 할당받기 까지 오랜 시간이 소요되기 때문이다.</p>
</blockquote>

<h2 id="6-thread">6. Thread</h2>

<blockquote>
  <p>“A Theard ( or Lightweigth process) is a basic unit of CPU utilization”</p>

</blockquote>

<p>✔️ Thread의 구성 (CPU 수행과 관련)</p>

<ul>
  <li>program counter</li>
  <li>register set</li>
  <li>stack space</li>
</ul>

<p>✔️ Thread가 동료 Thread와 공유하는 부분 (=task)</p>

<ul>
  <li>code section</li>
  <li>data section</li>
  <li>OS resource</li>
</ul>

<p>✔️  전통적인 개념의 heavyweight process는 하나의 thread를 가지고 있는 task로 볼 수 있다.</p>

<p>✔️  다중 쓰레드로 구성된 태스크 구조에서는 하나의 서버 쓰레드가 블럭된 상태인 동안에도 동일한 태스크     내의 다른 쓰레드가 실행되어 빠른 처리가 가능하다.</p>

<p>✔️  동일한 작업을 수행하는 다중 스레드가 협력하여 높은 처리율과 성능 향상을 얻을 수 있다.</p>

<p>✔️  스레드를 사용하면 병렬성을 높일 수 있다.</p>

<ul>
  <li>멀티코어 컴퓨터에서 얻는 장점</li>
</ul>

<p>✔️  멀티 프로세스보다 멀티 스레드가 가볍다.</p>

<ul>
  <li>멀티 프로세스의 경우 각각의 프로세스마다 자원을 별도로 생성하는 반면, 멀티 스레드는 CPU 수행과 관련된 부분만 생성하고 code, data, os 자원같은 경우 프로세스의 메모리 영역을 참조한다.</li>
</ul>

<blockquote>
  <p>💡 멀티 쓰레드 웹 서버를 예로 들면, 한 요청이 끝날 때까지 기다렸다가 다음 요청을 처리하는 게 아닌 쓰레드마다 각각의 요청을 처리할 수 있다.</p>
</blockquote>

<h2 id="7-thread-의-장점">7. Thread 의 장점</h2>

<p>✔️ Responsiveness</p>

<ul>
  <li>multi-threaded
    <ul>
      <li>만약 하나의 Thread 블럭되면 (eg network) 또 다른 Thread 작업을 이어간다. (eg display)</li>
    </ul>
  </li>
</ul>

<p>✔️ Resource Sharing</p>

<ul>
  <li>여러개의 Thread 코드영역, 데이터 영역 등 프로세스 자원(CPU 수행에 필요한 자원)을 공유할 수 있다.</li>
</ul>

<p>✔️ Economy</p>

<ul>
  <li>프로세스 문맥교환과 프로세스 생성은 Thread 스위칭, Thread 생성보다 오버헤드가 상당히 크다
    <ul>
      <li>솔라리스 운영체제의 경우 오버헤드가 각각 30배 5배</li>
    </ul>
  </li>
</ul>

<p>✔️ Utilization of MP Architecutres</p>

<ul>
  <li>각 쓰레드가 서로 다른 CPU에서 병렬적으로 수행될 수 있다. (멀티 프로세서 환경)</li>
</ul>]]></content><author><name>ramram</name></author><category term="OS" /><category term="프로세스" /><category term="스케줄러" /><category term="OS" /><category term="Operating System" /><category term="쓰레드" /><category term="Thread" /><category term="반효경" /><category term="운영체제와 정보기술의 원리" /><summary type="html"><![CDATA[🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟]]></summary></entry><entry><title type="html">[운영체제 스터디] 컴퓨터 구조와 컴퓨터 시스템 동작원리</title><link href="http://localhost:4000/os/os-study-02/" rel="alternate" type="text/html" title="[운영체제 스터디] 컴퓨터 구조와 컴퓨터 시스템 동작원리" /><published>2022-03-15T00:00:00+09:00</published><updated>2022-03-15T00:00:00+09:00</updated><id>http://localhost:4000/os/os-study-02</id><content type="html" xml:base="http://localhost:4000/os/os-study-02/"><![CDATA[<p>🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟</p>

<h2 id="1-컴퓨터-구조">1. 컴퓨터 구조</h2>

<p><img src="https://user-images.githubusercontent.com/56028408/157796926-1bb83571-56ea-404a-b551-048cb898fdaf.png" alt="https://user-images.githubusercontent.com/56028408/157796926-1bb83571-56ea-404a-b551-048cb898fdaf.png" /></p>

<p>✔️ 전문가적 입장에서 컴퓨터를 말할 때, 보통 CPU와 Memory를 말한다.</p>

<p>✔️ 컴퓨터는 CPU, Memory, I/O Device, Disk, 네트워크 장비들로 이뤄져있다.</p>

<h2 id="2-컴퓨터-시스템-구조">2. 컴퓨터 시스템 구조</h2>

<p>✔️  CPU</p>

<ul>
  <li>CPU는 매 클럭사이클 마다 메모리에서 instruction을 하나씩 읽어서 실행한다.</li>
  <li>instruction 수행이 종료되면 Interrupt Line을 체크하고 인터럽트 신호가 확인되면 수행한다.</li>
</ul>

<p>✔️  Modebit</p>

<ul>
  <li>사용자가 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치</li>
  <li>하드웨어적으로 두 가지 모드의 Operation 지원
    <ul>
      <li>1 → 사용자 모드로 사용자 프로그램을 실행한다.</li>
      <li>0 → 커널모드로 OS 코드를 실행한다</li>
    </ul>
  </li>
  <li>보안을 해칠 수 있는 중요한 명령어는 커널 모드에서만 수행 가능한 특권명령으로 규정한다.</li>
  <li>Interrupt나 Exeception이 발생하면 하드웨어가 mode bit를 0으로 변경하여 운영체제에게 CPU를 할당한다.</li>
  <li>커널모드에서 작업이 끝나면 사용자모드로 변경하기 전에 mode bit를 1으로 변경한다.</li>
</ul>

<p>✔️  Timer</p>

<ul>
  <li>특정 프로그램이 CPU를 독점하는 것을 방지하기위한 장치</li>
  <li>운영체제가 사용자 프로그램에게 CPU를 넘겨줄 때 Timer에 값을 지정해서 넘겨준다.</li>
  <li>타이머 값이 0이 되면 타이머가 CPU에게 인터럽트 신호를 발신한다.</li>
  <li>타이머는 time sharing을 구현하기 위해 널리 이용됨</li>
  <li>타이머는 현재 시간을 계산하기 위해서도 사용됨</li>
</ul>

<p>✔️  Memory</p>

<ul>
  <li>메모리는 CPU가 처리할 데이터나 명령어가 임시로 저장되는 곳으로 작업 공간 역할을 한다.</li>
  <li>컴퓨터 작업을 할 때 하드디스크에 있는 데이터는 먼저 메모리로 이동된 다음 CPU로 전송된다.
    <ul>
      <li>프로그램 실행도 이와 마찬가지로 CPU가 메모리에 저장되어 있는 용량만큼 프로그램을 작동시킨다.</li>
    </ul>
  </li>
</ul>

<p>✔️  I/O Device</p>

<ul>
  <li>각각의 I/O Device는 각 디바이스를 전담하는 Controller를 가지고 있다.</li>
  <li>Controller는 각 I/O 디바이스의 내부를 통제하는 작업을 담당한다. CPU에게 인터럽트를 발생시키는 것도 Controller가 담당한다.</li>
  <li>I/O Device는 CPU에 비해 처리속도가 상당히 느리다</li>
  <li>I/O Device는 모두 각각의 Local Buffer를 가지고 있다.</li>
  <li>I/O는 실제 device와 local buffer 사이에서 일어남</li>
</ul>

<p>✔️ I/O Device Controller</p>

<ul>
  <li>I/O 장치유형을 관리하는 일종의 작은 CPU</li>
  <li>제어 정보를 위해 control register, status register를 가짐</li>
  <li>local buffer를 가짐 (일종의 data register)</li>
  <li>Device controller는 I/O가 끝났을 경우 인터럽트로 CPU에 그 사실을 알림</li>
</ul>

<p>✔️ DMA Controller</p>

<ul>
  <li>CPU와 동일하게 직접 메모리에 접근 가능한 컨트롤러</li>
  <li>I/O device의 작업이 종료되어 localBuffer에 데이터가 적재되면 DMA 컨트롤러가 하드웨어 인터럽트를 CPU 대신 수신하여 데이터를 메모리에 복사한 후 합쳐서 CPU에게 인터럽트를 보낸다</li>
</ul>

<p>✔️ 인터럽트 (Interrupt)</p>

<ul>
  <li>인터럽트 당한 시점의 레지스터와 프로그램 카운터를 저장한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다.</li>
  <li>넓은 의미의 인터럽트
    <ul>
      <li>interuppt (하드웨어 인터럽트) : 하드웨어가 발생시킨 인터럽트</li>
      <li>trap (소프트웨어 인터럽트)</li>
    </ul>
  </li>
  <li>Exception: 프로그램이 오류를 범한 경우</li>
  <li>System Call: 프로그램이 커널함수를 호출하는 경우</li>
  <li>인터럽트 관련 용어
    <ul>
      <li>인터럽트 백터
        <ul>
          <li>해당 인터럽트의 처리 루틴 주소를 가지고 있다.</li>
        </ul>
      </li>
      <li>인터럽트 처리 루틴
        <ul>
          <li>해당 인터럽트를 처리하는 커널 함수</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="3-입출력-io의-수행">3. 입출력 (I/O)의 수행</h2>

<ul>
  <li>모든 입출력 명령은 특권 명령이다.</li>
  <li>사용자 프로그램이 I/O를 하는 방식
    <ul>
      <li>시스템콜(system call)</li>
      <li>사용자 프로그램이 운영체제의 서비스를 받기위해 호출하는 것</li>
    </ul>
  </li>
  <li>trap을 사용하여 인터럽트 벡터의 특정 위치로 이동</li>
  <li>제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동</li>
  <li>올바른 I/O 요청인지 확인 후 I/O 수행</li>
  <li>I/O 완료 시 제어권을 시스템콜 다음 명령으로 옮김</li>
</ul>

<h2 id="3-동기식-입출력">3. 동기식 입출력</h2>

<p>✔️ 동기식 입출력은 어떤 프로그램이 입출력 요청을 했을 때</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>입출력 작업이 완료된 후에야 그 프로그램이 후속 작업을 수행할 수 있는 방식을 말한다.
</code></pre></div></div>

<p>🌟  <strong>동기식 입출력의 실행 방식</strong> 🌟</p>

<blockquote>
  <p>동기식 입출력은 프로그램이 디스크에서 어떤 정보를 읽어오라는 요청을 했을 때 디스크 입출력이 진행되는 동안 그 프로그램의 다음 명령을 수행하지 않고 기다린다.
그러다가 입출력이 완료되어 인터럽트를 통해 완료 사실이 전달된 후에야 CPU의 제어권이 해당 프로그램에게 넘어간다.</p>
</blockquote>

<p>따라서 동기식 입출력에서 CPU는 입출력 연산이 끝날 때까지 인터럽트를 기다리며 자원을 낭비하게 된다.
한편 CPU의 명령 수행 속도는 빠르지만 입출력 장치에서 데이터를 읽어오는 등의 입출력 연산은 상대적으로 느리다.</p>

<p>그럼에도 불구하고 입출력이 완료될 때까지 대기했다가 사용자 프로그램에게 CPU의 제어권을 넘기는 방식은 자원 낭비를 초래한다.</p>

<p>따라서 일반적으로 프로그램이 입출력을 수행 중인 경우 CPU를 입출력을 실행한 프로그램에게서 빼앗아 다른 프로그램에게 할당하고 입출력을 수행중인 프로그램은 봉쇄상태로 변경한다.</p>
<blockquote>

</blockquote>

<h2 id="4-비동기식-입출력">4. 비동기식 입출력</h2>

<p>비동기식 입출력은 프로그램이 디스크 정보를 요청하더라도 프로그램을 봉쇄상태로 이동하지 않고 다음 작업을 수행한다.</p>

<p>🌟  비<strong>동기식 입출력의 실행 방식</strong> 🌟</p>

<blockquote>
  <p>비동기식 입출력은 입출력 연산을 요청한 후에 연산이 끝나기를 기다리는 것이 아니라</p>

  <p>CPU의 제어권을 입출력 연산을 호출한 그 프로그램에게 곧바로 다시 부여하는 것을 말한다.</p>

  <p>어떤 프로그램이 데이터를 디스크에서 읽어오라는 요청을 했을 때 보통은 읽어온 결과를 이용해서 다음 연산을 수행하지만 경우에 따라서는 그 데이터와 관련없이 수행할 수 있는 일이 있을 것이다.</p>

  <p>비동기식 입출력에서는 그러한 작업을 먼저 수행하고, 읽어오는 데이터가 반드시 이어야 수행할 수 있는 일들은 입출력이 완료된 후에 수행하게 된다.</p>

  <p>또한 디스크에서 읽어오는 요청이 아니라 디스크에 쓰는 요청이라면 쓰기 작업이 완료되기 전에도 다음 명령을 수행할 수 있으므로 비동기식 입출력이 사용될 수 있다.</p>

</blockquote>

<h2 id="5-프로그램의-구조와-실행">5. 프로그램의 구조와 실행</h2>

<p>✔️ 프로그램의 구조와 인터럽트</p>

<ul>
  <li>프로그램이 CPU에서 명령을 수행하려면 해당 명령을 담은 프로그램의 주소 영역이 메모리에 올라가 있어야 한다. 이때 프로그램의 주소 영역은 크게 코드, 데이터, 스택 영역으로 구분된다.</li>
</ul>

<p>✔️ 코드영역</p>

<ul>
  <li>코드영역은 작성한 프로그램의 함수들의 코드가 CPU에서 수행할 수 있는 기계어 명령 형태로 변환되어 저장되는 부분</li>
</ul>

<p>✔️ 데이터 영역</p>

<ul>
  <li>전역 변수 등 프로그램이 사용하는 데이터를 저장하는 부분</li>
</ul>

<p>✔️ 스택 영역</p>

<ul>
  <li>함수가 호출될 때 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는 데에 사용되는 공간</li>
</ul>

<p>✔️ 컴퓨터 시스템의 작동 개요</p>

<ul>
  <li>CPU는 빠른 속도로 처리하는 계산 능력은 가지고 있지만, 수행해야하는 작업을 스스로 결정하는 능력은 갖추고 있지 않다.</li>
  <li>
    <p>CPU는 매 시점 메모리의 특정 주소에 존재하는 명령어를 하나씩 읽어와서 그대로 실행한다.</p>

    <p>이때 CPU가 수행해야 할 메모리 주소를 담고 있는 레지스터를 프로그램 카운터라고 부른다.</p>
  </li>
  <li>CPU는 매번 프로그램 카운터가 가리키는 메모리 위치의 명령을 처리하게 된다.</li>
</ul>

<p>✔️ 프로그램의 실행</p>

<ul>
  <li>프로그램이 실행되고 있다는 것은 디스크에 존재하면 실행파일이 메모리에 적재된다는 의미와</li>
  <li>프로그램이 CPU를 할당받고 명령을 수행하고 있는 상태라는 의미이다.</li>
  <li>현재 수행 중인 프로그램을 프로세서(process)라고 부른다.</li>
  <li>각 프로그램은 코드, 데이터, 스택영역과 같은 주소 공간을 별도로 가진다</li>
  <li>프로그램마다 독자적으로 존재하는 주소공간을 가상메모리 또는 논리적 메모리라고 부른다.</li>
</ul>

<hr />

<p><strong>[질문 리스트]</strong></p>

<ol>
  <li>사용자 프로그램이 I/O를 요청했을 때 일어나는 일을 설명해보시오
    <ul>
      <li>사용자는 직접 입출력 장치에 접근할 수 없기 때문에 시스템 콜을 하여 운영체제에게 I/O 작업을 요청한다.
 운영체제는 요청받은 I/O 명령을 사용자 프로그램 모드가 아닌 커널 모드에서 해당 요청에 맞는 처리코드를 수행하게 된다.
 예를 들어 디스크에서 자료를 읽어오는 시스템 콜이라면, CPU가 디스크 컨트롤러에게 데이터를 읽어오라는 명령을 내린다.</li>
    </ul>
  </li>
  <li>DMA 컨트롤러의 기능을 설명해주세요.
    <ul>
      <li>CPU가 입출력 장치들의 메모리 접근 요청에 의해 자주 인터럽트 당하는 것을 막아주어서
 CPU에 발생하는 인터럽트의 빈도를 줄여 CPU를 효율적으로 관리할 수 있게 도와주는 역할을 한다.</li>
      <li>DMA를 사용하면 CPU가 로컬버퍼에서 메모리로 읽어오는 작업을 DMA가 대행한다.</li>
      <li>DMA는 바이트 단위가 아니라 블록이라는 큰 단위로 정보를 메모리로 읽어온 후에 CPU에게 인터럽트를 발생시켜 작업이 끝난 것을 알린다.</li>
    </ul>
  </li>
  <li>시스템콜에 대해 설명해보세요
    <ul>
      <li>시스템 콜이란 사용자 프로그램이 특권명령을 수행하기 위해 운영체제에게 해당 작업을 요청하는 행위이다.
 시스템 콜은 일종의 소프트웨어적인 인터럽스로서 사용자 프로그램이 시스템 콜을 할 경우 트랩이 발생해 CPU의 제어권이 운영체제로 넘어가게 된다.
 그러면 운영체제는 해당 시스템 콜을 처리하기 위한 루틴으로 가서 정의된 명령을 수행한다.</li>
    </ul>
  </li>
</ol>]]></content><author><name>ramram</name></author><category term="OS" /><category term="운영체제" /><category term="컴퓨터 구조" /><category term="OS" /><category term="Operating System" /><category term="반효경" /><category term="운영체제와 정보기술의 원리" /><summary type="html"><![CDATA[🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟]]></summary></entry><entry><title type="html">[운영체제 스터디] 운영체제란 무엇인가?</title><link href="http://localhost:4000/os/os-study-01/" rel="alternate" type="text/html" title="[운영체제 스터디] 운영체제란 무엇인가?" /><published>2022-03-14T00:00:00+09:00</published><updated>2022-03-14T00:00:00+09:00</updated><id>http://localhost:4000/os/os-study-01</id><content type="html" xml:base="http://localhost:4000/os/os-study-01/"><![CDATA[<p>🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟</p>

<h2 id="1-운영체제란-무엇인가">1. 운영체제란 무엇인가?</h2>

<blockquote>
  <p>컴퓨터 하드웨어 바로 윗단에 설치되는 소프트웨어를 말한다.
운영체제는 하드웨어와 소프트웨어를 연결하는 소프트웨어 계층이다.</p>

</blockquote>

<p>✔️ 운영체제의 주요역할</p>

<ul>
  <li>하드웨어 자원을 효율적으로 관리</li>
  <li>사용자가 컴퓨터를 쉽게 다룰 수 있게 GUI 인터페이스 제공</li>
</ul>

<p>✔️ 자원이란 CPU, 메모리, 하드웨어 뿐만 아니라 소프트웨어 자원까지 포함하여 부르는 말이다. 자원관리는 운영체제의 중요한 역할 중 하나이다*</p>

<p>✔️ 협의의 운영체제(커널)</p>

<ul>
  <li>운영체제의 핵심 부분으로 전원이 켜짐과 동시에 메모리에 상주하는 부분</li>
</ul>

<p>✔️ 광의의 운영체제</p>

<ul>
  <li>커널 뿐만 아니라 각종 시스템 유틸리티를 포함한 개념</li>
  <li>항상 메모리에 올려두는 것이 아닌 별도의 프로그램으로서 사실상 운영체제의 일부라고 보긴 어렵지만 운영체제와 함께 설치되기 때문에 넓은 의미로 포함시킨다.</li>
</ul>

<h2 id="2-운영체제의-목적">2. 운영체제의 목적</h2>

<p>✔️ 운영체제의 핵심은 하드웨어를 효율적으로 관리할 수 있게 하는 것</p>

<p>✔️ 주어진 자원으로 최대한의 성능을 내도록</p>

<p>✔️ 사용자가 컴퓨터를 편리하게 사용할 수 있는 환경을 제공하는 것</p>

<ul>
  <li>사용자간의 형평성 있는 자원 분배</li>
</ul>

<p>✔️ 사용자 및 운영체제 자신을 보호</p>

<p>✔️ 프로세스, 파일, 메세지(소프트웨어 자원) 등을 관리</p>

<p>✔️ 운영체제의 자원? (하드웨어)</p>

<ul>
  <li>CPU, RAM, IO 장치 등등</li>
</ul>

<h2 id="3-운영-체제의-분류">3. 운영 체제의 분류</h2>

<h3 id="️동시-작업-가능-여부">✔️ 동시 작업 가능 여부</h3>

<ul>
  <li>단일 작업(sigle tasking)
    <ul>
      <li>한 번에 하나의 작업만 처리</li>
    </ul>
  </li>
  <li>다중 작업(multi tasking)
    <ul>
      <li>동시에 두 개 이상의 작업 처리</li>
      <li>현대의 운영체제 들은 대부분 다중 작업이 가능한 운영체제</li>
    </ul>
  </li>
</ul>

<h3 id="️사용자의-수">✔️ 사용자의 수</h3>

<p>여러 사용자가 동시에 접근할 수 있는지를 기준으로 구분</p>

<ul>
  <li>단일 사용자(sigle user)
예 ) MS-DOS, MS Windows</li>
  <li>다중 사용자(multi user)
예 ) UNIX, NT server</li>
</ul>

<h3 id="️처리-방식">✔️ 처리 방식</h3>

<ul>
  <li>일괄 처리(bath processing)
    <ul>
      <li>작업 요청의 일정량 모아서 한꺼번에 처리</li>
      <li>작업이 완전 종료될 때까지 기다려야함
  예 ) 초기 Punch Card 처리 시스템</li>
    </ul>
  </li>
  <li>시분할(time sharing)
    <ul>
      <li>여러 작업을 수행할 때 컴퓨터 처리 능력을 일정한 시간 단위로 분할하여 사용</li>
      <li>일괄 처리 시스템에 비해 짧은 응답을 가짐</li>
      <li>interactive한 방식</li>
      <li>범용 컴퓨터의 처리방식</li>
    </ul>
  </li>
  <li>실시간(Realtime OS)
    <ul>
      <li>정해진 시간 안에 어떠한 일이 반드시 종료됨이 보장되어야 하는 실시간 시스템을 위한 OS
  예 ) 원자로/공장 제어, 미사일 제어, 반도체 장비, 로보트 제어</li>
    </ul>
  </li>
  <li>실시간 시스템의 개념 확장
    <ul>
      <li>Hard realtime system (경성 실시간 시스템)</li>
      <li>Soft realtime sysytem(연성 실시간 시스템)</li>
    </ul>
  </li>
</ul>

<h3 id="️몇-가지-용어">✔️ 몇 가지 용어</h3>

<ul>
  <li>Multitasking (여러 프로그램이 실행되는 것)</li>
  <li>Multiprogramming (메모리에 여러 프로그램이 올라가있음을 강조)</li>
  <li>Time sharing (Multitasking과 유사하지만 CPU 강조)</li>
  <li>Multiprocess</li>
  <li>Multiprocessor
    <ul>
      <li>하나의 컴퓨터에 CPU(processor)가 여러 개 붙어 있음을 의미</li>
    </ul>
  </li>
  <li>구분
    <ul>
      <li>위의 용어들은 컴퓨터에서 여러 작업을 동시에 수행하는 것을 뜻한다</li>
      <li>Multiprogramming은 여러 프로그램이 메모리에 올라가 있음을 강조</li>
      <li>Time Sharing은 CPU의 시간을 분할하여 나누어 쓴다는 의미를 강조</li>
    </ul>
  </li>
</ul>

<h3 id="️운영-체제의-예">✔️ 운영 체제의 예</h3>

<ul>
  <li>UNIX
    <ul>
      <li>코드의 대부분을 C언어로 작성 됨</li>
      <li>높은 이식성</li>
      <li>최소한의 커널 구조</li>
      <li>복잡한 시스템에 맞게 확장 용이</li>
      <li>소스 코드 공개</li>
      <li>프로그램 개발에 용이</li>
      <li>대형 컴퓨터를 위해 만들어짐</li>
      <li>다양한 버전
        <ul>
          <li>System V, FreeBSD, SunOs, Solaris</li>
          <li>Linux (Unix 소스코드 기반)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>DOS(Disk Operating System)
    <ul>
      <li>MS사에서 1981년 IBM-PC를 위해 개발</li>
      <li>단일 사용자용 운영체제, 메모리 관리 능력의 한계(주 기억 장치 : 640KB)</li>
    </ul>
  </li>
  <li>MS Windows
    <ul>
      <li>MS사의 다중 작업용 GUI 기반 운영 체제</li>
      <li>Plug and Play, 네트워크 환경 강화</li>
      <li>DOS용 응용 프로그램과 호환성 제공</li>
      <li>불안정성 (초창기 Windows)</li>
      <li>풍부한 자원 소프트웨어</li>
    </ul>
  </li>
  <li>Hanheld device를 위한 OS
    <ul>
      <li>PalmOS, Pocket PC (WinCE), Tiny OS</li>
    </ul>
  </li>
</ul>

<h2 id="4-운영체제의-구조">4. 운영체제의 구조</h2>

<p><strong>CPU, Memory, I/O Device, Disk (운영체제는 각 자원들을 관리한다)</strong></p>

<p>✔️ CPU 스케줄링</p>

<ul>
  <li>어떤 프로그램에게 우선순위를 할당할지?
    <ul>
      <li>짧은 간격으로 프로그램을 교체 함 (시분할)</li>
      <li>프로그램이 실행된 순서대로 우선순위를 할당하면 작업이 길어질 경우 나머지 프로그램 응답시간이 길어지기 때문에 사용하지 않는다.</li>
    </ul>
  </li>
</ul>

<p>✔️ 메모리 관리</p>

<ul>
  <li>한정된 메모리를 어떻게 관리하나?
    <ul>
      <li>프로그램 실행에 필요한 최소한의 정보만을 메모리에 올려 둠</li>
      <li>CPU에서 사용될 가능성이 낮은 정보들을 DISK에 내려둔다.</li>
      <li>CPU에서 사용될 가능성이 낮은 정보를 어떻게 판단하는지?
        <ul>
          <li>데이터가 메모리에 올라간 이후로 자주 사용된 데이터이면 사용될 가능성이 높은 정보로 판단한다</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>✔️ DISK 파일관리</p>

<ul>
  <li>DISK 스케줄링 (엘리베이터 스케줄링과 유사함 CPU 스케줄링과는 다르다)
    <ul>
      <li>DISK에 들어온 요청들을 HEAD와 가까운 위치에 들어온 요청이 있다면 먼저 처리하고 DISK HEAD의 이동을 최소화한다.</li>
    </ul>
  </li>
</ul>

<p>✔️ I/O Device</p>

<ul>
  <li>다른 자원들에 비해 느리다.</li>
  <li>입출력관리 인터럽트
    <ul>
      <li>I/O Device가 작업을 처리해야할 경우 CPU에게 인터럽트 신호를 준다</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br /></p>

<hr />

<p><strong>[질문 리스트]</strong></p>

<ol>
  <li>운영체제의 정의를 설명하고 그 기능에 대해 아는대로 설명해주세요
    <ul>
      <li>운영체제는 컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 다른 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층이다.
 운영체제는 사용자가 컴퓨터를 쉽게 다룰 수 있게 GUI 인터페이스 제공하고, 하드웨어 자원을 효율적으로 사용할 수 있게 도와준다.</li>
    </ul>
  </li>
  <li>운영체제 운용 방법 중 하나인 시분할 시스템에 대해서 설명해주세요
    <ul>
      <li>시분할 시스템은 여러 작업을 수행할 때 CPU를 일정한 시간 단위로 프로그램에게 할당하여 처리해줌으로써 각 사용자에게 독립된 컴퓨터를 사용하는 느낌을 준다. 라운드 로빈(Round Robin)방식이라고도 한다.</li>
      <li>하나의 CPU는 같은 시점에서 여러 개의 작업을 동시에 수행할 수 없기 때문에, CPU의 전체 사용시간을 작은 작업 시간량으로 쪼개어그 시간량 동안만 번갈아가면서 CPU를 할당하여 각 작업을 처리하는 방법이다.모든 작업이 동시에 진행되는 것처럼 대화식 처리가 가능하다. 각 작업에 대한 응답시간을 최소화 하는 것이 목적이다.</li>
    </ul>
  </li>
  <li>운영체제의 개념을 좁은 의미와 넓은 의미로 나누어 간략하게 설명하세요
    <ul>
      <li>운영체제의 좁은 의미는 운영체제 커널을 의미하고 커널은 운영체제의 핵심 부분임으로 전원이 켜짐과 동시에 메모리에 상주합니다.
운영체제의 넓은 의미는 운영체제의 커널과 각종 주변 유틸리티 시스템을 포함한 개념입니다<em>.</em></li>
    </ul>
  </li>
</ol>]]></content><author><name>ramram</name></author><category term="OS" /><category term="운영체제란?" /><category term="운영체제의 목적" /><category term="운영체제 구조" /><category term="Operating System" /><category term="반효경" /><category term="운영체제와 정보기술의 원리" /><summary type="html"><![CDATA[🌟 본 게시물은 이화여자대학교 반효경 교수님 강의를 참고로 작성한 게시물 입니다. 틀린 내용은 꼬옥 지적 부탁드립니다 ! 🌟]]></summary></entry></feed>