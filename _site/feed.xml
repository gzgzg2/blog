<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-03-24T10:34:02+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">나비랑 나리 주인님의 블로그</title><subtitle>Spring back-end 개발자 람람</subtitle><author><name>ramram</name></author><entry><title type="html">[운영체제 스터디] 다단계 큐 스케줄링과 프로세스 동기화</title><link href="http://localhost:4000/os/os-study-05/" rel="alternate" type="text/html" title="[운영체제 스터디] 다단계 큐 스케줄링과 프로세스 동기화" /><published>2022-03-23T00:00:00+09:00</published><updated>2022-03-23T00:00:00+09:00</updated><id>http://localhost:4000/os/os-study-05</id><content type="html" xml:base="http://localhost:4000/os/os-study-05/"><![CDATA[<h2 id="1-multilevel-queue-singlecore-cpu-기준">1. Multilevel Queue (SingleCore Cpu 기준)</h2>

<p>✔️ Multilevel Feedback Queue보다 프로세스 차별적인 방식</p>

<p>✔️ Ready queue를 여러 개로 분할</p>

<ul>
  <li>foreground (interactive)</li>
  <li>background (batch - no human interaction)</li>
</ul>

<p>✔️  각 큐는 독립적인 스케줄링 알고리즘을 가짐</p>

<ul>
  <li>foreground - RR (라운드 로빈)
    <ul>
      <li>사용자와 대화하는 프로세스이기 때문에 응답시간이 짧은 것이 중요하다</li>
    </ul>
  </li>
  <li>background - FCFS (선입선출)
    <ul>
      <li>사용자와 대화없이 CPU만 사용하는 batch형 작업이기 때문에 응답시간이 빠를 필요가 없다</li>
    </ul>
  </li>
</ul>

<p>✔️  큐에 대한 스케줄링이 필요</p>

<ul>
  <li>Fixed priority scheduling
    <ul>
      <li>serve all from foreground then from background</li>
      <li>Possibility of starvation
        <ul>
          <li>우선순위가 높은 작업이 종료되지 않으면 우선순위가 낮은 프로세스는 영원히 실행되지 못하는 문제가 발생할 수 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Time slice
    <ul>
      <li>각 큐에  CPU time을 적절한 비율로 할당</li>
      <li>starvation을 막기위해 전체 CPU 사용시간을 우선순위가 높은 foreground 작업에 80% 할당하고 우선순위가 낮은 background 작업에 20%를 할당하게 한다.</li>
    </ul>
  </li>
</ul>

<h2 id="2-multilevel-feedback-queue-singlecore-cpu-기준">2. Multilevel Feedback Queue (SingleCore Cpu 기준)</h2>

<p>✔️  프로세스가 다른 큐로 이동할 수 있음</p>

<p>✔️  에이징(aging)을 이와 같은 방식으로 구현할 수 있음</p>

<p>✔️ Multilevel-feedback-queue scheduler를 이루고 있는 요소들</p>

<ul>
  <li>Queue의 수</li>
  <li>각 큐의 scheduling algorithm</li>
  <li>Process를 상위 큐로 보내는 기준</li>
  <li>Process를 하위 큐로 내쫓는 기준</li>
  <li>프로세스가 CPU 서비스를 받으려 할 때 들어갈 큐를 결정하는 기준</li>
</ul>

<p>✔️  처음 실행되는 작업은 우선순위를 가장 높게 받음</p>

<h3 id="21-multilevel-feedback-queue-예시">2.1 Multilevel Feedback Queue 예시</h3>

<p>✔️ Three queues:</p>

<ul>
  <li>Q0 - time quantum 8 milliseconds</li>
  <li>Q1 -  time quantun 16 milliseconds</li>
  <li>Q2 - FCFS (선입선출)</li>
</ul>

<p>✔️ Schduling</p>

<ul>
  <li>새로운 작업이 Q0으로 들어간다.</li>
  <li>CPU를 잡아서 할당 시간 8milliseconds 동안 수행된다</li>
  <li>Q0에서 할당받은 시간내에 작업을 다 끝내지 못했으면 Q1로 내려간다.</li>
  <li>Q1에 줄서서 기다렸다가 CPU를 할당받고 16ms 동안 수행된다.</li>
  <li>Q1에서 할당받은 시간내에 작업을 끝내지 못한 경우 Q2로 쫓겨난다.</li>
</ul>

<h2 id="3-멀티코어-cpu의-경우-고려해야할-점">3. 멀티코어 CPU의 경우 고려해야할 점</h2>

<blockquote>
  <p>CPU가 여러 개인 경우 스케줄링은 더욱 복잡해진다.</p>

</blockquote>

<p>✔️ Homogeneous processor인 경우</p>

<ul>
  <li>Queue에 한줄로 세워서 각 프로세서가 알아서 꺼내가게 할 수 있다.</li>
  <li>반드시 특정 프로세스에세 수행되어야 하는 프로세스가 있는 경우에는 문제가 복잡해진다.</li>
</ul>

<p>✔️ Load sharing</p>

<ul>
  <li>일부 프로세서에 job이 몰리지 않도록 부하를 적절히 공유하는 메커니즘이 필요하다</li>
  <li>별개의 큐를 두는 방법 vs 공동 큐를 사용하는 방법</li>
</ul>

<p>✔️ Symmetric Multiprocessing (SMP)</p>

<ul>
  <li>각 프로세서가 각자 알아서 스케줄링 결정</li>
</ul>

<p>✔️ Asymmetric multiprocessing</p>

<ul>
  <li>비대칭형 다중 처리기
    <ul>
      <li>하나의 프로세서가 시스템 데이터의 접근과 공유를 책임지고 나머지 프로세서는 거기에 따라 움직이는 방식</li>
    </ul>
  </li>
  <li>대칭형 다중 처리기
    <ul>
      <li>CPU가 각자 알아서 스케줄링하는 방식</li>
    </ul>
  </li>
</ul>

<h2 id="4-real-time-scheduling">4. Real-Time Scheduling</h2>

<p>✔️ Hard real-time systems</p>

<ul>
  <li>Hard real-time task는 정해진 시간 안에 반드시 끝내도록 스케줄링해야 함</li>
</ul>

<p>✔️ Soft real-time computing</p>

<ul>
  <li>Soft real-time task는 일반 프로세스에 비해 높은 priority를 갖도록 해야 함</li>
</ul>

<p>✔️ EDF (Earlist Deadline scheduling)</p>

<ul>
  <li>실시간 환경에서는 먼저 온 요청보다 데드라인이 다가온 요청을 먼저 처리하는 스케줄링</li>
  <li>연성 실시간 시스템처럼 일반 작업과 VOD 작업 등이 혼합된 환경에서는 데드라인이 존재하는 프로세스에게 일반 프로세스보다 높은 우선 순위를 할당한다.</li>
</ul>

<h2 id="5-thread-scheduling">5. Thread Scheduling</h2>

<p>✔️ Local Scheduling</p>

<ul>
  <li>User level thread의 경우 사용자 수준의 thread library에 의해 어떤 thread를 스케줄링할지 결정
    <ul>
      <li>이 경우에 운영체제는 해당 thread의 존재를 알지 못한다.</li>
    </ul>
  </li>
</ul>

<p>✔️ Global Sheduling</p>

<ul>
  <li>Kernel level thread의 경우 일반 프로세스와 마찬 가지로 커널의 단기 스케줄러가 어떤 thread를 스케줄할지 결정</li>
</ul>

<h2 id="6-process-synchronization">6. Process Synchronization</h2>

<blockquote>
  <p>멀티 프로세서 시스템의 경우 메모리 주소공간을 공유하는 CPU 프로세스가 여럿 있는 경우 Race Condition의 가능성이 있다. 아래 내용들은 Race Condition 발생 원인과 이를 해결하기 위한 프로세스 동기화 방법이다.</p>

</blockquote>

<p>✔️ <strong>Race Condition?</strong></p>

<blockquote>
  <p>여러 프로세스들이 동시에 공유데이터에 접근하여 경쟁하는 상태이다.</p>

  <p>여러 프로세스가 동시에 공유데이터에 접근하게되면 데이터의 불일치 문제를 발생시킬 수 있다.</p>

  <p>일관성 유지를 위해서는 협력 프로세스간의 실행 순서를 정해주는 메커니즘이 필요하다</p>

</blockquote>

<p>✔️ <strong>OS에서 Race Condition은 언제 발생하는가?</strong></p>

<ul>
  <li>Kernel에서 수행 중 인터럽트 발생 시</li>
  <li>Process가 system call을 하여 kernel mode로 수행 중인데 context switch가 일어나는 경우</li>
  <li>N 개의 프로세스가 공유 데이터를 동시에 사용하기를 원하는 경우</li>
</ul>

<p>‼️  <strong>한 프로세스가 공유 데이터를 사용하고 있을 때 다른 프로세스가 접근하면 안되는 이유</strong> ‼️</p>

<ul>
  <li>각 프로세스의 <strong>code segment</strong>에는 공유 데이터를 접근하는 코드인 <strong>ciritical section</strong>이 존재한다.</li>
  <li>이 경우에 하나의 프로세스가 <strong>critical section</strong>에 있을 때 다른 모든 프로세스는 <strong>critical section</strong>에 들어갈 수 없어야 한다.</li>
</ul>

<p><strong>✔️ Race Condition은 어떻게 방지하는가?</strong></p>

<ul>
  <li>Process가 system call을 하여 kernel mode로 수행 중인데 context switch가 일어나는 경우
    <ul>
      <li>커널 모드에서 수행 중일 때는 CPU를 선점하지 않고 커널모드에서 사용자 모드로 돌아갈 때 CPU를 선점하는 방식</li>
    </ul>
  </li>
  <li>Multiprocessor에서 shared memory 내의 kernel data
    <ul>
      <li>방법 1) 한번에 하나의 CPU만이 커널에 들어갈 수 있게 하는 방법</li>
      <li>방법 2) 커널 배우에 있는 각 공유 데이터에 접근할 때마다 그 데이터에 대한 lock / unlock을 하는 방법</li>
    </ul>
  </li>
</ul>]]></content><author><name>ramram</name></author><category term="OS" /><category term="멀티 피드백 큐" /><category term="멀티레벨 큐" /><category term="프로세스 동기화" /><category term="Operating System" /><summary type="html"><![CDATA[1. Multilevel Queue (SingleCore Cpu 기준)]]></summary></entry><entry><title type="html">[운영체제 스터디] 프로세스 생성과 프로세스의 협력</title><link href="http://localhost:4000/os/os-study-04/" rel="alternate" type="text/html" title="[운영체제 스터디] 프로세스 생성과 프로세스의 협력" /><published>2022-03-22T00:00:00+09:00</published><updated>2022-03-22T00:00:00+09:00</updated><id>http://localhost:4000/os/os-study-04</id><content type="html" xml:base="http://localhost:4000/os/os-study-04/"><![CDATA[<h2 id="1-프로세스와-관련한-시스템-콜">1. 프로세스와 관련한 시스템 콜</h2>

<p>✔️ fork()</p>

<ul>
  <li>create a child (copy)</li>
</ul>

<p>✔️ exec()</p>

<ul>
  <li>overlay new image</li>
</ul>

<p>✔️ wait()</p>

<ul>
  <li>sleep until child is done</li>
</ul>

<p>✔️ exit()</p>

<ul>
  <li>frees all the resources, notify parent</li>
</ul>

<h2 id="2-프로세스-생성-process-creation">2. 프로세스 생성 (Process Creation)</h2>

<p>‼️  <strong><em>Copy-on-wirte(COW)</em></strong></p>

<ul>
  <li>자원의 내용이 변경될 때 메모리 영역을 복제하고 변경되지 않을 경우에는 부모 프로세스의 자원을 공유한다.</li>
</ul>

<p>✔️  부모프로세스(Parent process)가 자식 프로세스(chlidren process) 생성</p>

<p>✔️ 프로세스의 트리(계층 구조) 형성</p>

<p>✔️ 프로세스는 자원을 필요로 함</p>

<ul>
  <li>운영체제로부터 받는다</li>
  <li>부모와 공유한다.</li>
</ul>

<p>✔️ 자원의 공유</p>

<ul>
  <li>부모와 자식이 모든 자원을 공유하는 모델</li>
  <li>일부를 공유하는 모델
    <ul>
      <li>보통은 공유하는 모델보다 공유하지않는 모델이 대부분이다.</li>
    </ul>
  </li>
  <li>전혀 공유하지 않는 모델
    <ul>
      <li>부모와 자식 프로세스가 자원을 공유하지 않을 경우엔 자원을 두고 부모와 자식이 경쟁하게 된다.</li>
    </ul>
  </li>
</ul>

<p>✔️ 수행(Execution)</p>

<ul>
  <li>부모와 자식이 공존하며 수행되는 모델
    <ul>
      <li>부모와 자식이 공존하며 수행되는 모델은 자식과 부모가 CPU를 획득하기 위해 경쟁하는 관계가 된다.</li>
    </ul>
  </li>
  <li>자식이 종료(terminate)될 때까지 부모가 기다리는(wait)모델
    <ul>
      <li>자식 프로세스가 종료될 때까지 부모는 봉쇄상태에 머물러 있다가 자식프로세스가 종료된 이후에 CPU를 얻을 수 있는 권한이 생긴다.</li>
      <li>일반적인 봉쇄상태와 다르게 자원을 기다리며 줄 서 있는 것이 아니다.</li>
    </ul>
  </li>
</ul>

<p>✔️ 주소 공간 (Address space)</p>

<ul>
  <li>자식은 부모의 공간을 복사함 (binary and OS data)</li>
  <li>자식은 그 공간에 새로운 프로그램을 올림</li>
</ul>

<p>✔️ 유닉스의 예</p>

<ul>
  <li>fork()
    <ul>
      <li>fork() 시스템 콜이 새로운 프로세스를 생성</li>
      <li>부모를 그대로 복사 (OS data execpt PID + binary)
        <ul>
          <li>주소공간은 따로 가지고 있지만 주소공간의 내용은 동일한 내용을 갖게 된다 (문맥이 동일하다)</li>
          <li>문맥이 동일하기 때문에 부모 프로세스의 프로그램 카운터 지점부터 수행하게 된다.</li>
        </ul>
      </li>
      <li>주소 공간 할당</li>
      <li>부모 프로세스와 다른 작업을 수행할 수 있지만, 이는 조건문에 의한 분기일 뿐 사실상 부모 프로세스와 동일한 코드의 내용을 갖는다.</li>
    </ul>
  </li>
  <li>exec()
    <ul>
      <li>exec() 시스템 콜을 통해 새로운 프로그램으로 주소 공간을 덮어씌울 수 있다.</li>
      <li>부모 프로세스와 문맥이 달라지므로 부모프로세스의 실행시점부터 수행하지 않고 처음부터 실행하게 된다.</li>
    </ul>
  </li>
</ul>

<h2 id="3-프로세스-종료-process-termination">3. 프로세스 종료 (Process Termination)</h2>

<p>✔️ exit()</p>

<ul>
  <li>프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려준다(exit)</li>
  <li>자식이 부모에게 output data를 보냄 (via wait)</li>
  <li>프로세스의 각종 자원들이 운영체제에게 반납됨</li>
  <li>명시적으로 exit()를 호출하지 않았더라도 컴파일러가 main 함수가 리턴되는 위치에 exit()를 넣어줌</li>
</ul>

<p>✔️ abort()</p>

<ul>
  <li>자식이 할당 자원의 한계치를 넘어섬</li>
  <li>자식에게 할당된 태스크가 더 이상 필요하지 않음</li>
  <li>키보드로 kill, break를 친 경우</li>
  <li>부모가 종료(exit)하는 경우
    <ul>
      <li>운영체제는 부모 프로세스가 종료하는 경우 자식이 더 이상 수행되도록 두지 않는다.</li>
      <li>단계적인 종료</li>
    </ul>
  </li>
</ul>

<h2 id="4-자식-프로세스-생성">4. 자식 프로세스 생성</h2>

<p>✔️ 부모 프로세스가 자식 프로세스를 생성할 때의 플로우</p>

<ol>
  <li>부모 프로세스가 자식 프로세스 생성을 위해 fork() 시스템 콜을 발생시킨다.</li>
  <li>fork() 시스템 콜이 발생하면 CPU의 제어권이 커널로 넘어간다.</li>
  <li>커널은 fork()를 호출한 프로세스를 복제하여 자식 프로세스를 생성한다.</li>
</ol>

<blockquote>
  <p>부모 프로세스를 복제하여 생성된 자식 프로세스는 현실세계의 부모 자식과는 달리 자신을 똑닮은 자식이 아닌, 자신의 외모와 기억이 전부 동일한 복제인간을 생성하는 것과 같다.</p>

  <p>복제된 대상은 ‘복제되었다’는 기억을 가지는 것이 아니라 부모와 마찬가지로 방금 전에 자기 자신을 ‘복제했다’는 기억을 가지게 된다. 자식 프로세스가 복제된 프로세스라는 사실을 알 수 있는 단서는 fork() 함수의 결과값이 원본 프로세스는 양수를 가지고 복제본은 0을 갖는다는 차이점이 있다.</p>

</blockquote>

<h2 id="5-프로세스간의-협력">5. 프로세스간의 협력</h2>

<blockquote>
  <p>프로세스는 각자 자신만의 독립적인 공간을 가지고 수행되며 프로세스가 다른 프로세스의 주소공간을 참조하는 것은 허용되지 않는다. 따라서 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미칠 수 없다.</p>

</blockquote>

<p>🤔 <strong><em>독립적인 프로세스가 서로 협력하면 프로세스 작업의 효율성이 증가할 것 같은데..?</em></strong></p>

<p>원칙적으론 프로세스는 다른 프로세스의 수행에 영향을 미칠 수 없지만, 프로세스가 협력했을 때 작업 효율이 증가할 수 있기 때문에 운영체제는 여러가지 매커니즘을 제공한다. 대표적인 매커니즘으론 IPC가 있다.</p>

<p>✔️  프로세스 간 협력 메커니즘 (IPC: Interprocess Communication)</p>

<ul>
  <li>하나의 컴퓨터안에서 실행 중인 서로 다른 프로세스 간에 발생하는 통신</li>
  <li>프로세스간의 통신과 동기화를 이루기 위한 메커니즘</li>
  <li>메시지 전달 방식과 공유 메모리 방식이 있음.
    <ul>
      <li>두 방식의 차이는 프로세스 사이에 공유 데이터를 사용하는가, 그렇지 않는가에 있다</li>
    </ul>
  </li>
  <li>메시지를 전달하는 방법
    <ul>
      <li>Massage passing
        <ul>
          <li>커널을 통해 메시지 전달</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>주소공간을 공유하는 방법
    <ul>
      <li>Shared memory
        <ul>
          <li>서로 다른 프로세스 간에도 일부 주소 공간을 공유하게 하는 shared momory 메커니즘이 있음</li>
        </ul>
      </li>
      <li>🤔 Thread
        <ul>
          <li>thread는 사실상 하나의 프로세스이므로 프로세스 간 협렵으로 보기는 어렵지만 동일한 process를 구성하는 thread들 간에는 주소 공간을 공유하므로 협력이 가능</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="️ipc의-메세지-전달-방식-massage-passing">‼️ IPC의 메세지 전달 방식 (Massage passing)</h3>

<p>✔️ Message system</p>

<ul>
  <li>프로세스 사이에 공유 변수(shared variable)를 일체 사용하지 않고 통신하는 시스템</li>
</ul>

<p>✔️ Direct Communication</p>

<ul>
  <li>통신하려는 프로세스의 이름을 명시적으로 표시</li>
</ul>

<p><img width="583" alt="스크린샷 2022-03-20 오후 8 03 43" src="https://user-images.githubusercontent.com/56028408/159159351-86081a47-49b8-424c-9490-3dd586acbc92.png" /></p>

<p>✔️ Indirect Communication</p>

<ul>
  <li>mailbox (또는 port)를 통해 메세지를 간접 전달</li>
</ul>

<p><img width="583" alt="스크린샷 2022-03-20 오후 8 04 12" src="https://user-images.githubusercontent.com/56028408/159159348-1860f708-522d-487f-ab62-543c36d90581.png" /></p>

<p>💡 <strong>Massage passing</strong></p>

<blockquote>
  <p>공유데이터를 사용하지 않는 프로세스들이 메시지를 주고받으며 통신하는 방식을 사용한다. 이때 두 프로세스의 주소공간이 다르므로 메시지를 직접 전달할 수 없기 때문에 커널이 그 역할을 대신한다.</p>

  <p>메시지 통신을 하는 시스템은 커널에 의해 send와 receive라는 두 가지 연산을 제공받게 된다. 이 두 연산을 통해 프로세스는 전달할 메세지를 운영체제에게 시스템 콜 방식으로 요청해 전달할 수 있다.</p>

  <p>통신하기를 원하는 두 프로세스는 커뮤니케이션 링크를 생성한 후 send()와 receive()를 이용해서 메시지를 주고받게 된다.</p>

</blockquote>]]></content><author><name>ramram</name></author><category term="OS" /><category term="프로세스 생성" /><category term="부모 프로세스" /><category term="자식 프로세스" /><category term="Operating System" /><summary type="html"><![CDATA[1. 프로세스와 관련한 시스템 콜]]></summary></entry><entry><title type="html">[운영체제 스터디] 프로세스의 특성과 CPU 스케줄링</title><link href="http://localhost:4000/os/os-study-04-02/" rel="alternate" type="text/html" title="[운영체제 스터디] 프로세스의 특성과 CPU 스케줄링" /><published>2022-03-22T00:00:00+09:00</published><updated>2022-03-22T00:00:00+09:00</updated><id>http://localhost:4000/os/os-study-04-02</id><content type="html" xml:base="http://localhost:4000/os/os-study-04-02/"><![CDATA[<h2 id="1cpu-and-io-bursts-in-program-execution">1. CPU and I/O Bursts In Program Execution</h2>

<blockquote>
  <p>어떤 프로그램이든 프로그램을 실행한다는 것은 CPU Burst와 I/O Burst를 반복하게 되는 것이다.</p>

</blockquote>

<p>❓CPU Burst</p>

<ul>
  <li>CPU에서 instruction을 수행하는 것</li>
</ul>

<p>❓ I/O Burst</p>

<ul>
  <li>I/O를 instruction을 수행하는 작업</li>
</ul>

<h3 id="프로세스의-특성-분류">💡 프로세스의 특성 분류</h3>

<p>✔️ I/O-bound process</p>

<ul>
  <li>CPU를 잡고 계산하는 시간보다 I/O에 많은 시간이 필요한 Job</li>
  <li>(many short CPU bursts)</li>
</ul>

<p>✔️CPU-bound process</p>

<ul>
  <li>계산 위주의 job</li>
  <li>(few very long CPU bursts)</li>
</ul>

<h3 id="cpu-burst-time의-분포">💡 CPU-burst Time의 분포</h3>

<p><img width="713" alt="image" src="https://user-images.githubusercontent.com/56028408/159224088-360d62a2-4066-4a8b-99cc-4935e80941d8.png" /></p>

<p>✔️ 여러 종류의 job(=process)이 섞여 있기 때문에 CPU 스케줄링이 필요하다.</p>

<ul>
  <li>Interactive job에게 적절한 reponse 제공 요망</li>
  <li>CPU와 I/O 장치 등 시스템 자원을 골고루 효율적으로 사용해야 함</li>
</ul>

<h2 id="2-cpu-scheduler--dispatcher">2. CPU Scheduler &amp; Dispatcher</h2>

<p>✔️ CPU Scheduler</p>

<ul>
  <li>Ready 상태의 프로세스 중에서 이번에 CPU를 줄 프로세스를 고른다.</li>
</ul>

<p>✔️ Dispatcher</p>

<ul>
  <li>CPU의 제어권을 CPU scheduler에 의해 선택된 프로세스에게 넘긴다</li>
  <li>이 과정을 context switch(문맥 교환)라고 한다.</li>
</ul>

<p>✔️ CPU 스케줄링이 필요한 경우</p>

<ol>
  <li>Running → Blocked (예: I/O 요청하는 시스템 콜)</li>
  <li>Running → Ready (예: 할당시간만료로 timer interrupt)</li>
  <li>Blocked → Ready (예: I/O 완료후 interrupt)</li>
  <li>Terminate</li>
</ol>

<blockquote>
  <p><strong>I/O를 발생시켜 Blocked 되는 경우나 Terminate에서의 스케줄링은 강제로 빼앗지 않고 자진반납(nonpreemptive)한다. 다른 상태는 모두 강제로 빼앗기는(preemptive) 경우이다.</strong></p>

</blockquote>

<p>❓<strong>nonpreemptive = 비선점형 방식</strong></p>

<ul>
  <li>CPU를 획득한 프로세스가 스스로 CPU를 반납하기 전까지는 CPU를 빼앗기지 않음</li>
</ul>

<p><strong>❓preemptive = 선점형 방식</strong></p>

<ul>
  <li>프로세스가 CPU를 계속 사용하길 원한다고 하더라도 강제로 빼앗길 수 있음</li>
</ul>

<h2 id="3-dispatcher">3. Dispatcher</h2>

<blockquote>
  <p>CPU 스케줄러가 어떤 프로레스에게 CPU를 할당해야 할지 결정하고나면 선택된 프로세스에게 실제로 CPU를 이양하는 작업이 필요하다.</p>

  <p>이와 같이 새롭게 선택된 프로세스가 CPU를 할당받고 작업을 수행할 수 있도록 환경설정 하는 운영체제의 코드를 디스패처라고 부른다.</p>

  <p>디스패처는 현재 수행 중이던 프로세스의 문맥(context)을 그 프로세스의 PCB에 저장하고, 새롭게 선택된 프로세스의 문맥을 PCB로부터 복원한 후 그 프로세스에게 CPU를 넘기는 작업을 수행한다.</p>

  <p>디스패처가 하나의 프로세스를 정지시키고 다른 프로세스에게 CPU를 전달하기까지 걸리는 시간을 디스패치 지연시간(dispatch Latency)이라고 하며, 디스패치 지연시간의 대부분은 문맥교환 오버헤드에 해당된다.</p>

</blockquote>

<h2 id="4-스케줄링-알고리즘">4. 스케줄링 알고리즘</h2>

<h3 id="1-선입선출-스케줄링fcfs"><strong>1. 선입선출 스케줄링(FCFS)</strong></h3>

<blockquote>
  <p>선입선출(First-Come First-Served: FCFS) 스케줄링은 프로세스가 준비큐에 도착한 시간 순서대로 CPU를 할당하는 방식을 말한다.  이 방식에서는 CPU를 먼저 요청한 프로세스에게 CPU를 할당하고, 해당 프로세스가 자발적으로 CPU를 반납할 때까지 빼앗기지 않는다.</p>

</blockquote>

<p><strong>1.1 선입선출 스케줄링의 단점</strong></p>

<ul>
  <li>도착한 순서대로 CPU 작업을 처리하기 때문에 CPU Burst가 짧은 작업이어도 도착시간이 늦어지게 되면, CPU Burst가 높은 작업이 끝날 때까지 기다려야 하므로 사용량에 비해 대기시간이 길어진다는 단점이 있다. 이를 콘보이 현상 이라고 하며, 이는 FCFS 스케줄링의 대표적인 단점에 해당된다.</li>
</ul>

<hr />

<h3 id="2-최단작업-우선-스케줄링-sjf"><strong>2. 최단작업 우선 스케줄링 (SJF)</strong></h3>

<blockquote>
  <p>최단작업 우선(Shortest-job First: SFJ) 스케줄링 알고리즘은 CPU 버스트가 가장 짧은 프로세스에게 CPU를 제일 먼저 할당하는 방식이다. 이와 같은 할당 방식을 통해 CPU 버스트가 짧은 프로세스가 CPU를 먼저 사용하고 준비 큐를 빠져나가게 되면 프로세스들이 준비 큐에서 기다리는 전체적인 시간이 줄어들게 된다. SJF 스케줄링 알고리즘은 평균 대기시간을 가장 짧게 하는 최적 알고리즘으로 알려져 있다.</p>

</blockquote>

<p><strong>2.1 선점방식</strong></p>

<ul>
  <li>진행중인 작업의 남은 CPU 버스트보다 짧은 작업이 도착하면 더 짧은 작업에게 CPU를 할당하는 방식 이러한 방식을 SRTF(Shortest Remaining Time First)라고도 부른다.</li>
  <li>프로세스들이 준비 큐에 도착하는 시간이 불규칙한 경우 선점형방식이 프로세스들의 평균 대기시간을 최소화 하는 최적의 알고리즘이 된다.</li>
  <li>일반적인 시분할 환경에서는 중간중간에 새로운 프로세스가 도착하는 경우가 발생하므로 선점형 방식이 평균 대기시간을 가장 많이 줄일 수 있다.</li>
</ul>

<p><strong>2.2 비선점방식</strong></p>

<ul>
  <li>먼저 도착한 작업의 CPU 수행이 끝나서 스스로 CPU를 내어놓을 때까지 스케줄링을 하지 않는다.</li>
  <li>일련의 프로세스들이 준비큐에 한번에 도착하고 그 후에는 따로 도착하지 않는 환경에선 선점형방식과 같은 대기시간 결과를 나타내기도 한다.</li>
</ul>

<p><strong>2.1 SFJ 스케줄링의 단점</strong></p>

<ul>
  <li>CPU 버스트가 짧은 프로세스가 계속 도착할 경우 CPU 버스트가 긴 프로세스는 영원히 CPU를 할당받지 못할 수 있다. 이를 기아 현상(starvation)이라고 한다.</li>
</ul>

<hr />

<h3 id="3-우선순위-스케줄링"><strong>3. 우선순위 스케줄링</strong></h3>

<blockquote>
  <p>우선순위 스케줄링(priority scheduling)이란 준비 큐에서 기다리는 프로세스들 중 우선순위가 가장 높은 프로세스에게 제일 먼저 CPU를 할당하는 방식을 말한다. 이때 우선순위는 우선순위값(priority number)을 통해 표시하며 우선순위값이 작을수록 높은 우선순위를 가지는 것으로 가정한다.</p>

  <p>우선순위 스케줄러도 비선점형방식과 선점형방식이 있는데 이는 SJF 알고리즘의 비선점형,선점형과 동일한 방식에서 CPU 버스트 시간 기준이 아닌, 우선순위 기준으로 변경된 것이다.</p>

</blockquote>

<p><strong>3.1 우선순위를 정하는 방법</strong></p>

<ul>
  <li>CPU 버스트 시간으로 우선순위 선정
    <ul>
      <li>이러한 경우 SJF 알고리즘과 동일한 의미를 가지게 됨</li>
    </ul>
  </li>
  <li>시스템과 관련된 동일한 작업을 수행하는 프로세스의 우선순위를 높게 부여하는 것</li>
  <li></li>
</ul>

<p><strong>3.2 우선순위 스케줄링 단점</strong></p>

<ul>
  <li>우선순위 스케줄러 방식에서도 기아현상이 발생할 수 있다. 우선순위가 높은 프로세스가 계속 도착하는 상황에서 우선순위가 낮은 프로세스는 CPU를 얻지못한 채 계속 기다려야 할 수 있기 때문이다. 이러한 단점을 해결하기 위해 노화(aging) 기법이 존재한다.</li>
</ul>

<p><strong>3.3 노화기법 (aging)</strong></p>

<ul>
  <li>노화 기법이란 기다리는 시간이 길어지면 우선순위를 조금씩 높여, 언젠가는 가장 높은 우선순위가 되어 CPU를 할당받을 수 있게 해주는 방법이다.</li>
</ul>

<hr />

<h3 id="4-라운드로빈-스케줄링"><strong>4. 라운드로빈 스케줄링</strong></h3>

<blockquote>
  <p>라운드로빈 스케줄링은 시분할 시스템 성질을 가장 잘 활용한 새로운 의미의 스케줄링 방식이라 할 수 있다. 라운드로빈 스케줄링에서는 각 프로세스가 CPU를 연속적으로 사용할 수 있는 시간이 특정 시간으로 제한된다.</p>

  <p>제한된 시간이 경과하면 해당 프로세스로부터 CPU를 회수해 준비 큐에 줄 서 있는 다른 프로세스에게 CPU를 할당한다.</p>

  <p>라운드로빈 스케줄링의 할당시간을 너무 길게 설정하면 이는 FCFS와 같은 결과를 나타나게 되고, 너무 짧게 설정할 경우엔 CPU 프로세스가 빈번하게 변경되어 문맥교환 오버헤드가 발생하게 된다. 따라서 일반적으로 할당시간은 수십 밀리초 정도의 규모로 설정하게 된다.</p>

</blockquote>]]></content><author><name>ramram</name></author><category term="OS" /><category term="CPU 스케줄링" /><category term="Round Robin" /><category term="SJF 스케줄링" /><category term="FCFS" /><category term="우선순위 스케줄링" /><summary type="html"><![CDATA[1. CPU and I/O Bursts In Program Execution]]></summary></entry><entry><title type="html">[운영체제 스터디] 프로세스와 쓰레드</title><link href="http://localhost:4000/os/os-study-03/" rel="alternate" type="text/html" title="[운영체제 스터디] 프로세스와 쓰레드" /><published>2022-03-16T00:00:00+09:00</published><updated>2022-03-16T00:00:00+09:00</updated><id>http://localhost:4000/os/os-study-03</id><content type="html" xml:base="http://localhost:4000/os/os-study-03/"><![CDATA[<h2 id="1-프로세스">1. 프로세스</h2>

<blockquote>
  <p>“Process is a program in execution”</p>

</blockquote>

<p>✔️ 프로세스의 문맥(context)</p>

<ul>
  <li>CPU 수행 상태를 나타내는 하드웨어 문맥
    <ul>
      <li>하드웨어 문맥
        <ul>
          <li>Program Counter</li>
          <li>각종 register</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>프로세스의 주소 공간 (프로세스마다 각자의 주소공간을 가지고 있음)
    <ul>
      <li>code, data, stack</li>
    </ul>
  </li>
  <li>프로세스 관련 커널 자료 구조
    <ul>
      <li>PCB (Process Control Block)</li>
      <li>Kernel stack</li>
    </ul>
  </li>
</ul>

<p>✔️ 프로세스는 상태가 변경되며 수행된다</p>

<ul>
  <li>Running
    <ul>
      <li>CPU를 잡고 Instruction을 수행중인 상태</li>
    </ul>
  </li>
  <li>Ready
    <ul>
      <li>CPU를 기다리는 상태(메모리 등 다른 조건을 모두 만족하고)</li>
    </ul>
  </li>
  <li>Blocked (wait, sleep)
    <ul>
      <li>CPU를 주어도 당장 Instruction을 수행할 수 있는 상태</li>
      <li>Process 자신이 요청한 event가 즉시 만족되지 않아 이를 기다리는 상태</li>
    </ul>
  </li>
  <li>Suspended (stopped)
    <ul>
      <li>외부적인 이유로 프로세스의 수행이 정지된 상태
        <ul>
          <li>사용자가 프로그램을 일시 정지시킨 경우 (break key)</li>
          <li>메모리에 너무 많은 프로세스가 올라와 있을 때</li>
          <li>시스템이 특정한 이유로 프로세스를 잠시 중단시킨 경우</li>
        </ul>
      </li>
      <li>프로세스는 통째로 디스크에 swap out 된다.</li>
    </ul>
  </li>
</ul>

<p>❗New : 프로세스가 생성중인 상태</p>

<p>❗Termonated: 수행(execution)이 끝난 상태</p>

<p>❗Blocked: 자신이 요청한 event가 만족되면 Ready</p>

<p>❗Suspended: 외부에서 resume해 주어야 Active</p>

<h3 id="프로세스-상태도">🌟 프로세스 상태도</h3>

<p><img src="https://user-images.githubusercontent.com/67252475/158180436-40a50fc5-2c26-4935-a195-b00796adbc1a.png" alt="image" /></p>

<h2 id="2-pcb">2. PCB</h2>

<ul>
  <li>운영체제가 각 프로세스를 관리하기 위해 프로세스당 유지하는 정보</li>
  <li>다음의 구성 요소를 가진다(구조체로 유지)
    <ul>
      <li>OS가 관리상 사용하는 정보
        <ul>
          <li>process state, process ID</li>
          <li>scheduling Information, priority</li>
        </ul>
      </li>
      <li>CPU 수행 관련 하드웨어 값
        <ul>
          <li>Program counter, registers</li>
        </ul>
      </li>
      <li>메모리 관련
        <ul>
          <li>Code, data, stack의 위치 정보</li>
        </ul>
      </li>
      <li>파일 관련
        <ul>
          <li>Open file descriptors</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="3-문맥-교환-context-switch">3. 문맥 교환 (Context Switch)</h2>

<p>✔️ CPU를 한 프로세스에서 다른 프로세르로 넘겨주는 과정</p>

<p>✔️ CPU가 다른 프로세스에게 넘어갈 때 운영체제는 다음을 수행</p>

<ul>
  <li>CPU를 내어주는 프로세스의 상태를 그 프로세스의 PCB에 저장</li>
  <li>CPU를 새롭게 얻는 프로세스의 상태를 PCB에서 읽어옴
    <ul>
      <li>프로세스가 이전에  실행 중이던 상태부터 다시 실행하기 위해</li>
    </ul>
  </li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">문맥교환은</span> <span class="o">**</span><span class="kt">Timer</span> <span class="kt">Interuppt</span><span class="o">**</span><span class="n">가</span> <span class="n">발생하거나</span> <span class="o">**</span><span class="kt">I</span><span class="o">/</span><span class="kt">O</span> <span class="kt">SystemCall</span><span class="o">**</span><span class="n">이</span> <span class="n">발생할</span> <span class="n">때</span> <span class="n">이뤄진다</span><span class="o">.</span> 
<span class="n">사용자</span> <span class="n">프로그램이</span> <span class="o">**</span><span class="kt">Interuppt</span><span class="o">**</span><span class="n">를</span> <span class="n">발생시키거나</span> <span class="o">**</span><span class="kt">SystemCall</span><span class="o">**</span><span class="n">을</span> <span class="n">하여</span> <span class="n">사용자</span> <span class="n">모드에서</span> <span class="n">커널모드로</span> <span class="n">변경되는</span> <span class="n">것은</span>
<span class="n">문맥교환이</span> <span class="n">아니다</span><span class="o">.</span> 

<span class="n">사용자모드에서</span> <span class="n">커널모드로</span> <span class="n">변경되는</span> <span class="n">것도</span> <span class="n">문맥교환은</span> <span class="n">이러나지</span> <span class="n">않았지만</span> <span class="n">이전에</span> <span class="n">실행했던</span> 
<span class="n">사용자</span> <span class="n">프로그램이</span> <span class="n">실행</span> <span class="n">중이던</span> <span class="n">정보를</span> <span class="kt">PCB에</span> <span class="n">저장하기</span> <span class="n">때문에</span> <span class="n">약간의</span> <span class="n">문맥은</span> <span class="n">저장이</span> <span class="n">되지만</span>
<span class="n">문맥교환처럼</span> <span class="n">프로세스</span> <span class="n">자체가</span> <span class="n">변경되는</span> <span class="n">것보다</span> <span class="n">오버헤드가</span> <span class="n">적다</span><span class="o">.</span>

<span class="n">문맥교환이</span> <span class="n">발생하면</span> <span class="n">해당</span> <span class="n">프로세스가</span> <span class="n">사용하던</span> <span class="o">**</span><span class="kt">Cache</span> <span class="kt">Memory</span><span class="o">**</span><span class="n">를</span> <span class="o">**</span><span class="kt">Flush</span><span class="o">**</span> <span class="n">해야하기</span> <span class="n">때문에</span> <span class="n">커널모드와</span> <span class="n">사용자모드</span> 
<span class="n">스위칭보다</span> <span class="n">상당한</span> <span class="n">오버헤드가</span> <span class="n">발생한다</span><span class="o">.</span>
</code></pre></div></div>

<p>💡 프로세스의 문맥이란 프로세스 실행상태와 프로세스 자원 등 커널에서 관리하는 <strong>프로세스 실행 정보</strong>를 말한다.</p>

<h2 id="4-프로세스를-스케줄링하기-위한-큐">4. 프로세스를 스케줄링하기 위한 큐</h2>

<p>✔️  Job queue</p>

<ul>
  <li>현재 시스템 내에 있는 모든 프로세스의 집합</li>
</ul>

<p>✔️ Ready queue</p>

<ul>
  <li>현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합</li>
</ul>

<p>✔️ Device queue</p>

<ul>
  <li>I/O device의 처리를 기다리는 프로세스의 집합</li>
</ul>

<blockquote>
  <p>💡 이와 같은 큐는 소프트웨어 자원을 기다리는 경우에도 필요하다. 예를 들면 공유 데이터에 대한 접근 권한은 소프트웨어 자원으로 분류될 수 있다. 어떠한 프로세스가 공유 데이터를 사용하는 중에 다른 프로세스가 같은 데이터를 접근하면 일관성이 훼손될 수 있기 때문에 매 시점 하나의 프로세스만이 접근할 수 있도록 해야한다.</p>
</blockquote>

<h2 id="5-스케줄러-scheduler">5. 스케줄러 (Scheduler)</h2>

<p>✔️  Long-term scheduler (장기 스케줄러 or Job Scheduler)</p>

<ul>
  <li>시작 프로세스 중(new 상태의 프로세스) 어떤 것들을 ready queue로 보낼지 결정</li>
  <li>프로세스에 메모리(및 각종 자원)을 주는 문제</li>
  <li>degree of Multiprogramming을 제어</li>
  <li>time sharing system에는 보통 장기 스케줄러가 없음 (무조건 ready 상태)</li>
  <li>현대의 운영체제에는 장기 스케줄러가 없다</li>
</ul>

<p>✔️ Short-term scheduler (단기 스케줄러 or CPU scheduler)</p>

<ul>
  <li>어떤 프로세스를 다음번에 running 시킬지 결정</li>
  <li>프로세스에 CPU를 주는 문제</li>
  <li>충분히 빨라야 함 (milliseconde 단위)</li>
</ul>

<p>✔️ Medium-Tern Scheduler (중기 스케줄러 or Swapper)</p>

<ul>
  <li>여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아냄</li>
  <li>프로세스에게서 memory를 뺏는 문제</li>
  <li>degree of Multiprogramming을 제어</li>
</ul>

<blockquote>
  <p>💡 스왑아웃 대상 0순위는 봉쇄상태의 프로세스다.</p>

  <p>봉쇄상태의 프로세스를 스왑아웃 시켜도 메모리가 부족하면 타이머 인터럽트가 발생하여 준비큐로 이동하는 프로세스를 추가적으로 스왑아웃 시킨다.</p>

  <p>준비큐에 너무 많은 프로세스가 존재하면 개별 프로세스에 배정되는 메모리양이 지나치게 적어지고 CPU를 한번 할당받은 후 다시 할당받기 까지 오랜 시간이 소요되기 때문이다.</p>
</blockquote>

<h2 id="6-thread">6. Thread</h2>

<blockquote>
  <p>“A Theard ( or Lightweigth process) is a basic unit of CPU utilization”</p>

</blockquote>

<p>✔️ Thread의 구성 (CPU 수행과 관련)</p>

<ul>
  <li>program counter</li>
  <li>register set</li>
  <li>stack space</li>
</ul>

<p>✔️ Thread가 동료 Thread와 공유하는 부분 (=task)</p>

<ul>
  <li>code section</li>
  <li>data section</li>
  <li>OS resource</li>
</ul>

<p>✔️  전통적인 개념의 heavyweight process는 하나의 thread를 가지고 있는 task로 볼 수 있다.</p>

<p>✔️  다중 쓰레드로 구성된 태스크 구조에서는 하나의 서버 쓰레드가 블럭된 상태인 동안에도 동일한 태스크     내의 다른 쓰레드가 실행되어 빠른 처리가 가능하다.</p>

<p>✔️  동일한 작업을 수행하는 다중 스레드가 협력하여 높은 처리율과 성능 향상을 얻을 수 있다.</p>

<p>✔️  스레드를 사용하면 병렬성을 높일 수 있다.</p>

<ul>
  <li>멀티코어 컴퓨터에서 얻는 장점</li>
</ul>

<p>✔️  멀티 프로세스보다 멀티 스레드가 가볍다.</p>

<ul>
  <li>멀티 프로세스의 경우 각각의 프로세스마다 자원을 별도로 생성하는 반면, 멀티 스레드는 CPU 수행과 관련된 부분만 생성하고 code, data, os 자원같은 경우 프로세스의 메모리 영역을 참조한다.</li>
</ul>

<blockquote>
  <p>💡 멀티 쓰레드 웹 서버를 예로 들면, 한 요청이 끝날 때까지 기다렸다가 다음 요청을 처리하는 게 아닌 쓰레드마다 각각의 요청을 처리할 수 있다.</p>
</blockquote>

<h2 id="7-thread-의-장점">7. Thread 의 장점</h2>

<p>✔️ Responsiveness</p>

<ul>
  <li>multi-threaded
    <ul>
      <li>만약 하나의 Thread 블럭되면 (eg network) 또 다른 Thread 작업을 이어간다. (eg display)</li>
    </ul>
  </li>
</ul>

<p>✔️ Resource Sharing</p>

<ul>
  <li>여러개의 Thread 코드영역, 데이터 영역 등 프로세스 자원(CPU 수행에 필요한 자원)을 공유할 수 있다.</li>
</ul>

<p>✔️ Economy</p>

<ul>
  <li>프로세스 문맥교환과 프로세스 생성은 Thread 스위칭, Thread 생성보다 오버헤드가 상당히 크다
    <ul>
      <li>솔라리스 운영체제의 경우 오버헤드가 각각 30배 5배</li>
    </ul>
  </li>
</ul>

<p>✔️ Utilization of MP Architecutres</p>

<ul>
  <li>각 쓰레드가 서로 다른 CPU에서 병렬적으로 수행될 수 있다. (멀티 프로세서 환경)</li>
</ul>]]></content><author><name>ramram</name></author><category term="OS" /><category term="프로세스" /><category term="스케줄러" /><category term="OS" /><category term="Operating System" /><category term="쓰레드" /><category term="Thread" /><summary type="html"><![CDATA[1. 프로세스]]></summary></entry><entry><title type="html">[운영체제 스터디] 컴퓨터 구조와 컴퓨터 시스템 동작원리</title><link href="http://localhost:4000/os/os-study-02/" rel="alternate" type="text/html" title="[운영체제 스터디] 컴퓨터 구조와 컴퓨터 시스템 동작원리" /><published>2022-03-15T00:00:00+09:00</published><updated>2022-03-15T00:00:00+09:00</updated><id>http://localhost:4000/os/os-study-02</id><content type="html" xml:base="http://localhost:4000/os/os-study-02/"><![CDATA[<h2 id="1-컴퓨터-구조">1. 컴퓨터 구조</h2>

<p><img src="https://user-images.githubusercontent.com/56028408/157796926-1bb83571-56ea-404a-b551-048cb898fdaf.png" alt="https://user-images.githubusercontent.com/56028408/157796926-1bb83571-56ea-404a-b551-048cb898fdaf.png" /></p>

<p>✔️ 전문가적 입장에서 컴퓨터를 말할 때, 보통 CPU와 Memory를 말한다.</p>

<p>✔️ 컴퓨터는 CPU, Memory, I/O Device, Disk, 네트워크 장비들로 이뤄져있다.</p>

<h2 id="2-컴퓨터-시스템-구조">2. 컴퓨터 시스템 구조</h2>

<p>✔️  CPU</p>

<ul>
  <li>CPU는 매 클럭사이클 마다 메모리에서 instruction을 하나씩 읽어서 실행한다.</li>
  <li>instruction 수행이 종료되면 Interrupt Line을 체크하고 인터럽트 신호가 확인되면 수행한다.</li>
</ul>

<p>✔️  Modebit</p>

<ul>
  <li>사용자가 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치</li>
  <li>하드웨어적으로 두 가지 모드의 Operation 지원
    <ul>
      <li>1 → 사용자 모드로 사용자 프로그램을 실행한다.</li>
      <li>0 → 커널모드로 OS 코드를 실행한다</li>
    </ul>
  </li>
  <li>보안을 해칠 수 있는 중요한 명령어는 커널 모드에서만 수행 가능한 특권명령으로 규정한다.</li>
  <li>Interrupt나 Exeception이 발생하면 하드웨어가 mode bit를 0으로 변경하여 운영체제에게 CPU를 할당한다.</li>
  <li>커널모드에서 작업이 끝나면 사용자모드로 변경하기 전에 mode bit를 1으로 변경한다.</li>
</ul>

<p>✔️  Timer</p>

<ul>
  <li>특정 프로그램이 CPU를 독점하는 것을 방지하기위한 장치</li>
  <li>운영체제가 사용자 프로그램에게 CPU를 넘겨줄 때 Timer에 값을 지정해서 넘겨준다.</li>
  <li>타이머 값이 0이 되면 타이머가 CPU에게 인터럽트 신호를 발신한다.</li>
  <li>타이머는 time sharing을 구현하기 위해 널리 이용됨</li>
  <li>타이머는 현재 시간을 계산하기 위해서도 사용됨</li>
</ul>

<p>✔️  Memory</p>

<ul>
  <li>메모리는 CPU가 처리할 데이터나 명령어가 임시로 저장되는 곳으로 작업 공간 역할을 한다.</li>
  <li>컴퓨터 작업을 할 때 하드디스크에 있는 데이터는 먼저 메모리로 이동된 다음 CPU로 전송된다.
    <ul>
      <li>프로그램 실행도 이와 마찬가지로 CPU가 메모리에 저장되어 있는 용량만큼 프로그램을 작동시킨다.</li>
    </ul>
  </li>
</ul>

<p>✔️  I/O Device</p>

<ul>
  <li>각각의 I/O Device는 각 디바이스를 전담하는 Controller를 가지고 있다.</li>
  <li>Controller는 각 I/O 디바이스의 내부를 통제하는 작업을 담당한다. CPU에게 인터럽트를 발생시키는 것도 Controller가 담당한다.</li>
  <li>I/O Device는 CPU에 비해 처리속도가 상당히 느리다</li>
  <li>I/O Device는 모두 각각의 Local Buffer를 가지고 있다.</li>
  <li>I/O는 실제 device와 local buffer 사이에서 일어남</li>
</ul>

<p>✔️ I/O Device Controller</p>

<ul>
  <li>I/O 장치유형을 관리하는 일종의 작은 CPU</li>
  <li>제어 정보를 위해 control register, status register를 가짐</li>
  <li>local buffer를 가짐 (일종의 data register)</li>
  <li>Device controller는 I/O가 끝났을 경우 인터럽트로 CPU에 그 사실을 알림</li>
</ul>

<p>✔️ DMA Controller</p>

<ul>
  <li>CPU와 동일하게 직접 메모리에 접근 가능한 컨트롤러</li>
  <li>I/O device의 작업이 종료되어 localBuffer에 데이터가 적재되면 DMA 컨트롤러가 하드웨어 인터럽트를 CPU 대신 수신하여 데이터를 메모리에 복사한 후 합쳐서 CPU에게 인터럽트를 보낸다</li>
</ul>

<p>✔️ 인터럽트 (Interrupt)</p>

<ul>
  <li>인터럽트 당한 시점의 레지스터와 프로그램 카운터를 저장한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다.</li>
  <li>넓은 의미의 인터럽트
    <ul>
      <li>interuppt (하드웨어 인터럽트) : 하드웨어가 발생시킨 인터럽트</li>
      <li>trap (소프트웨어 인터럽트)</li>
    </ul>
  </li>
  <li>Exception: 프로그램이 오류를 범한 경우</li>
  <li>System Call: 프로그램이 커널함수를 호출하는 경우</li>
  <li>인터럽트 관련 용어
    <ul>
      <li>인터럽트 백터
        <ul>
          <li>해당 인터럽트의 처리 루틴 주소를 가지고 있다.</li>
        </ul>
      </li>
      <li>인터럽트 처리 루틴
        <ul>
          <li>해당 인터럽트를 처리하는 커널 함수</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="3-입출력-io의-수행">3. 입출력 (I/O)의 수행</h2>

<ul>
  <li>모든 입출력 명령은 특권 명령이다.</li>
  <li>사용자 프로그램이 I/O를 하는 방식
    <ul>
      <li>시스템콜(system call)</li>
      <li>사용자 프로그램이 운영체제의 서비스를 받기위해 호출하는 것</li>
    </ul>
  </li>
  <li>trap을 사용하여 인터럽트 벡터의 특정 위치로 이동</li>
  <li>제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동</li>
  <li>올바른 I/O 요청인지 확인 후 I/O 수행</li>
  <li>I/O 완료 시 제어권을 시스템콜 다음 명령으로 옮김</li>
</ul>

<h2 id="3-동기식-입출력">3. 동기식 입출력</h2>

<p>✔️ 동기식 입출력은 어떤 프로그램이 입출력 요청을 했을 때</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>입출력 작업이 완료된 후에야 그 프로그램이 후속 작업을 수행할 수 있는 방식을 말한다.
</code></pre></div></div>

<p>🌟  <strong>동기식 입출력의 실행 방식</strong> 🌟</p>

<blockquote>
  <p>동기식 입출력은 프로그램이 디스크에서 어떤 정보를 읽어오라는 요청을 했을 때 디스크 입출력이 진행되는 동안 그 프로그램의 다음 명령을 수행하지 않고 기다린다.
그러다가 입출력이 완료되어 인터럽트를 통해 완료 사실이 전달된 후에야 CPU의 제어권이 해당 프로그램에게 넘어간다.</p>
</blockquote>

<p>따라서 동기식 입출력에서 CPU는 입출력 연산이 끝날 때까지 인터럽트를 기다리며 자원을 낭비하게 된다.
한편 CPU의 명령 수행 속도는 빠르지만 입출력 장치에서 데이터를 읽어오는 등의 입출력 연산은 상대적으로 느리다.</p>

<p>그럼에도 불구하고 입출력이 완료될 때까지 대기했다가 사용자 프로그램에게 CPU의 제어권을 넘기는 방식은 자원 낭비를 초래한다.</p>

<p>따라서 일반적으로 프로그램이 입출력을 수행 중인 경우 CPU를 입출력을 실행한 프로그램에게서 빼앗아 다른 프로그램에게 할당하고 입출력을 수행중인 프로그램은 봉쇄상태로 변경한다.</p>
<blockquote>

</blockquote>

<h2 id="4-비동기식-입출력">4. 비동기식 입출력</h2>

<p>비동기식 입출력은 프로그램이 디스크 정보를 요청하더라도 프로그램을 봉쇄상태로 이동하지 않고 다음 작업을 수행한다.</p>

<p>🌟  비<strong>동기식 입출력의 실행 방식</strong> 🌟</p>

<blockquote>
  <p>비동기식 입출력은 입출력 연산을 요청한 후에 연산이 끝나기를 기다리는 것이 아니라</p>

  <p>CPU의 제어권을 입출력 연산을 호출한 그 프로그램에게 곧바로 다시 부여하는 것을 말한다.</p>

  <p>어떤 프로그램이 데이터를 디스크에서 읽어오라는 요청을 했을 때 보통은 읽어온 결과를 이용해서 다음 연산을 수행하지만 경우에 따라서는 그 데이터와 관련없이 수행할 수 있는 일이 있을 것이다.</p>

  <p>비동기식 입출력에서는 그러한 작업을 먼저 수행하고, 읽어오는 데이터가 반드시 이어야 수행할 수 있는 일들은 입출력이 완료된 후에 수행하게 된다.</p>

  <p>또한 디스크에서 읽어오는 요청이 아니라 디스크에 쓰는 요청이라면 쓰기 작업이 완료되기 전에도 다음 명령을 수행할 수 있으므로 비동기식 입출력이 사용될 수 있다.</p>

</blockquote>

<h2 id="5-프로그램의-구조와-실행">5. 프로그램의 구조와 실행</h2>

<p>✔️ 프로그램의 구조와 인터럽트</p>

<ul>
  <li>프로그램이 CPU에서 명령을 수행하려면 해당 명령을 담은 프로그램의 주소 영역이 메모리에 올라가 있어야 한다. 이때 프로그램의 주소 영역은 크게 코드, 데이터, 스택 영역으로 구분된다.</li>
</ul>

<p>✔️ 코드영역</p>

<ul>
  <li>코드영역은 작성한 프로그램의 함수들의 코드가 CPU에서 수행할 수 있는 기계어 명령 형태로 변환되어 저장되는 부분</li>
</ul>

<p>✔️ 데이터 영역</p>

<ul>
  <li>전역 변수 등 프로그램이 사용하는 데이터를 저장하는 부분</li>
</ul>

<p>✔️ 스택 영역</p>

<ul>
  <li>함수가 호출될 때 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는 데에 사용되는 공간</li>
</ul>

<p>✔️ 컴퓨터 시스템의 작동 개요</p>

<ul>
  <li>CPU는 빠른 속도로 처리하는 계산 능력은 가지고 있지만, 수행해야하는 작업을 스스로 결정하는 능력은 갖추고 있지 않다.</li>
  <li>
    <p>CPU는 매 시점 메모리의 특정 주소에 존재하는 명령어를 하나씩 읽어와서 그대로 실행한다.</p>

    <p>이때 CPU가 수행해야 할 메모리 주소를 담고 있는 레지스터를 프로그램 카운터라고 부른다.</p>
  </li>
  <li>CPU는 매번 프로그램 카운터가 가리키는 메모리 위치의 명령을 처리하게 된다.</li>
</ul>

<p>✔️ 프로그램의 실행</p>

<ul>
  <li>프로그램이 실행되고 있다는 것은 디스크에 존재하면 실행파일이 메모리에 적재된다는 의미와</li>
  <li>프로그램이 CPU를 할당받고 명령을 수행하고 있는 상태라는 의미이다.</li>
  <li>현재 수행 중인 프로그램을 프로세서(process)라고 부른다.</li>
  <li>각 프로그램은 코드, 데이터, 스택영역과 같은 주소 공간을 별도로 가진다</li>
  <li>프로그램마다 독자적으로 존재하는 주소공간을 가상메모리 또는 논리적 메모리라고 부른다.</li>
</ul>

<hr />

<p><strong>[질문 리스트]</strong></p>

<ol>
  <li>사용자 프로그램이 I/O를 요청했을 때 일어나는 일을 설명해보시오
    <ul>
      <li>사용자는 직접 입출력 장치에 접근할 수 없기 때문에 시스템 콜을 하여 운영체제에게 I/O 작업을 요청한다.
 운영체제는 요청받은 I/O 명령을 사용자 프로그램 모드가 아닌 커널 모드에서 해당 요청에 맞는 처리코드를 수행하게 된다.
 예를 들어 디스크에서 자료를 읽어오는 시스템 콜이라면, CPU가 디스크 컨트롤러에게 데이터를 읽어오라는 명령을 내린다.</li>
    </ul>
  </li>
  <li>DMA 컨트롤러의 기능을 설명해주세요.
    <ul>
      <li>CPU가 입출력 장치들의 메모리 접근 요청에 의해 자주 인터럽트 당하는 것을 막아주어서
 CPU에 발생하는 인터럽트의 빈도를 줄여 CPU를 효율적으로 관리할 수 있게 도와주는 역할을 한다.</li>
      <li>DMA를 사용하면 CPU가 로컬버퍼에서 메모리로 읽어오는 작업을 DMA가 대행한다.</li>
      <li>DMA는 바이트 단위가 아니라 블록이라는 큰 단위로 정보를 메모리로 읽어온 후에 CPU에게 인터럽트를 발생시켜 작업이 끝난 것을 알린다.</li>
    </ul>
  </li>
  <li>시스템콜에 대해 설명해보세요
    <ul>
      <li>시스템 콜이란 사용자 프로그램이 특권명령을 수행하기 위해 운영체제에게 해당 작업을 요청하는 행위이다.
 시스템 콜은 일종의 소프트웨어적인 인터럽스로서 사용자 프로그램이 시스템 콜을 할 경우 트랩이 발생해 CPU의 제어권이 운영체제로 넘어가게 된다.
 그러면 운영체제는 해당 시스템 콜을 처리하기 위한 루틴으로 가서 정의된 명령을 수행한다.</li>
    </ul>
  </li>
</ol>]]></content><author><name>ramram</name></author><category term="OS" /><category term="운영체제" /><category term="컴퓨터 구조" /><category term="OS" /><category term="Operating System" /><summary type="html"><![CDATA[1. 컴퓨터 구조]]></summary></entry><entry><title type="html">[운영체제 스터디] 운영체제란 무엇인가?</title><link href="http://localhost:4000/os/os-study-01/" rel="alternate" type="text/html" title="[운영체제 스터디] 운영체제란 무엇인가?" /><published>2022-03-14T00:00:00+09:00</published><updated>2022-03-14T00:00:00+09:00</updated><id>http://localhost:4000/os/os-study-01</id><content type="html" xml:base="http://localhost:4000/os/os-study-01/"><![CDATA[<h2 id="1-운영체제란-무엇인가">1. 운영체제란 무엇인가?</h2>

<blockquote>
  <p>컴퓨터 하드웨어 바로 윗단에 설치되는 소프트웨어를 말한다.
운영체제는 하드웨어와 소프트웨어를 연결하는 소프트웨어 계층이다.</p>

</blockquote>

<p>✔️ 운영체제의 주요역할</p>

<ul>
  <li>하드웨어 자원을 효율적으로 관리</li>
  <li>사용자가 컴퓨터를 쉽게 다룰 수 있게 GUI 인터페이스 제공</li>
</ul>

<p>✔️ 자원이란 CPU, 메모리, 하드웨어 뿐만 아니라 소프트웨어 자원까지 포함하여 부르는 말이다. 자원관리는 운영체제의 중요한 역할 중 하나이다*</p>

<p>✔️ 협의의 운영체제(커널)</p>

<ul>
  <li>운영체제의 핵심 부분으로 전원이 켜짐과 동시에 메모리에 상주하는 부분</li>
</ul>

<p>✔️ 광의의 운영체제</p>

<ul>
  <li>커널 뿐만 아니라 각종 시스템 유틸리티를 포함한 개념</li>
  <li>항상 메모리에 올려두는 것이 아닌 별도의 프로그램으로서 사실상 운영체제의 일부라고 보긴 어렵지만 운영체제와 함께 설치되기 때문에 넓은 의미로 포함시킨다.</li>
</ul>

<h2 id="2-운영체제의-목적">2. 운영체제의 목적</h2>

<p>✔️ 운영체제의 핵심은 하드웨어를 효율적으로 관리할 수 있게 하는 것</p>

<p>✔️ 주어진 자원으로 최대한의 성능을 내도록</p>

<p>✔️ 사용자가 컴퓨터를 편리하게 사용할 수 있는 환경을 제공하는 것</p>

<ul>
  <li>사용자간의 형평성 있는 자원 분배</li>
</ul>

<p>✔️ 사용자 및 운영체제 자신을 보호</p>

<p>✔️ 프로세스, 파일, 메세지(소프트웨어 자원) 등을 관리</p>

<p>✔️ 운영체제의 자원? (하드웨어)</p>

<ul>
  <li>CPU, RAM, IO 장치 등등</li>
</ul>

<h2 id="3-운영-체제의-분류">3. 운영 체제의 분류</h2>

<h3 id="️동시-작업-가능-여부">✔️ 동시 작업 가능 여부</h3>

<ul>
  <li>단일 작업(sigle tasking)
    <ul>
      <li>한 번에 하나의 작업만 처리</li>
    </ul>
  </li>
  <li>다중 작업(multi tasking)
    <ul>
      <li>동시에 두 개 이상의 작업 처리</li>
      <li>현대의 운영체제 들은 대부분 다중 작업이 가능한 운영체제</li>
    </ul>
  </li>
</ul>

<h3 id="️사용자의-수">✔️ 사용자의 수</h3>

<p>여러 사용자가 동시에 접근할 수 있는지를 기준으로 구분</p>

<ul>
  <li>단일 사용자(sigle user)
예 ) MS-DOS, MS Windows</li>
  <li>다중 사용자(multi user)
예 ) UNIX, NT server</li>
</ul>

<h3 id="️처리-방식">✔️ 처리 방식</h3>

<ul>
  <li>일괄 처리(bath processing)
    <ul>
      <li>작업 요청의 일정량 모아서 한꺼번에 처리</li>
      <li>작업이 완전 종료될 때까지 기다려야함
  예 ) 초기 Punch Card 처리 시스템</li>
    </ul>
  </li>
  <li>시분할(time sharing)
    <ul>
      <li>여러 작업을 수행할 때 컴퓨터 처리 능력을 일정한 시간 단위로 분할하여 사용</li>
      <li>일괄 처리 시스템에 비해 짧은 응답을 가짐</li>
      <li>interactive한 방식</li>
      <li>범용 컴퓨터의 처리방식</li>
    </ul>
  </li>
  <li>실시간(Realtime OS)
    <ul>
      <li>정해진 시간 안에 어떠한 일이 반드시 종료됨이 보장되어야 하는 실시간 시스템을 위한 OS
  예 ) 원자로/공장 제어, 미사일 제어, 반도체 장비, 로보트 제어</li>
    </ul>
  </li>
  <li>실시간 시스템의 개념 확장
    <ul>
      <li>Hard realtime system (경성 실시간 시스템)</li>
      <li>Soft realtime sysytem(연성 실시간 시스템)</li>
    </ul>
  </li>
</ul>

<h3 id="️몇-가지-용어">✔️ 몇 가지 용어</h3>

<ul>
  <li>Multitasking (여러 프로그램이 실행되는 것)</li>
  <li>Multiprogramming (메모리에 여러 프로그램이 올라가있음을 강조)</li>
  <li>Time sharing (Multitasking과 유사하지만 CPU 강조)</li>
  <li>Multiprocess</li>
  <li>Multiprocessor
    <ul>
      <li>하나의 컴퓨터에 CPU(processor)가 여러 개 붙어 있음을 의미</li>
    </ul>
  </li>
  <li>구분
    <ul>
      <li>위의 용어들은 컴퓨터에서 여러 작업을 동시에 수행하는 것을 뜻한다</li>
      <li>Multiprogramming은 여러 프로그램이 메모리에 올라가 있음을 강조</li>
      <li>Time Sharing은 CPU의 시간을 분할하여 나누어 쓴다는 의미를 강조</li>
    </ul>
  </li>
</ul>

<h3 id="️운영-체제의-예">✔️ 운영 체제의 예</h3>

<ul>
  <li>UNIX
    <ul>
      <li>코드의 대부분을 C언어로 작성 됨</li>
      <li>높은 이식성</li>
      <li>최소한의 커널 구조</li>
      <li>복잡한 시스템에 맞게 확장 용이</li>
      <li>소스 코드 공개</li>
      <li>프로그램 개발에 용이</li>
      <li>대형 컴퓨터를 위해 만들어짐</li>
      <li>다양한 버전
        <ul>
          <li>System V, FreeBSD, SunOs, Solaris</li>
          <li>Linux (Unix 소스코드 기반)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>DOS(Disk Operating System)
    <ul>
      <li>MS사에서 1981년 IBM-PC를 위해 개발</li>
      <li>단일 사용자용 운영체제, 메모리 관리 능력의 한계(주 기억 장치 : 640KB)</li>
    </ul>
  </li>
  <li>MS Windows
    <ul>
      <li>MS사의 다중 작업용 GUI 기반 운영 체제</li>
      <li>Plug and Play, 네트워크 환경 강화</li>
      <li>DOS용 응용 프로그램과 호환성 제공</li>
      <li>불안정성 (초창기 Windows)</li>
      <li>풍부한 자원 소프트웨어</li>
    </ul>
  </li>
  <li>Hanheld device를 위한 OS
    <ul>
      <li>PalmOS, Pocket PC (WinCE), Tiny OS</li>
    </ul>
  </li>
</ul>

<h2 id="4-운영체제의-구조">4. 운영체제의 구조</h2>

<p><strong>CPU, Memory, I/O Device, Disk (운영체제는 각 자원들을 관리한다)</strong></p>

<p>✔️ CPU 스케줄링</p>

<ul>
  <li>어떤 프로그램에게 우선순위를 할당할지?
    <ul>
      <li>짧은 간격으로 프로그램을 교체 함 (시분할)</li>
      <li>프로그램이 실행된 순서대로 우선순위를 할당하면 작업이 길어질 경우 나머지 프로그램 응답시간이 길어지기 때문에 사용하지 않는다.</li>
    </ul>
  </li>
</ul>

<p>✔️ 메모리 관리</p>

<ul>
  <li>한정된 메모리를 어떻게 관리하나?
    <ul>
      <li>프로그램 실행에 필요한 최소한의 정보만을 메모리에 올려 둠</li>
      <li>CPU에서 사용될 가능성이 낮은 정보들을 DISK에 내려둔다.</li>
      <li>CPU에서 사용될 가능성이 낮은 정보를 어떻게 판단하는지?
        <ul>
          <li>데이터가 메모리에 올라간 이후로 자주 사용된 데이터이면 사용될 가능성이 높은 정보로 판단한다</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>✔️ DISK 파일관리</p>

<ul>
  <li>DISK 스케줄링 (엘리베이터 스케줄링과 유사함 CPU 스케줄링과는 다르다)
    <ul>
      <li>DISK에 들어온 요청들을 HEAD와 가까운 위치에 들어온 요청이 있다면 먼저 처리하고 DISK HEAD의 이동을 최소화한다.</li>
    </ul>
  </li>
</ul>

<p>✔️ I/O Device</p>

<ul>
  <li>다른 자원들에 비해 느리다.</li>
  <li>입출력관리 인터럽트
    <ul>
      <li>I/O Device가 작업을 처리해야할 경우 CPU에게 인터럽트 신호를 준다</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br /></p>

<hr />

<p><strong>[질문 리스트]</strong></p>

<ol>
  <li>운영체제의 정의를 설명하고 그 기능에 대해 아는대로 설명해주세요
    <ul>
      <li>운영체제는 컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 다른 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층이다.
 운영체제는 사용자가 컴퓨터를 쉽게 다룰 수 있게 GUI 인터페이스 제공하고, 하드웨어 자원을 효율적으로 사용할 수 있게 도와준다.</li>
    </ul>
  </li>
  <li>운영체제 운용 방법 중 하나인 시분할 시스템에 대해서 설명해주세요
    <ul>
      <li>시분할 시스템은 여러 작업을 수행할 때 CPU를 일정한 시간 단위로 프로그램에게 할당하여 처리해줌으로써 각 사용자에게 독립된 컴퓨터를 사용하는 느낌을 준다. 라운드 로빈(Round Robin)방식이라고도 한다.</li>
      <li>하나의 CPU는 같은 시점에서 여러 개의 작업을 동시에 수행할 수 없기 때문에, CPU의 전체 사용시간을 작은 작업 시간량으로 쪼개어그 시간량 동안만 번갈아가면서 CPU를 할당하여 각 작업을 처리하는 방법이다.모든 작업이 동시에 진행되는 것처럼 대화식 처리가 가능하다. 각 작업에 대한 응답시간을 최소화 하는 것이 목적이다.</li>
    </ul>
  </li>
  <li>운영체제의 개념을 좁은 의미와 넓은 의미로 나누어 간략하게 설명하세요
    <ul>
      <li>운영체제의 좁은 의미는 운영체제 커널을 의미하고 커널은 운영체제의 핵심 부분임으로 전원이 켜짐과 동시에 메모리에 상주합니다.
운영체제의 넓은 의미는 운영체제의 커널과 각종 주변 유틸리티 시스템을 포함한 개념입니다<em>.</em></li>
    </ul>
  </li>
</ol>]]></content><author><name>ramram</name></author><category term="OS" /><category term="운영체제란?" /><category term="운영체제의 목적" /><category term="운영체제 구조" /><category term="Operating System" /><summary type="html"><![CDATA[1. 운영체제란 무엇인가?]]></summary></entry><entry><title type="html">SpringFramework - Web ApplicationContext</title><link href="http://localhost:4000/tobi/spring-applicationcontext/" rel="alternate" type="text/html" title="SpringFramework - Web ApplicationContext" /><published>2022-02-21T00:00:00+09:00</published><updated>2022-02-21T00:00:00+09:00</updated><id>http://localhost:4000/tobi/spring-applicationcontext</id><content type="html" xml:base="http://localhost:4000/tobi/spring-applicationcontext/"><![CDATA[<h2 id="1--ioc-컨테이너--빈-팩토리와-애플리케이션-컨텍스트">1.  IoC 컨테이너 : 빈 팩토리와 애플리케이션 컨텍스트</h2>

<ul>
  <li>스프링 애플리케이션에서는 오브젝트의 생성과 관계설정, 사용, 제거 등의 작업을 애플리케이션 코드 대신 독립적인 컨테이너가 담당한다.</li>
  <li>이를 컨테이너가 코드 대신 오브젝트 제어권을 갖고있다고 해서 IoC 라고 부른다. 그래서 스프링 컨테이너를 IoC 컨테이너 라고도 한다.</li>
  <li>스프링에선 IoC를 담당하는 컨테이너를 빈 팩토리 또는 애플리케이션 컨텍스트라고 부르기도 한다.</li>
  <li>오브젝트의 생성과 오브젝트 사이의 런타임 관계를 설정하는 DI 관점으로 볼 때는 컨테이너를 빈 팩토리라고 한다.</li>
  <li>그런데 스프링 컨테이너는 단순한 DI 작업보다 더 많은 일을 한다. DI를 위한 빈 팩토리에 엔터프라이즈 애플리케이션을 개발하는 데 필요한 여러 가지 컨테이너 기능을 추가한 것을 애플리케이션 컨텍스트라고 부른다.</li>
</ul>

<p>❗ApplicationContext는 beacFactory interface를 상속받고 있지만, 위임하는 것 외에 다른 로직은 구현하지 않는다.</p>

<h2 id="2-web-applicationcontext">2. Web ApplicationContext</h2>

<ul>
  <li>스프링 애플리케이션에서 가장 많이 사용되는 ApplicationContext는 바로 WebApplicationContext 이다. WebApplicationContext는 ApplicationContext를 확장한 인터페이스이므로 정확히는 WebApplicationContext를 구현한 클래스를 사용하는 셈이다.</li>
  <li>웹 애플리케이션에서 만들어지는  IoC 컨테이너는 WebApplicationContext 인터페이스를 구현한 것임을 기억해두자.</li>
  <li>WebApplicationContext의 특징은 자신이 만들어지고 동작하는 환경인 웹 모듈에 대한 정보에 접근할 수 있다는 점이다. 이를 이용해 웹 환경으로부터 필요한 정보를 가져오거나, 웹 환경에 스프링 컨테이너 자신을 노출할 수 있다. 컨테이너가 웹 환경에 노출되면 같은 웹 모듈이 들어 있는 스프링 빈이 아닌 일반 오브젝트와 연동될 수 있다.</li>
</ul>

<h2 id="3-web-applicationcontext--계층구조">3. Web ApplicationContext  계층구조</h2>

<ul>
  <li>웹 애플리케이션 레벨에 등록되는 컨테이너는 보통 루트 웹 애플리케이션 컨텍스트라고 불린다.</li>
  <li>루트 웹 애플리케이션 컨텍스트는 서블릿 레벨에 등록되는 컨테이너들의 부모 컨테이너가 되고, 일반적으로 전체 계층구조 내에서 가장 최상단에 위치한 루트 컨텍스트가 되기 때문이다.</li>
  <li>웹 애플리케이션에는 하나 이상의 스프링 애플리케이션의 프론트 컨트롤러 역할을 하는 서블릿이 등록될 수 있다(디스패쳐 서블릿은 프론트 컨트롤러 패턴으로 구현되었음)</li>
  <li>등록된 서블릿에는 각각 독립적으로 애플리케이션 컨텍스트가 만들어진다. 이런 경우 각 서블릿이 공유하게 되는 공통적인 빈들이 생길 수 있다.</li>
  <li>공통적으로 사용하는 빈을 루트 웹 애플리케이션 레벨의 컨텍스트에 등록하면 공통되는 빈들이 서블릿별로 중복돼서 생성되는 것을 방지할 수 있다.</li>
  <li>하지만 하나의 서블릿이 모든 애플리케이션 요청을 처리하는 프론트 컨트롤러 패턴으로 구현되었기 때문에 여러개의 서블릿 컨테이너를 생성하는 것은 드물다</li>
</ul>

<details>
  <summary>❗여러개의 자식 컨테이너를 생성하는 것이 아닌데 계층 구조를 사용하는 이유는?
</summary>
  <div>
    <p>그 이유는 전체 애플리케이션에서 웹 기술에 의존적인 부분과 그렇지 않은 부분을 구분하기 위해서이다. 스프링을 이용하는 웹 애플리케이션이라고 해서</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>반드시 스프링 웹 서블릿 만들 필요는 없다. 스프링 기술을 사용하고 스프링 빈으로 만들지만 웹을 담당하는 프레젠테이션 계층은 스프링 외의 기술을 사용하는 경우도 종종 있기 때문이다.
</code></pre></div>    </div>
  </div>
</details>

<h2 id="4-부모-컨텍스트를-이용한-계층구조-효과">4. 부모 컨텍스트를 이용한 계층구조 효과</h2>

<ul>
  <li>모든 애플리케이션 컨텍스트는 부모 애플리케이션 컨텍스트를 가질 수 있다.</li>
  <li>계층구조 안의 모든 컨텍스트는 각자 독립적인 설정정보를 이용해 빈 오젝트를 만들고 관리한다.</li>
  <li>각자 독립적으로 자신이 관리하는 빈을 갖고 있긴 하지만 DI를 위해 빈을 찾을 떄는 부모 애플리케이션의 빈까지 모두 검색한다.</li>
  <li>먼저 자신이 관리하는 빈 중에서 필요한 빈을 찾아보고, 없으면 부모 컨텍스트에게 빈을 찾아달라고 요청한다. (빈을 찾지 못할 경우 계층구조를 따라서 가장위에 존재하는 루트 컽넥스트까지 요청이 전달 됨)</li>
  <li>자신과 부모 컨텍스트에 동일한 빈이 존재한다면, 자신이 갖고있는 빈이 우선시 된다.  (빈 검색 순서는 자신이 먼저이고, 그 다음 직계 부모의 순서이다.)</li>
</ul>

<p>❗중요한 건 자신의 부모 컨텍스트에게만 빈을 요청하고, 자식 컨텍스트에게는 요청하지 않는 점이다. 그런 이유로 같은 레벨에 있는 형제 컨텍스트의 빈도 찾을 수 없다.</p>

<h2 id="5-web-applicationcontext-의-root-context-가-어떻게-결정되나">5. Web ApplicationContext 의 Root Context 가 어떻게 결정되나?</h2>

<ul>
  <li>WAS 가 구동될 때  Web.xml 의 설정 정보를 리딩한다.</li>
  <li>리딩되면서 SpringContextLoader가 Web.Xml의 contextConfigLocation 의 파일경로를 스캔하고  root-context로 생성한다.</li>
</ul>

<details>
  <summary>❗dispatcher-servlet context 안에서도 contextConfigLocation 을 생성하고 있는데 context-param 안의 contextConfigLocation가 root-context 인 이유는?
</summary>
  <div>
    <p>자세하진  않지만 .. context-param 과 init-param 의 차이는 전역변수, 지역변수의 개념과 비슷하다. context-param 안에서 생성된 빈은 모든 서블릿에서 사용할 수 있다.</p>

    <p>init-param으로 생성된 빈들은 해당 서블릿 안에서만 참조가 가능하다. 이런 이유 때문에 context-param 안에 생성된 contextConfigLocation를 root-context 로 인식하는게 아닐까 싶다.</p>
  </div>
</details>

<p><br />
<br />
<br /></p>

<h1 id="아직-작성-중-">아직 작성 중 …</h1>]]></content><author><name>ramram</name></author><category term="Tobi" /><category term="springframework" /><category term="applicationContext" /><category term="dispatcherServlet" /><category term="토비의 스프링 3.1" /><summary type="html"><![CDATA[1. IoC 컨테이너 : 빈 팩토리와 애플리케이션 컨텍스트]]></summary></entry><entry><title type="html">SpringBoot - Redis Client 적용기</title><link href="http://localhost:4000/springboot/spring-boot-redis/" rel="alternate" type="text/html" title="SpringBoot - Redis Client 적용기" /><published>2022-02-16T00:00:00+09:00</published><updated>2022-02-21T00:00:00+09:00</updated><id>http://localhost:4000/springboot/spring-boot-redis</id><content type="html" xml:base="http://localhost:4000/springboot/spring-boot-redis/"><![CDATA[<h2 id="들어가며">들어가며</h2>

<p>스프링부트 Redis 적용 방법을 공유하고자 게시물을 작성하였다.
예제코드로 적용 방법을 알아보자</p>

<h2 id="redis-의존-설정">🌟 Redis 의존 설정</h2>

<p>Spring은 다양한 Redis 의존설정 방법을 제공한다.</p>

<p>1 - Gradle이나 Maven 설정 파일에 의존 추가하기</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">dependencies</span> <span class="err">{</span>
	<span class="nv">implementation</span> <span class="ss">'org</span><span class="o">.</span><span class="nv">springframework</span><span class="o">.</span><span class="nv">boot:spring-boot-starter-data-redis</span><span class="o">'</span>
<span class="err">}</span>
</code></pre></div></div>
<p><br />
2 - Intellij tool 을 사용하여 SpringBoot 프로젝트 생성시점에 Spring Data Redis 를 추가하는 방법이다.</p>

<p><img src="https://user-images.githubusercontent.com/56028408/154784437-6aff0467-1b9e-401d-a3da-928f16524194.png" alt="redis-intellij" width="550" height="500" /></p>

<p>3 - Spring initializr 로 프로젝트 생성 시점에 Spring Data Redis 추가하기</p>

<p><img src="https://user-images.githubusercontent.com/56028408/154784439-d6dafd63-1c91-47b5-b38f-4533574a972b.png" alt="initalizr-redis" width="700" height="500" /></p>

<p><br /></p>

<p><code class="language-plaintext highlighter-rouge">💡 참고로 Springboot 2 부터는 Lettuce가 기본 Redis Client로 사용된다. 본 프로젝트도 Lettuce를 사용하였다</code></p>

<h2 id="applicationyml-설정">🌟 A<strong>pplication.yml</strong> 설정</h2>

<p>정말 간단하게 Redis 의존을 추가했다. 이제 남은 건 A<strong>pplication.yml</strong> 작성과 Redis Configuration Bean 만 등록하면 된다. 아마도</p>

<p>ymal 작성은 매우 간단하다.</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">spring:</span>
	<span class="nv">redis:</span>
		<span class="nv">lettuce:</span>
			<span class="nv">pool:</span>
				<span class="nv">max-active:</span> <span class="mi">1000</span>
				<span class="nv">max-idle:</span> <span class="mi">500</span>
				<span class="nv">min-idle:</span> <span class="mi">2</span>
				<span class="nv">max-wait:</span> <span class="mi">1000</span>
	<span class="nv">port:</span> <span class="mi">6379</span>
	<span class="nv">host:</span> <span class="mf">127.0</span><span class="o">.</span><span class="mf">0.1</span>
	<span class="nv">password:</span> <span class="ss">'vldpsxl1q2w3e</span><span class="o">'</span>
</code></pre></div></div>

<p>Redis 에 관한 정보만 입력한다고 가정하면 이게 끝이다.  설정 정보는 아래 표 참조 바람<br />
<br /></p>

<p><strong>Redis Option</strong></p>

<table>
  <thead>
    <tr>
      <th>파라미터</th>
      <th>파라미터 설명</th>
      <th>기본값</th>
      <th>기타</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>spring.redis.pool.max-active</td>
      <td>pool에 할당할 수 있는 최대 커넥션 수 (음수는 무제한)</td>
      <td>8</td>
      <td> </td>
    </tr>
    <tr>
      <td>spring.redis.pool.max-idle</td>
      <td>pool의 “idle” 커넥션 최대수 (음수는 무제한)</td>
      <td>8</td>
      <td> </td>
    </tr>
    <tr>
      <td>spring.redis.pool.max-wait</td>
      <td>사용 가능한 커넥션이 없을 때 호출자가 대기해야하는 최대 시간 (단위 : 밀리초, 음수는 무제한 차단)</td>
      <td>-1</td>
      <td> </td>
    </tr>
    <tr>
      <td>spring.redis.pool.min-idle</td>
      <td>pool에서 관리하는 “idle” 커넥션 최소수 (양수일 떄만 유효)</td>
      <td>0</td>
      <td> </td>
    </tr>
    <tr>
      <td>spring.redis.port</td>
      <td>redis server port</td>
      <td>6379</td>
      <td> </td>
    </tr>
    <tr>
      <td>spring.redis.host</td>
      <td>redis server host</td>
      <td>127.0.0.1</td>
      <td> </td>
    </tr>
    <tr>
      <td>spring.redis.password</td>
      <td>redis server login password</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>spring.redis.timeout</td>
      <td>커넥션 타임아웃 (단위: 밀리세컨드)</td>
      <td>0</td>
      <td> </td>
    </tr>
    <tr>
      <td>spring.redis.database</td>
      <td>커넥션 팩토리에 사용되는 데이터베이스 인덱스</td>
      <td>0</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h2 id="redisconnectionfactory-redistemplate-설정하기">🌟 RedisConnectionFactory, RedisTemplate 설정하기</h2>

<p>순조롭게 Yaml 파일 설정도 끝이났다.  이제는 Java를 사용해서 기존에 xml 파일로 설정했던 RedisFactory, RedisTemplate를 변경해보자.</p>

<h3 id="xml">XML</h3>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- Redis 설정 고통 부분--&gt;</span>
<span class="c">&lt;!-- Redis Serializer --&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"stringRedisSerializer"</span> <span class="na">class=</span><span class="s">"org.springframework.data.redis.serializer.StringRedisSerializer"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"jsonRedisSerializer"</span> <span class="na">class=</span><span class="s">"org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"jackson2JsonRedisSerializer"</span> <span class="na">class=</span><span class="s">"org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;constructor-arg&gt;</span>
        <span class="nt">&lt;value&gt;</span>java.util.Map<span class="nt">&lt;/value&gt;</span>
    <span class="nt">&lt;/constructor-arg&gt;</span>
<span class="nt">&lt;/bean&gt;</span>

<span class="c">&lt;!-- Redis Template --&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"redisTemplate"</span> <span class="na">class=</span><span class="s">"org.springframework.data.redis.core.RedisTemplate"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"connectionFactory"</span> <span class="na">ref=</span><span class="s">"jedisConnFactory"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"keySerializer"</span> <span class="na">ref=</span><span class="s">"stringRedisSerializer"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"valueSerializer"</span> <span class="na">ref=</span><span class="s">"jsonRedisSerializer"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"hashKeySerializer"</span> <span class="na">ref=</span><span class="s">"stringRedisSerializer"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"hashValueSerializer"</span> <span class="na">ref=</span><span class="s">"jsonRedisSerializer"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</code></pre></div></div>

<h3 id="java">JAVA</h3>

<p><strong>RedisTemplate 설정</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@EnableRedisRepositories</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedisTemplateConfig</span> <span class="o">{</span>

		<span class="nd">@Value</span><span class="o">(</span><span class="s">"${spring.redis.host}"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">redisHost</span><span class="o">;</span>
		<span class="nd">@Value</span><span class="o">(</span><span class="s">"${spring.redis.port}"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">redisPort</span><span class="o">;</span>

		<span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">RedisConnectionFactory</span> <span class="nf">redisConnectionFactory</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">LettuceConnectionFactory</span><span class="o">(</span><span class="n">redisHost</span><span class="o">,</span><span class="n">redisPort</span><span class="o">);</span>
		<span class="o">}</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">RedisTemplate</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="nf">redisTemplate</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">RedisTemplate</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">redisTemplate</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RedisTemplate</span><span class="o">&lt;&gt;();</span>
				<span class="n">redisTemplate</span><span class="o">.</span><span class="na">setKeySerializer</span><span class="o">(</span><span class="k">new</span> <span class="nc">StringRedisSerializer</span><span class="o">());</span>
				<span class="n">redisTemplate</span><span class="o">.</span><span class="na">setValueSerializer</span><span class="o">(</span><span class="k">new</span> <span class="nc">GenericJackson2JsonRedisSerializer</span><span class="o">());</span>
				<span class="n">redisTemplate</span><span class="o">.</span><span class="na">setHashKeySerializer</span><span class="o">(</span><span class="k">new</span> <span class="nc">StringRedisSerializer</span><span class="o">());</span>
				<span class="n">redisTemplate</span><span class="o">.</span><span class="na">setHashValueSerializer</span><span class="o">(</span><span class="k">new</span> <span class="nc">GenericJackson2JsonRedisSerializer</span><span class="o">());</span>
				<span class="k">return</span> <span class="n">redisTemplate</span><span class="o">;</span>
		<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>기존 xml 파일은 번거롭게 Serializer 클래스를 매번 bean으로 등록해서 redisTemplate에 주입했다.
그런데 자바코드는 간단하게 인스턴스만 생성해서 주입하고 있는 것을 확인할 수 있다.</p>

<p><br /></p>

<p><code class="language-plaintext highlighter-rouge">💡 참고로 RedisTemplate는 RedisTemplate뿐만 아니라 StringRedisTemplate 도 존재한다.  게시물 주제와 연관이 없으므로 자세한 내용은 생략한다.</code></p>

<p><br /></p>

<h2 id="redis-message-listener">🌟 Redis Message Listener</h2>

<p>이제 Redis Message Listener를 등록해보자.</p>

<h3 id="xml-1">XML</h3>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!--첫번째--&gt;</span>
 <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"redisKeyExpireMessageListener"</span> <span class="na">class=</span><span class="s">"org.springframework.data.redis.listener.adapter.MessageListenerAdapter"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;constructor-arg&gt;</span>
            <span class="nt">&lt;bean</span> <span class="na">class=</span><span class="s">"framework.redis.RedisKeyExpireMessageListener"</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/constructor-arg&gt;</span>
    <span class="nt">&lt;/bean&gt;</span>

<span class="c">&lt;!--두번째--&gt;</span>
  <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"redisContainer1"</span> <span class="na">class=</span><span class="s">"org.springframework.data.redis.listener.RedisMessageListenerContainer"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"connectionFactory"</span> <span class="na">ref=</span><span class="s">"jedisConnFactory"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"messageListeners"</span><span class="nt">&gt;</span>
          <span class="nt">&lt;map&gt;</span>
              <span class="nt">&lt;entry</span> <span class="na">key-ref=</span><span class="s">"redisKeyExpireMessageListener"</span><span class="nt">&gt;</span>
<span class="c">&lt;!--세번째--&gt;</span>
                  <span class="nt">&lt;bean</span> <span class="na">class=</span><span class="s">"org.springframework.data.redis.listener.PatternTopic"</span><span class="nt">&gt;</span>
                      <span class="nt">&lt;constructor-arg</span> <span class="na">value=</span><span class="s">"__keyevent@*:expired"</span><span class="nt">/&gt;</span>
                  <span class="nt">&lt;/bean&gt;</span>
              <span class="nt">&lt;/entry&gt;</span>
          <span class="nt">&lt;/map&gt;</span>
      <span class="nt">&lt;/property&gt;</span>
  <span class="nt">&lt;/bean&gt;</span>
</code></pre></div></div>

<ol>
  <li><code class="language-plaintext highlighter-rouge">MessageListenerAdapter</code> 빈에  <code class="language-plaintext highlighter-rouge">MessageListener</code> 를 주입한다.</li>
  <li><code class="language-plaintext highlighter-rouge">RedisMessageListenerContainer</code> 빈 등록 <code class="language-plaintext highlighter-rouge">connectionFactory</code>, <code class="language-plaintext highlighter-rouge">messageListeners</code> 주입</li>
  <li><code class="language-plaintext highlighter-rouge">redisKeyExpireMessageListener</code> 가 수신할 채널 혹은 패턴을 등록한다. 패턴은 이벤트 또는 채널명이 될 수 있다.</li>
</ol>

<h3 id="java-1">JAVA</h3>

<p><strong>MessageListenerAdapter 추가</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="nd">@Bean</span>
  <span class="kd">public</span> <span class="nc">MessageListenerAdapter</span> <span class="nf">messageListenerAdapter</span><span class="o">(</span><span class="nc">RedisKeyExpireMessageListener</span> <span class="n">redisKeyExpireMessageListener</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="k">new</span> <span class="nf">MessageListenerAdapter</span><span class="o">(</span><span class="n">redisKeyExpireMessageListener</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="nd">@Bean</span>
  <span class="kd">public</span> <span class="nc">RedisMessageListenerContainer</span> <span class="nf">redisMessageListenerContainer</span><span class="o">(</span>
          <span class="nc">RedisConnectionFactory</span> <span class="n">redisConnectionFactory</span>
          <span class="o">,</span> <span class="nc">MessageListenerAdapter</span> <span class="n">messageListenerAdapter</span><span class="o">,</span> <span class="nc">PatternTopic</span> <span class="n">patternTopic</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">RedisMessageListenerContainer</span> <span class="n">container</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RedisMessageListenerContainer</span><span class="o">();</span>
      <span class="n">container</span><span class="o">.</span><span class="na">setConnectionFactory</span><span class="o">(</span><span class="n">redisConnectionFactory</span><span class="o">);</span>
      <span class="n">container</span><span class="o">.</span><span class="na">addMessageListener</span><span class="o">(</span><span class="n">messageListenerAdapter</span><span class="o">,</span> <span class="n">patternTopic</span><span class="o">);</span>
      <span class="k">return</span> <span class="n">container</span><span class="o">;</span>
  <span class="o">}</span>

	<span class="nd">@Bean</span>
  <span class="kd">public</span> <span class="nc">PatternTopic</span> <span class="nf">patternTopic</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">return</span> <span class="k">new</span> <span class="nf">PatternTopic</span><span class="o">(</span><span class="s">"__keyevent@*:expired"</span><span class="o">);</span>
  <span class="o">}</span>
</code></pre></div></div>

<p><strong>MessageListenerAdapter 에 주입할 MessageListener 구현</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedisKeyExpireMessageListener</span> <span class="kd">implements</span> <span class="nc">MessageListener</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onMessage</span><span class="o">(</span><span class="nc">Message</span> <span class="n">message</span><span class="o">,</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">pattern</span><span class="o">)</span> <span class="o">{</span>
				
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
❗ spring boot 의 <code class="language-plaintext highlighter-rouge">@EnableAutoConfiguration</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>spring boot 는  프로젝트에 추가된 라이브러리를 기반으로 실행에 필요한 환경을 자동으로 설정해준다.
어떻게 보면 정말 편리한 기능이지만, 섬세한 설정이 필요한 경우엔 직접 설정하는 것이 안전하다.
</code></pre></div></div>

<h2 id="redis-cache-management">🌟 Redis Cache Management</h2>

<h3 id="xml-2">XML</h3>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- redis Cache 설정 --&gt;</span>
  <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"redisCachePrefix"</span> <span class="na">class=</span><span class="s">"org.springframework.data.redis.cache.DefaultRedisCachePrefix"</span> <span class="nt">&gt;</span>
      <span class="nt">&lt;constructor-arg</span> <span class="na">name=</span><span class="s">"delimiter"</span> <span class="na">value=</span><span class="s">"_"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;/bean&gt;</span>

  <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"cacheManager"</span> <span class="na">class=</span><span class="s">"org.springframework.data.redis.cache.RedisCacheManager"</span> <span class="na">primary=</span><span class="s">"true"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;constructor-arg</span> <span class="na">ref=</span><span class="s">"redisTemplate"</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"defaultExpiration"</span> <span class="na">value=</span><span class="s">"1000"</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"usePrefix"</span> <span class="na">value=</span><span class="s">"true"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"cachePrefix"</span> <span class="na">ref=</span><span class="s">"redisCachePrefix"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;/bean&gt;</span>
</code></pre></div></div>

<h3 id="java-2">JAVA</h3>
<p><strong>@EnableCaching 어노테이션 추가</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SpringBootApplication</span>
<span class="nd">@EnableCaching</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringBootStudyApplication</span> <span class="o">{</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="nc">SpringBootStudyApplication</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>@EnableCaching 어노테이션은 @Cacheable 메소드가 호출될 때 사용되는 CacheInterceptor 및 Proxy 또는 AspectJ 같은 캐시 관리에 필요한 스프링 구성요소를 등록하는 역할을 한다.</p>

<p>@EnableCaching 어노테이션 뿐만 아니라 xml 파일에서 cacheManger 를 선언해서 사용할 때도 동일하게 동작한다.</p>

<p><br /></p>

<p><strong>CacheManagerConfig.class</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@RequiredArgsConstructor</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CacheManagerConfig</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">RedisCacheConfig</span> <span class="n">redisCacheConfig</span><span class="o">;</span>

	<span class="nd">@Bean</span>
  <span class="kd">public</span> <span class="nc">CacheManager</span> <span class="nf">cacheManager</span><span class="o">(</span><span class="nc">RedisConnectionFactory</span> <span class="n">redisConnectionFactory</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="nc">RedisCacheManager</span><span class="o">.</span><span class="na">RedisCacheManagerBuilder</span>
              <span class="o">.</span><span class="na">fromConnectionFactory</span><span class="o">(</span><span class="n">redisConnectionFactory</span><span class="o">)</span>
              <span class="o">.</span><span class="na">cacheDefaults</span><span class="o">(</span><span class="n">getDefaultRedisCacheConfiguration</span><span class="o">())</span>
              <span class="o">.</span><span class="na">build</span><span class="o">();</span>
	<span class="o">}</span>

  <span class="kd">private</span> <span class="nc">RedisCacheConfiguration</span> <span class="nf">getDefaultRedisCacheConfiguration</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">return</span> <span class="nc">RedisCacheConfiguration</span><span class="o">.</span><span class="na">defaultCacheConfig</span><span class="o">()</span>
              <span class="o">.</span><span class="na">entryTtl</span><span class="o">(</span><span class="nc">Duration</span><span class="o">.</span><span class="na">ofSeconds</span><span class="o">(</span><span class="n">redisCacheConfig</span><span class="o">.</span><span class="na">getTtl</span><span class="o">()))</span>
              <span class="o">.</span><span class="na">prefixCacheNameWith</span><span class="o">(</span><span class="n">redisCacheConfig</span><span class="o">.</span><span class="na">getCachePrefix</span><span class="o">());</span>
	<span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p><strong>RedisCacheConfig.class</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="nd">@ConfigurationProperties</span><span class="o">(</span><span class="n">prefix</span><span class="o">=</span><span class="s">"config.redis.cache"</span><span class="o">)</span>
<span class="nd">@Getter</span>
<span class="nd">@Setter</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedisCacheConfig</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">cachePrefix</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">ttl</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">application.yml</code></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">config:</span>
  <span class="nl">redis:</span>
      <span class="nl">cache:</span>
        <span class="n">cache</span><span class="o">-</span><span class="nl">ttl:</span> <span class="mi">1000</span>
        <span class="n">cache</span><span class="o">-</span><span class="nl">prefix:</span> <span class="s">"_"</span>
</code></pre></div></div>

<h2 id="lettuce를-선택한-이유">🌟 Lettuce를 선택한 이유</h2>

<p>마지막으로 Redis Client로 Lettuce를 선택한 이유를 설명하고자 한다.</p>

<h3 id="lettuce란">Lettuce란?</h3>

<p>lettuce는 Netty 기반의 Redis Client로 동기, 비동기 및 대응적 사용을 위해 확장 가능한 Thread-Safe Redis Client이다.</p>

<p>트랜잭션을 사용하지 않는 경우 하나의 연결을 공유할 수 있다. 추가로 Sentinel, Cluster, Pipelining, Auto-Reconnect 및 Redis 데이터 모델과 같은 고급 Redis 기능을 지원한다.</p>

<h3 id="lettuce-장점">Lettuce 장점</h3>

<ul>
  <li>connection 인스턴스를 여러 쓰레드에서 공유할 수 있기 때문에 Thread-safe하다.</li>
  <li>Lettuce는 비동기로 요청을 처리하기 때문에 성능적인 이점이 있다. (비동기, 동기 둘 다 지원하기 때문에 유연하게 사용가능)</li>
  <li>Jedis보다 다양한 DataType지원</li>
</ul>

<p><br /></p>
<details>
  <summary>❗connection 인스턴스를 여러 쓰레드에서 공유할 수 있는 것이 장점인 이유는?</summary>
  <div>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Redis 서버 인스턴스는 여러 클라이언트에 연결하여 명령을 동시에 보내고 받을 수 있지만, 명령을 실행할 때 각 인스턴스는 단일 스레드이다.
    
이는 애플리케이션이 멀티스레딩+단일 연결을 통해 Redis를 운영할 수 있다면 Redis 서버의 전체 연결 수를 효율화 할 수 있고,
    
여러 애플리케이션이 동일한 Redis 서버를 공유할 때 더 나은 안정성과 성능을 얻을 수 있다는 것을 의미한다.
    
응용 프로그램의 경우 여러 인스턴스를 유지 관리하는 리소스 소비가 줄어든다.
</code></pre></div>    </div>
  </div>
</details>

<h3 id="lettuce-단점">Lettuce 단점</h3>

<ul>
  <li>connection 인스턴스의 공유라는 점에서 Thread-safe 한 것이기 때문에 Single-Thread로 동작하는 애플리케이션에서 레디스 데이터에 접근할 때는 또다르게 고려할 점이 생긴다.</li>
  <li>하나의 connection을 공유하기 때문에 connection pool을 생성하지 않으면 transaction을 사용할 수 없다.</li>
</ul>

<p><br /></p>

<h2 id="jedis와-lettuce-비교">🌟 Jedis와 Lettuce 비교</h2>

<p>그렇다면 Jedis와 Lettuce의 차이점이 무엇이길래 Springboot2 이후로는 Lettuce가 기본 Redis Client로 선택되었는지 알아보자
<br />
<br />
<br /></p>

<p><strong>Jedis보다 뛰어난 성능</strong></p>

<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>TPS(낮을수록 응답속도 빠름)</th>
      <th>Redis CPU</th>
      <th>Connections</th>
      <th>응답 속도</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Jedis</td>
      <td>31.000</td>
      <td>20%</td>
      <td>515</td>
      <td>1000ms</td>
    </tr>
    <tr>
      <td>Lettuce</td>
      <td>100,000</td>
      <td>7%</td>
      <td>6</td>
      <td>7.5ms</td>
    </tr>
  </tbody>
</table>

<p><br />
<br />
<br /></p>

<p><strong>Jedis와 Lettuce 기능비교</strong></p>

<table>
  <thead>
    <tr>
      <th>Supported Feature</th>
      <th>Lettuce</th>
      <th>Jedis</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Standalone Connection</td>
      <td>O</td>
      <td>O</td>
    </tr>
    <tr>
      <td>Master/Replica Connection</td>
      <td>O</td>
      <td> </td>
    </tr>
    <tr>
      <td>Redis Sentinel</td>
      <td>Master Lookup, Sentinel Authentication, Replica Redis</td>
      <td>Master Lookup</td>
    </tr>
    <tr>
      <td>Redis Cluster</td>
      <td>Cluster Connection, Cluster Node Connection, Replica Reads</td>
      <td>Cluster Connection, Cluster Node Connection</td>
    </tr>
    <tr>
      <td>Transport Channers</td>
      <td>TCP, OS-native TCP(epoll, kqueue), Unix Domain Sockets</td>
      <td>TCP</td>
    </tr>
    <tr>
      <td>Connection Pooling</td>
      <td>O(using commons-pool2)</td>
      <td>O(using commons-pool2)</td>
    </tr>
    <tr>
      <td>Other Connection Features</td>
      <td>Singleton-connection sharing for non-blocking commands</td>
      <td>JedisShardInfo support</td>
    </tr>
    <tr>
      <td>SSL Support</td>
      <td>O</td>
      <td>O</td>
    </tr>
    <tr>
      <td>Pub/Sub</td>
      <td>O</td>
      <td>O</td>
    </tr>
    <tr>
      <td>Pipelining</td>
      <td>O</td>
      <td>O</td>
    </tr>
    <tr>
      <td>Transactions</td>
      <td>O</td>
      <td>O</td>
    </tr>
    <tr>
      <td>DataType Support</td>
      <td>Key, String, List, Set, Sorted Set, Hash Server, Stream, Scriping, Geo, HyperLogLog</td>
      <td>Key, String, List, Set, Sorted Set, Scriping, Geo, HyperLogLog</td>
    </tr>
    <tr>
      <td>Reactive (non-blocking) API</td>
      <td>O</td>
      <td>O</td>
    </tr>
  </tbody>
</table>

<p><br />
<br /></p>

<p><strong><em>참고 → O 표시는 지원되는 기능이다.</em></strong></p>

<p>표로 jedis와 Lettuce의 기능을 비교해본 결과, 두 가지 차이점을 찾을 수 있다.</p>

<ul>
  <li>Jedis에서 지원하는 모든 기능을 Lettuce에서도 지원한다.</li>
  <li>Jedis에서 지원하지 않는 기능도 Lettuce에서 지원한다.</li>
</ul>

<p><br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br /></p>

<h1 id="reference">🌟<strong>**Reference</strong>**</h1>

<p><a href="http://arahansa.github.io/docs_spring/redis.html">http://arahansa.github.io/docs_spring/redis.html</a></p>

<p><a href="https://wnwngus.tistory.com/64">https://wnwngus.tistory.com/64</a></p>

<p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/EnableCaching.html">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/EnableCaching.html</a></p>

<p><a href="https://segmentfault.com/a/1190000040331000/en">https://segmentfault.com/a/1190000040331000/en</a></p>

<p><a href="https://mandlife.tistory.com/entry/Springboot-redis-%EC%84%A4%EC%A0%95-Jedis%EB%B3%B4%EB%8B%A4%EB%8A%94-Lettuce">https://mandlife.tistory.com/entry/Springboot-redis-설정-Jedis보다는-Lettuce</a></p>]]></content><author><name>ramram</name></author><category term="SpringBoot" /><category term="springBoot" /><category term="redis" /><category term="lettuce" /><summary type="html"><![CDATA[들어가며]]></summary></entry></feed>