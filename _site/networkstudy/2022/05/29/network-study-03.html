<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-translate-customization" content="108d9124921d80c3-80e20d618ff053c8-g4f02ec6f3dba68b7-c">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>[네트워크 스터디] Chapter_03 케이블의 앞은 LAN 기기였다. | Your awesome title</title>
<meta name="generator" content="Jekyll v4.2.2">
<meta property="og:title" content="[네트워크 스터디] Chapter_03 케이블의 앞은 LAN 기기였다.">
<meta name="author" content="GitHub User">
<meta property="og:locale" content="en_US">
<meta name="description" content="📗 Chapter_03 케이블의 앞은 LAN 기기였다. _허브와 스위치, 라우터의 탐험">
<meta property="og:description" content="📗 Chapter_03 케이블의 앞은 LAN 기기였다. _허브와 스위치, 라우터의 탐험">
<link rel="canonical" href="http://localhost:4000/networkstudy/2022/05/29/network-study-03.html">
<meta property="og:url" content="http://localhost:4000/networkstudy/2022/05/29/network-study-03.html">
<meta property="og:site_name" content="Your awesome title">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2022-05-29T00:00:00+09:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="[네트워크 스터디] Chapter_03 케이블의 앞은 LAN 기기였다.">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"GitHub User"},"dateModified":"2022-05-29T00:00:00+09:00","datePublished":"2022-05-29T00:00:00+09:00","description":"📗 Chapter_03 케이블의 앞은 LAN 기기였다. _허브와 스위치, 라우터의 탐험","headline":"[네트워크 스터디] Chapter_03 케이블의 앞은 LAN 기기였다.","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/networkstudy/2022/05/29/network-study-03.html"},"url":"http://localhost:4000/networkstudy/2022/05/29/network-study-03.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="shortcut icon" href="">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-noto-sans@0.0.72/index.min.css">
  <link rel="stylesheet" href="/assets/css/main.css">
  <script src="/assets/js/main.js"></script><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Your awesome title">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/languages/go.min.js"></script>



















<script>
// Init highlight js
document.addEventListener('DOMContentLoaded', function(event) {
  var els = document.querySelectorAll('pre code')

  function addLangData(block) {
    var outer = block.parentElement.parentElement.parentElement;
    var lang = block.getAttribute('data-lang');
    for (var i = 0; i < outer.classList.length; i++) {
      var cls = outer.classList[i];
      if (cls.startsWith('language-')) {
        lang = cls;
        break;
      }
    }
    if (!lang) {
      cls = block.getAttribute('class');
      lang = cls ? cls.replace('hljs ', '') : '';
    }
    if (lang.startsWith('language-')) {
      lang = lang.substr(9);
    }
    block.setAttribute('class', 'hljs ' + lang);
    block.parentNode.setAttribute('data-lang', lang);
  }

  function addBadge(block) {
    var enabled = ('true' || 'true').toLowerCase();
    if (enabled == 'true') {
      var pre = block.parentElement;
      pre.classList.add('badge');
    }
  }

  function handle(block) {
    addLangData(block);
    addBadge(block)
    hljs.highlightBlock(block);
  }

  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    handle(el);
  }
});
</script>

<style>
  /* code language badge */
  pre.badge::before {
    content: attr(data-lang);
    color: #fff;
    background-color: #ff4e00;
    padding: 0 .5em;
    border-radius: 0 2px;
    text-transform: uppercase;
    text-align: center;
    min-width: 32px;
    display: inline-block;
    position: absolute;
    right: 0;
  }

  /* fix wrong badge display for firefox browser */
  code > table pre::before {
    display: none;
  }
</style>
</head>
<body>



























































































































<header class="site-header " role="banner">

  <div class="wrapper">
    <div class="site-header-inner">
<span class="site-brand"><a class="site-brand-inner" rel="author" href="/">
  <img class="site-favicon" title="Your awesome title" src="" onerror="this.style.display='none'">
  Your awesome title
</a>
</span><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger">
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewbox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
              </svg>
            </span>
          </label>

          <div class="trigger">
<a class="page-link" href="/about.html">ABOUT</a><a class="page-link" href="/archives.html">ARCHIVES</a><a class="page-link" href="/categories.html">CATEGORIES</a><a class="page-link" href="/">HOME</a><a class="page-link" href="/tags.html">TAGS</a>









<span class="page-link">



<div id="google_translate_element" style="display: none;">
</div>

<span class="ct-language">
  <ul class="list-unstyled ct-language-dropdown">
    
      <li>
        <a href="#" class="lang-select" data-lang="en">
          
          <img src="https://cdn.countryflags.com/thumbs/united-states-of-america/flag-400.png" title="English">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="fr">
          
          <img src="https://cdn.countryflags.com/thumbs/france/flag-400.png" title="French">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="zh-CN">
          
          <img src="https://cdn.countryflags.com/thumbs/china/flag-400.png" title="Chinese(Simple)">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ja">
          
          <img src="https://cdn.countryflags.com/thumbs/japan/flag-400.png" title="Japanese">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ko">
          
          <img src="https://cdn.countryflags.com/thumbs/south-korea/flag-400.png" title="Korean">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ru">
          
          <img src="https://cdn.countryflags.com/thumbs/russia/flag-400.png" title="Russian">
          
        </a>
      </li>
    
  </ul>
</span>

<script type="text/javascript">
function googleTranslateElementInit() {
  new google.translate.TranslateElement({
    pageLanguage: 'en',
    autoDisplay: false,
    layout: google.translate.TranslateElement.InlineLayout.VERTICAL
  }, 'google_translate_element');

  // Links to cross-origin destinations are unsafe
  var gll = document.getElementsByClassName('goog-logo-link')[0];
  if (gll) {
    gll.setAttribute('rel', 'noopener');
  }

  function restoreLang() {
    var iframe = document.getElementsByClassName('goog-te-banner-frame')[0];
    if (!iframe) return;

    var innerDoc = iframe.contentDocument || iframe.contentWindow.document;
    var restore_el = innerDoc.getElementsByTagName("button");

    for (var i = 0; i < restore_el.length; i++) {
      if (restore_el[i].id.indexOf("restore") >= 0) {
        restore_el[i].click();
        var close_el = innerDoc.getElementsByClassName("goog-close-link");
        close_el[0].click();
        return;
      }
    }
  }

  function triggerHtmlEvent(element, eventName) {
    var event;
    if (document.createEvent) {
      event = document.createEvent('HTMLEvents');
      event.initEvent(eventName, true, true);
      element.dispatchEvent(event);
    } else {
      event = document.createEventObject();
      event.eventType = eventName;
      element.fireEvent('on' + event.eventType, event);
    }
  }

  var googleCombo = document.querySelector("select.goog-te-combo");
  var langSelect = document.querySelector('.ct-language');
  langSelect.addEventListener('click', function(event) {
    if (!event.target) {
      return;
    }

    var selected = document.querySelector('.ct-language .ct-language-selected');
    if (selected) {
      selected.classList.remove('ct-language-selected');
    }

    var target = event.target;
    while (target && target !== langSelect ) {
      if (target.matches('.lang-select')) {
        break;
      }
      target = target.parentElement;
    }

    if (target && target.matches('.lang-select')) {
      var lang = target.getAttribute('data-lang');
      if (googleCombo.value == lang) {
        restoreLang();
      } else {
        target.parentElement.classList.add('ct-language-selected');
        googleCombo.value = lang;
        triggerHtmlEvent(googleCombo, 'change');
      }
    }

    event.preventDefault();
  });
}
</script>

<script type="text/javascript" src="//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>
</span>
</div>
        </nav>
</div>
  </div>
</header>

<script>
  function initHeader() {
    var lastScrollY = getScrollPos().y;
    var documentElement = document.documentElement;

    function storeScrollData() {
      var y = getScrollPos().y;var scrollStatus = "";

      if (y <= 0) {
        scrollStatus = "top";
      } else if ((window.innerHeight + y) >= document.body.offsetHeight) {
        scrollStatus = "bottom";
      } else {
        var isScrollDown = (y - lastScrollY > 0) ? true : false;
        scrollStatus = isScrollDown ? "down" : "up";
      }

      lastScrollY = y;
      documentElement.setAttribute("data-scroll-status", scrollStatus);
    }

    window.addEventListener('scroll', function(e) {
      storeScrollData();
    });

    storeScrollData();
  }
  document.addEventListener('DOMContentLoaded', initHeader);
</script>
















































































































































<script>
  function hashLocate(hashValue) {
    hashValue = hashValue.replace(/^.*#h-/, '');
    hashValue = decodeURIComponent(hashValue);
    var element = document.getElementById(hashValue);

    if (!element) {
      return;
    }

    var header = document.querySelector('header.site-header');
    var headerRect = header.getBoundingClientRect();
    var headerTop = Math.floor(headerRect.top);
    var headerHeight = Math.floor(headerRect.height);
    var scrollPos = getScrollPos();
    var offsetY = element.offsetTop - (headerTop + headerHeight + 20);

    if (offsetY == scrollPos.y) {
      return;
    }

    if (headerTop == 0  && offsetY > scrollPos.y) {
      offsetY += headerHeight + 2;
    } else if (headerTop < 0  && offsetY < scrollPos.y) {
      offsetY -= headerHeight - 2;
    }

    smoothScrollTo(offsetY);
  }

  // The first event occurred
  window.addEventListener('load', function(event) {
    if (window.location.hash) {
      hashLocate(window.location.hash);
    }
  });

  // The first event occurred
  window.addEventListener('click', function(event) {
    if (event.target.tagName.toLowerCase() == 'a') {
      hashLocate(event.target.getAttribute('href'));
    }
  });
</script>
<div class="theme-toggle">
  <input type="checkbox" id="theme-switch">
  <label for="theme-switch">
    <div class="toggle"></div>
    <div class="names">
      <p class="light">Light</p>
      <p class="dark">Dark</p>
    </div>
  </label>
</div>




<script>
  (function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var nightModeOption = ('auto' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
      storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
      var data = storage.getItem('theme');
      try {
        data = JSON.parse(data ? data : '');
      } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
      }
      return data;
    }

    function handleThemeToggle(nightShift) {
      themeData.nightShift = nightShift;
      saveThemeData(themeData);
      html.dataset.theme = nightShift ? 'dark' : 'light';
      setTimeout(function() {
        sw.checked = nightShift ? true : false;
      }, 50);
    }

    function autoThemeToggle() {
      // Next time point of theme toggle
      var now = new Date();
      var toggleAt = new Date();
      var hours = now.getHours();
      var nightShift = hours >= 19 || hours <=7;

      if (nightShift) {
        if (hours > 7) {
          toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
      } else {
        toggleAt.setHours(19);
      }

      toggleAt.setMinutes(0);
      toggleAt.setSeconds(0);
      toggleAt.setMilliseconds(0)

      var delay = toggleAt.getTime() - now.getTime();

      // auto toggle theme mode
      setTimeout(function() {
        handleThemeToggle(!nightShift);
      }, delay);

      return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
      };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
      handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
      var data = autoThemeToggle();

      // Toggle theme by local setting
      if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
      } else {
        handleThemeToggle(themeData.nightShift);
      }
    } else if (nightModeOption == 'manual') {
      handleThemeToggle(themeData.nightShift);
    } else {
      var nightShift = themeData.nightShift;
      if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
      }
      handleThemeToggle(nightShift);
    }
  })();
</script>
<div id="click-to-top" class="click-to-top">
  <i class="fa fa-arrow-up"></i>
</div>
<script>
  (function () {
    const clickToTop = document.getElementById('click-to-top');
    window.addEventListener('scroll', () => {
      if (window.scrollY > 100) {
        clickToTop.classList.add('show')
      }else {
        clickToTop.classList.remove('show')
      }
    });
    clickToTop.addEventListener('click', () => {
      window.smoothScrollTo(0);
    });
  })();
</script>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="framework">
  <section class="main">

     <div class="post">
  <section>









<header class="post-header">
  <h1 class="post-title p-name" itemprop="name headline">[네트워크 스터디] Chapter_03 케이블의 앞은 LAN 기기였다.</h1>
  <h2 class="post-subtitle"></h2>

  <p class="post-meta">
    <time class="dt-published" datetime="2022-05-29T00:00:00+09:00" itemprop="datePublished"><i class="fa fa-calendar"></i> May 29, 2022
    </time>

    
    
































    <span class="post-reading-time left-vsplit"><i class="fa fa-clock-o"></i> About 10 mins</span>
  </p>
<div class="post-tags">
<a class="post-tag" href="/tags.html#%EB%A6%AC%ED%94%BC%ED%84%B0%20%ED%97%88%EB%B8%8C">#리피터 허브</a><a class="post-tag" href="/tags.html#%EC%8A%A4%EC%9C%84%EC%B9%AD%20%ED%97%88%EB%B8%8C">#스위칭 허브</a><a class="post-tag" href="/tags.html#%EB%9D%BC%EC%9A%B0%ED%8C%85">#라우팅</a>
</div></header>
<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

    <div class="post-content e-content" itemprop="articleBody">

      <h1 id="-chapter_03-케이블의-앞은-lan-기기였다-_허브와-스위치-라우터의-탐험">📗 Chapter_03 케이블의 앞은 LAN 기기였다. _허브와 스위치, 라우터의 탐험</h1>

<h3 id="3장의-요점-짚고-넘어가기-">🌟 3장의 요점 짚고 넘어가기 🌟</h3>

<blockquote>
  <p>해당 챕터는 클라이언트 PC가 가정이나 회사의 LAN에 접속되고, 앞부분이 ADSL이나 광섬유(FTTH)등의 광대역 회선에 의해 인터넷에 접속된다는 최신의 대표적인 상황을 가정하여 설명한다.</p>

  <p>이 경우 LAN 어댑터가 송신한 패킷은 스위칭 허브 등을 경유하여 인터넷 접속용 라우터에 도착한다. 라우터의 앞부분은 이미 인터넷이므로여기에서부터 앞부분은 통신사가 패킷을 상대에게 운반한다. 우체통에 봉투를 넣으면 그 후에는 집배원이 편지를 상대에게 전달하는 것과 유사하다.</p>

</blockquote>

<h1 id="1-케이블과-리피터-허브속을-신호가-흘러간다">1. 케이블과 리피터 허브속을 신호가 흘러간다.</h1>

<h3 id="하나하나의-패킷이-독립된-것으로-동작한다">하나하나의 패킷이 독립된 것으로 동작한다.</h3>

<p>컴퓨터에서 송신된 패킷은 허브나 라우터라는 중계 장치에 의해 중계되어 목적지에게 운반된다. 이때 중계장치는 패킷의 데이터 정보를 확인하지 않는다. 이는 애플리케이션의 데이터나 TCP 프로토콜의 제어정보는 패킷 운반 동작에 아무런 영향을 주지 못하는 것이다. 즉 HTTP 메세지나 TCP 수신확인 서버와 클라이언트의 관계 같은 것들은 모두 무시된다고 보면 된다. 따라서 모든 패킷은 독립적인 패킷으로 판단되어 목적지에 운반된다.</p>

<h3 id="lan-케이블은-신호를-약화시키지-않는-것이-핵심이다">LAN 케이블은 신호를 약화시키지 않는 것이 핵심이다</h3>

<p>LAN 어댑터가 흘려보낸 전기신호가 케이블을 통해 허브에 도착될 때 송출한 신호 그대로 허브에 도착하지 않는다. 케이블을 통과하는 사이에 신호의 에너지가 조금씩 떨어지므로 케이블의 길이가 길어질수록 신호가 약해진다.</p>

<p>신호가 약해지는 것 뿐만 아니라 이더넷의 경우 사각형의 각진 신호가 뭉개져서 둥글게 변한다. 신호의 각진 부분은 주파수가 높을수록 전압이 급격하게 변화하게 된다. 이처럼 급격하게 변화하다가 신호가 약해져서 변화가 없어질 때 각이 뭉개진다.</p>

<p>잡음이 없을 경우에도 신호가 도착할 때는 변형돼서 도착할 때가 대부분인데 잡음의 영향까지 더해지면 매우 심각하게 변화한다. 약해진 신호가 더욱 변형되어 0과 1을 잘못 판독할 수 있는데 이것이 통신 오류의 원인이 될 수 있다.</p>

<h3 id="리피터-허브는-연결되어-있는-전체-케이블에-신호를-송신한다">리피터 허브는 연결되어 있는 전체 케이블에 신호를 송신한다.</h3>

<p>신호가 리피터 허브에 도달하면 리피터 허브는 LAN 전체에 신호를 흘린다. 이더넷의 기본 원리인 전체에 패킷의 신호를 뿌리고 수신처 MAC주소에 해당하는 기기만 패킷을 수신한다는 원리를 그대로 실현했다고 보면 된다.</p>

<p>리피터 허브의 내부는 아래 그림과 같은데 각 커넥터의 안쪽에는 LAN 어댑터 내부에 있는 PHY 회로와 역할이 같은 회로가 존재한다. 이를 LAN 어댑터 측과 같이 RJ-45 커넥터에 직접 접속하면 신호를 제대로 수신할 수 없다. 제대로 신호를 수신하려면 <strong>‘송신 단자’</strong>의 신호를 <strong>‘수신 단자’</strong>로 받도록 해야한다. 회로와 커넥터 사이의 신호선을 교차하는 이유는 이 때문이다.</p>

<p>리피터 허브의 끝 커넥터에는 <strong>MDI/MDI-X</strong> 라는 전환 스위치가 존재한다. MDI는 RJ-45 커넥터와 신호 송수신 회로를 직접 결선한 것이고 MDI-X는 교차하여 결선하는 것을 나타낸다. 허브의 커넥터 부분은 보통 MDI-X 이므로 허브끼리 접속할 때는 한쪽을 MDI로 설정해야 한다. MDI로 전환하는 스위치가 없고 모든 커넥터가 MDI-X인 경우에는 크로스 케이블로 허브들에 접속한다.</p>

<p><img src="https://user-images.githubusercontent.com/56028408/165674870-5c7164fe-ca2b-4209-acb3-0e01af53d00a.png" alt="image"></p>

<p><strong>✔️  리피터 허브</strong></p>

<ul>
  <li>이더넷의 기본을 따르는 하드웨어</li>
  <li>리피터 허브에 도달한 신호를 LAN 전체에 전달하지만 수신처 MAC 주소에 해당하는 패킷만 수신한다.</li>
  <li>전체에 패킷의 신호를 뿌리고 수신처 MAC 주소에 해당하는 기기만 패킷을 수신한다는 의미
    <ul>
      <li>MAC 헤더의 값을 확인 함</li>
    </ul>
  </li>
  <li>리피터 허브의 내부에는 PHY(MAU) 회로와 역할이 같은 회로가 존재한다.</li>
  <li>리피터 허브의 끝 커넥터에서는 MDI/MDI-X와 같이 쓰여있는 전환 스위치가 존재한다.</li>
  <li>MDI로 전환하는 스위치가 없고 모든 커넥터가 MDI-X인 경우에는 크로스 케이블로 허브들에 접속한다.</li>
  <li>잡음의 영향을 받아 데이터가 변화한 것 같은 신호도 전송한다.</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">💡</span> <span class="err">리피터</span> <span class="err">허브는</span> <span class="err">연결된</span> <span class="err">케이블</span> <span class="err">전체에</span> <span class="err">신호를</span> <span class="err">송신한다</span><span class="p">.</span>
</code></pre></div></div>

<h1 id="2-스위칭-허브의-패킷중계-동작">2. 스위칭 허브의 패킷중계 동작</h1>

<h3 id="스위칭-허브는-주소-테이블로-중계한다">스위칭 허브는 주소 테이블로 중계한다</h3>

<p><strong>“스위칭 허브”</strong> 의 신호가 커넥터 부분에 도달하여 PHY 회로에서 수신되는 부분까지는 리피터 허브와 동일하다. PHY 회로에서 케이블을 흐르는 신호의 형식부터 공통의 신호 형식으로 변환한 후 신호는 MAC 회로에 들어간다. 이후 패킷을 디지털 데이터로 변환한 후 패킷의 맨 끝에 있는 FCS를 대조하여 오류의 유무를 검사하고 문제가 없으면 버퍼 메모리에 저장하고 오류가 있었던 패킷이면 폐기한다. 이 부분은 LAN 어댑터와 거의 같고 각 스위칭 허브의 커넥터 안쪽에는 LAN 어댑터와 같은 회로가 존재한다.</p>

<p>커넥터 안쪽에 있는 회로 부분을 포트라고 한다. 스위칭 허브의 각 포트는 PC의 LAN 어댑터와 거의 같지만 스위칭 허브의 포트는 MAC 주소를 검사하지 않고 모든 패킷을 수신하여 버퍼 메모리에 저장하기 때문에 스위칭 허브의 포트에는 LAN 어댑터와 달리 MAC 주소가 할당되어 있지 않다.</p>

<p>패킷을 버퍼 메모리에 저장하면 MAC 주소와 일치하는 것이 MAC 주소표에 등록되어 있는 지 조사한다.  주소표에 수신처 주소와 동일한 MAC 주소가 존재하면 주소표에쓰여있는 포트 위치에 패킷을 송신한다.</p>

<p>포트사이에 패킷을 운반할 때는 “<strong>스위치 회로”</strong> 에 패킷의 신호를 흘린다. 예를 들어 2번 포트에서 7번 포트로 패킷을 운반하려면 신호는 2번에서 들어올 것이다. 이때 선의 가로로 나열된 스위치의 왼쪽에서 7개까지의 스위치는 가로방향으로, 8번째의 스위치는 세로방향으로 전환한다.  그러면 아래 그림과 같이 신호는 출력측의 7번으로 흘러가서 7번 포트에 패킷이 도착한다. 이처럼 신호의 교점에 있는 스위치는 각각 독립적으로 움직이므로 신호가 중복되지 않으면 복수의 신호를 흘릴 수 있다.</p>

<p><img src="https://user-images.githubusercontent.com/56028408/165674867-1b3b5560-d81f-4548-a926-1797fb1aa1b7.png" alt="image"></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">💡</span> <span class="err">스위칭</span> <span class="err">허브는</span> <span class="n">MAC</span> <span class="err">주소표에서</span> <span class="n">MAC</span> <span class="err">주소를</span> <span class="err">조사하고</span> <span class="err">해당하는</span> <span class="err">포트에</span> <span class="err">신호를</span> <span class="err">송신한다</span><span class="p">.</span>
</code></pre></div></div>

<p>✔️ <strong>스위칭 허브</strong></p>

<ul>
  <li>스위치 내부에는 MAC 주소와 포트번호를 등록한 테이블이 존재한다.
    <ul>
      <li>여기에는 수신포트와 송신 포트도 함께 등록된다.</li>
    </ul>
  </li>
  <li>스위치 내부 테이블 정보를 확인하고 패킷을 중계한다. (목적지 확인)</li>
  <li>스위치 허브의 포트에는 MAC 주소가 할당되어 있지 않다.</li>
  <li>누군가 스위칭 허브에서 신호를 송신 중이면 신호를 보내지 않고 대기한다.</li>
  <li>신호의 교점에 있는 스위치는 독립적이므로 신호가 중복되지 않으면 복수의 신호를 동시에 흘린다.</li>
  <li>패킷이 충돌하지 않도록 재밍신호를 보낸다.</li>
</ul>

<p>✔️ <strong>스위치 회로의 구조</strong></p>

<ul>
  <li>그림과 같은 구조를 전자회로로 만든 것</li>
  <li>신호선은 격자 모양으로 배치되고 교점에 스위치가 존재함</li>
  <li>스위치는 전자적으로 개폐를 제어할 수 있음</li>
  <li>전자적 개폐를 통해 신호가 흐르는 대상을 제어함</li>
  <li>입력측은 수신측 포트에 접속되어 있고 출력측은 송신측 포트에 접속되어 있음</li>
</ul>

<h3 id="mac-주소-테이블을-등록-및-갱신한다">MAC 주소 테이블을 등록 및 갱신한다.</h3>

<p>스위칭 허브는 패킷을 중계할 때 MAC 주소표의 내용을 갱신하는 동작도 실행한다. 갱신 동작에는 두 가지 종류가 있다. 첫번째는 패킷을 수신했을 때 송신처 MAC 주소를 조사하고, 수신한 입력 포트 번호와 하나의 세트로 MAC 주소표에 등록하는 것이다.</p>

<p>MAC 주소표를 등록하는 동작 말고도 등록되어 있는 내용을 지우는 또 하나의 동작이 존재한다. 이것은 기기를 이동했을 때 이동한 기기의 정보 수정없이 패킷을 전달하는 작업을 방지하기 위한 동작이다. 스위치 허브는 오래된 정보를 갱신하기 위해 일정시간 동안 사용되지 않은 정보를 지운다.</p>

<p>✔️ <strong>스위칭 허브의 두 가지 갱신 동작</strong></p>

<ul>
  <li>송신처 MAC 주소 조사 후 수신한 입력포트와 하나의 세트로 MAC 주소표에 등록</li>
  <li>사용하지 않고 일장시간이 지나면 등록된 정보를 삭제하는 동작</li>
</ul>

<h2 id="예외적인-동작">예외적인 동작</h2>
<p>스위칭 허브와 리피터 허브가 같이 접속할 때 송신 포트가 패킷을 수신한 포트와 같을 수 있다. 이때 스위칭 허브는 수신한 포트와 송신하는 포트가 같은 것을 확인하고 같은 값이라면 패킷을 폐기한다. 이뿐만 아니라 MAC 주소표에 수신처 MAC 주소와 일치하는 주소가 등록되어있지 않은 경우도 있다. 이 경우에는 어느 포트에서 송신해야 할지 판단할 수 없으므로 패킷을 수신한 포트 이외의 전체 포트에 패킷을 송신한다. 또한 수신처 MAC 주소가 브로드캐스트 주소인 경우에도 수신 포트를 제외하고 모든 포트에서 패킷을 송신한다.</p>

<h2 id="스위칭-허브는-복수의-중계-동작을-동시에-실행한다">스위칭 허브는 복수의 중계 동작을 동시에 실행한다</h2>

<p>스위칭 허브는 수신처 MAC 주소의 기기가 존재하는 포트 이외에는 송신동작을 실행하지 않으므로 다른 포트는 빈    상태가 된다. 비어있는 포트에는 별도의 패킷을 흘릴 수 있으므로 스위칭 허브는 동시에 여러개의 패킷을 중계할 수 있다. 반면 리피터 허브는 들어온 신호를 모든 포트에 뿌리므로 동시에 두 개 이상의 신호가 들어오면 패킷이 충돌하기 때문에 복수의 신호를 동시에 흘릴 수 없다.</p>

<h1 id="3-라우터의-패킷-중계-동작">3. 라우터의 패킷 중계 동작</h1>

<h3 id="라우터의-기본">라우터의 기본</h3>

<p>라우터의 원리도 스위칭 허브와 비슷하다. 그러나 구체적인 동작은 스위칭 허브와 다른데 라우터는 스위칭 허브와 달리 IP라는 개념을 바탕으로 하기 때문이다. 라우터의 내부 구조는 중계 부분과 포트 부분이라는 두 부분으로 구성되어 있다. 라우터의 중계 부분과 포트 부분의 역할은 LAN 어댑터의 역할 분담과 같다. 즉 라우터의 중계 부분은 IP를 담당하고 포트 부분은 LAN 어댑터와 같다고 생각하면 된다.</p>

<p><img src="https://user-images.githubusercontent.com/56028408/165739277-13c76eb2-cacd-45f4-b842-86189f8fc284.png" alt="image"></p>

<p><strong>✔️ 라우터의 원리</strong></p>

<ul>
  <li>패킷은 라우터의 포트 부분에서 수신한다. (포트 부분의 하드웨어에 의뢰하여 패킷을 수신)</li>
  <li>패킷 수신 동작은 포트 부분에 연결된 하드웨어의 통신규칙에 따른다.</li>
  <li>중계 부분에서는 받은 패킷의 IP 패킷에 기록되어있는 수신처 IP 주소와 중계 대상을 등록한 표를 대조하여 중계 대상을 판단한다.</li>
  <li>라우터는 스위칭 허브와 달리 송신처나 수신처 둘 다 될 수 있음</li>
  <li>라우터의 포트에는 IP주소가 할당되어 있음 만약 포트가 이더넷인 경우 MAC도 같이 할당 됨</li>
</ul>

<p><strong>✔️ 라우터의 구성</strong></p>

<ul>
  <li>중계 부분과 포트 구분으로 구성되어 있음</li>
  <li>IP개념을 바탕으로 설계되어 있음</li>
  <li>라우터의 중계 부분이 패킷의 중계 대상을 판단함</li>
  <li>라우터의 포트 부분은 패킷의 송수신 동작을 담당함</li>
  <li>라우터의 포트 부분에는 다양한 하드웨어를 장착할 수 있고 라우터는 장착한 하드웨어에 맞는 통신 기술을 지원함</li>
</ul>

<h3 id="경로표에-등록된-정보">경로표에 등록된 정보</h3>

<p>라우터는 스위칭 허브와 달리 IP 헤더에 기재되어 있는 <strong>수신처 IP 주소로 중계 대상을 판단</strong>한다. 라우터는 스위칭 허브와 취급하는 주소가 다르므로 중계 대상을 등록하는 테이블의 내용도 다르다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">💡</span> <span class="err">라우터는</span> <span class="n">IP</span> <span class="err">주소로</span> <span class="err">중계</span> <span class="err">대상을</span> <span class="err">판단한다</span><span class="p">.</span>
</code></pre></div></div>

<p>라우터의 테이블은 <strong>라우팅 테이블</strong> 또는 <strong>경로표</strong>라고 불린다. 여기엔 아래와 같은 정보들이 등록되어 있다.</p>

<table>
  <thead>
    <tr>
      <th>수신처(Destination)</th>
      <th>넷마스크(Netmast)</th>
      <th>게이트웨이(Gateway)</th>
      <th>인터페이스(Interface)</th>
      <th>메트릭(Metric)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>10.10.1.0</td>
      <td>255.255.255.0</td>
      <td> </td>
      <td>e2</td>
      <td>1</td>
    </tr>
    <tr>
      <td>10.10.1.101</td>
      <td>255.255.255.255</td>
      <td> </td>
      <td>e2</td>
      <td>1</td>
    </tr>
    <tr>
      <td>192.168.1.0</td>
      <td>255.255.255.0</td>
      <td> </td>
      <td>e3</td>
      <td>1</td>
    </tr>
    <tr>
      <td>192.168.1.10</td>
      <td>255.255.255.255</td>
      <td> </td>
      <td>e3</td>
      <td>1</td>
    </tr>
    <tr>
      <td>0.0.0.0</td>
      <td>0.0.0.0</td>
      <td>192.0.2.1</td>
      <td>e1</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p><strong>✔️  라우팅 테이블 속성 정보</strong></p>

  <ul>
    <li>수신처
      <blockquote>
        <ul>
          <li>서브넷 자체를 나타내는 주소, 라우터가 중계할 대상</li>
        </ul>
      </blockquote>
    </li>
    <li>넷마스크
      <blockquote>
        <ul>
          <li>넷마스크 값에 따라 네트워크의 비트 수를 판단함</li>
        </ul>
      </blockquote>
    </li>
    <li>게이트웨이
      <blockquote>
        <ul>
          <li>라우터가 수신처에게 패킷을 전송할 때 거쳐야 하는 곳</li>
        </ul>
      </blockquote>
    </li>
    <li>인터페이스
      <blockquote>
        <ul>
          <li>인터페이스 항목에 등록되어있는 인터페이스(포트)에서 게이트웨이 항목에 등록되어있는 IP 주소를 가진 라우터에게 패킷을 중계함</li>
        </ul>
      </blockquote>
    </li>
    <li>메트릭
      <blockquote>
        <ul>
          <li>수신처 IP에 기록되어 있는 주소가 먼지, 가까운지를 판단하는 값</li>
        </ul>
      </blockquote>
    </li>
  </ul>
</blockquote>

<p>라우팅 테이블 수신처 항목에는 서브넷을 나타내는 IP 말고도  <strong>주소 집약</strong> 이라는 개념을 사용하여 몇개의 서브넷을 한개의 서브넷으로 간주한 후 묶은 서브넷을 경로표에 등록하기도 한다. 예를 들어 A 라우터에 10.10.1.0/24, 10.10.2.0/24, 10.10.3.0/24 서브넷이 연결되어 있을 때 B 라우터는 A라우터에 연결되어 있는 서브넷에게 패킷을 건낼 때 A 라우터에 패킷을 중계해야 한다는 사실은 변하지 않으므로 3개의 서브넷을 일괄적으로 통합하여 라우팅 테이블에 등록한다. 이것을 <strong>주소 집약</strong> 이라고 한다.</p>

<p><img src="https://user-images.githubusercontent.com/56028408/165739256-7e87212d-d23c-477d-b71d-0a69d1d453ba.png" alt="image"></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">💡</span> <span class="err">라우터는</span> <span class="err">호스트</span> <span class="err">번호를</span> <span class="err">무시하고</span> <span class="err">네트워크</span> <span class="err">번호</span> <span class="err">부분만</span> <span class="err">조사한다</span><span class="p">.</span>
<span class="err">💡</span> <span class="err">라우터의</span> <span class="err">경로표에서</span> <span class="err">'넷마스크'</span> <span class="err">항목은</span> <span class="err">경로표의</span> <span class="err">수신처와</span> <span class="err">패킷의</span> <span class="err">수신처</span> <span class="err">주소를</span> <span class="err">대조할</span> <span class="err">때</span> <span class="err">비트</span> <span class="err">수를</span> <span class="err">나타낸다</span><span class="p">.</span>
</code></pre></div></div>

<h3 id="라우터의-패킷-수신-동작">라우터의 패킷 수신 동작</h3>

<p>라우터 포트에는 MAC 주소와 IP가 할당되어 있으며 라우터는 자신의 주소에 해당하는 패킷만 수신하고 해당하지 않는 패킷은 폐기한다.</p>

<h3 id="경로표를-검색하여-출력-포트를-발견한다">경로표를 검색하여 출력 포트를 발견한다.</h3>

<p>MAC 헤더의 역할은 라우터에게 패킷을 건네주는 것이다. 때문에 라우터는 패킷 수신 동작이 끝나면 맨 앞의 MAC 헤더를 폐기한다. 수신동작이 끝나면 MAC 헤더 뒤에 있는 IP 헤더의 내용을 보고 패킷 중계 동작에 들어간다.</p>

<p><strong>✔️ 중계 동작</strong></p>
<ol>
  <li>수신한 패킷의 IP 주소와 경로표에 등록된 수신처 항목을 대조한다.</li>
  <li>복수의 후보가 발견되면 네트워크 번호의 비트 수가 가장 긴 것을 찾는다.</li>
  <li>네트워크 번호의 비트 수가 동일한 것이 존재하면 메트릭 값으로 판단한다.</li>
  <li>해당하는 행이 하나도 발견되지 않을 경우 패킷을 폐기하고 ICMP 메세지로 송신처에 통지한다.</li>
</ol>

<p><br></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">💡</span> <span class="err">라우터에서</span> <span class="err">중계하는</span> <span class="err">패킷의</span> <span class="err">수신처</span> <span class="n">MAC</span> <span class="err">주소에는</span> <span class="err">라우터의</span> <span class="err">포트에</span> <span class="err">할당된</span> <span class="n">MAC</span> <span class="err">주소가</span> <span class="err">기록되어</span> <span class="err">있다</span><span class="p">.</span>
</code></pre></div></div>

<h1 id="reference">Reference</h1>

<p>성공과 실패를 결정하는 1%의 네트워크</p>


    </div>

</article>
<div class="post-nav">
<a class="previous" href="/daily/2022/05/14/%EA%B8%80%EB%98%907%EA%B8%B0-%EB%8B%A4%EC%A7%90.html" title="[글또 7기] 다짐">[글또 7기] 다짐</a><a class="next" href="/networkstudy/2022/06/08/network-study-04.html" title="[네트워크 스터디] Chapter_04 엑세스 회선을 통해 인터넷의 내부로 !">[네트워크 스터디] Chapter_04 엑세스 회선을 통해...</a>
</div>
<div class="post-related">
      <div>Related Articles</div>
      <ul>
        <li><a class="post-link" href="/networkstudy/2022/06/08/network-study-04.html" title="[네트워크 스터디] Chapter_04 엑세스 회선을 통해 인터넷의 내부로 !">[네트워크 스터디] Chapter_04 엑세스 회선을 통해 인터넷의 내부로 !</a></li>
<li><a class="post-link" href="/os/2022/04/15/os-study-09.html" title="[네트워크 스터디] Chapter_04 엑세스 회선을 통해 인터넷의 내부로 !">[운영체제 스터디] 메모리 관리 - 논리적 주소와 물리적 주소</a></li>
<li><a class="post-link" href="/os/2022/04/04/os-study-08.html" title="[네트워크 스터디] Chapter_04 엑세스 회선을 통해 인터넷의 내부로 !">[운영체제 스터디] 데드락과 데드락 발생조건 4가지</a></li>
<li><a class="post-link" href="/os/2022/03/22/os-study-04.html" title="[네트워크 스터디] Chapter_04 엑세스 회선을 통해 인터넷의 내부로 !">[운영체제 스터디] 프로세스 생성과 프로세스의 협력</a></li>
</ul>
    </div>
<div class="post-comments"></div></section>
</div>


  </section>
  <section class="sidebar" style="margin-left: 15px;">
    <!-- Get sidebar items --><style type="text/css" media="screen">
.post-menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
</style>

<div class="post-menu">
  <div class="post-menu-title">TOC</div>
  <div class="post-menu-content"></div>
</div>

<script>
  function generateContent() {
    var menu = document.querySelector(".post-menu");
    var menuContent =  menu.querySelector(".post-menu-content");
    var headings = document.querySelector(".post-content").querySelectorAll("h2, h3, h4, h5, h6");

    // Hide menu when no headings
    if (headings.length === 0) {
      return menu.style.display = "none";
    }

    // Generate post menu
    var menuHTML = '';
    for (var i = 0; i < headings.length; i++) {
      var h = headings[i];
      menuHTML += (
        '<li class="h-' + h.tagName.toLowerCase() + '">'
        + '<a href="#h-' + h.getAttribute('id') + '">' + h.textContent + '</a></li>');
    }

    menuContent.innerHTML = '<ul>' + menuHTML + '</ul>';

    // The header element
    var header = document.querySelector('header.site-header');

    function doMenuCollapse(index, over_items) {
      var items = menuContent.firstChild.children;

      if (over_items == undefined) {
        over_items = 20;
      }

      if (items.length < over_items) {
        return;
      }

      var activeItem = items[index];
      var beginItem = activeItem
      var endItem = activeItem
      var beginIndex = index;
      var endIndex = index + 1;
      while (beginIndex >= 0
        && !items[beginIndex].classList.contains('h-h2')) {
        beginIndex -= 1;
      }
      while (endIndex < items.length
        && !items[endIndex].classList.contains('h-h2')) {
        endIndex += 1;
      }
      for (var i = 0; i < beginIndex; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
      for (var i = beginIndex + 1; i < endIndex; i++) {
        item = items[i]
        // if (!item.classList.contains('h-h2')) {
          item.style.display = '';
        // }
      }
      for (var i = endIndex; i < items.length; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
    }

    // Init menu collapsed
    doMenuCollapse(-1);

    // Active the menu item
    window.addEventListener('scroll', function (event) {
      var lastActive = menuContent.querySelector('.active');
      var changed = true;
      var activeIndex = -1;
      for (var i = headings.length - 1; i >= 0; i--) {
        var h = headings[i];
        var headingRect = h.getBoundingClientRect();
        var headerRect = header.getBoundingClientRect();
        var headerTop = Math.floor(headerRect.top);
        var headerHeight = Math.floor(headerRect.height);
        var headerHeight = headerTop + headerHeight + 20;
        if (headingRect.top <= headerHeight) {
          var id = 'h-' + h.getAttribute('id');
          var a = menuContent.querySelector('a[href="#' + id  + '"]');
          var curActive = a.parentNode;
          if (curActive) {
            curActive.classList.add('active');
            activeIndex = i;
          }
          if (lastActive == curActive) {
            changed = false;
          }
          break;
        }
      }
      if (changed) {
        if (lastActive) {
          lastActive.classList.remove('active');
        }
        doMenuCollapse(activeIndex);
      }
      event.preventDefault();
    });
  }
  generateContent();
</script>
</section>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">
    <div class="site-footer-inner">
<div>Unpublished Work <span class="copyleft">©</span> 2017-2022 GitHub User</div>
      <div>Powered by <a title="Jekyll is a simple, blog-aware, static site
      generator." href="https://jekyllrb.com/">Jekyll</a> &amp; <a title="Yat, yet
      another theme." href="https://github.com/jeffreytse/jekyll-theme-yat">Yat Theme</a>.</div>
      <div class="footer-col rss-subscribe">Subscribe <a href="/feed.xml">via RSS</a>
</div>
    </div>
  </div>
</footer>
</body>
</html>
